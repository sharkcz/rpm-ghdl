diff -urN ghdl-0.27/README ghdl-0.28dev/README
--- ghdl-0.27/README	2008-07-01 01:59:59.000000000 +0200
+++ ghdl-0.28dev/README	2009-09-20 09:07:54.000000000 +0200
@@ -4,7 +4,7 @@
 
 Copyright:
 **********
-GHDL is copyright (c) 2002, 2003, 2004, 2005, 2006, 2007 Tristan Gingold.
+GHDL is copyright (c) 2002 - 2008 Tristan Gingold.
 See the GHDL manual for more details.
 
 This program is free software; you can redistribute it and/or modify
@@ -27,9 +27,9 @@
 ***************************
 
 Required:
-* the sources of gcc-4.2.4 (at least the core part).
+* the sources of gcc-4.3.1 (at least the core part).
   Note: other versions of gcc sources have not been tested.
-* the Ada95 GNAT compiler (GNAT GPL 2005 are known to work;
+* the Ada95 GNAT compiler (GNAT GPL 2008 are known to work;
   Ada compilers in most Linux distributions are more or less buggy)
 * GNU/Linux for ix86 (pc systems) (porting is necessary for other systems)
 
@@ -53,12 +53,12 @@
   file from it).
 * move or copy the vhdl directory of ghdl into the gcc subdirectory of
   the gcc distribution.
-  You should have a gcc-4.2.4/gcc/vhdl directory.
+  You should have a gcc-4.3.1/gcc/vhdl directory.
 * configure gcc with the --enable-languages=vhdl option.  You may of course
   add other languages.
   Refer to the gcc installation documentation.
 * compile gcc.
-  'make CFLAGS="-O"' is OK (gcc 2.8.1 bugs with -O2 on some files).
+  'make CFLAGS="-O"' is OK
 * install gcc.  This installs the ghdl driver too.
   'make install' is OK.
 
diff -urN ghdl-0.27/vhdl/back_end.adb ghdl-0.28dev/vhdl/back_end.adb
--- ghdl-0.27/vhdl/back_end.adb	2005-09-22 23:26:01.000000000 +0200
+++ ghdl-0.28dev/vhdl/back_end.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,11 +12,10 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
-with Flags;
-with Types; use Types;
+with Flags; use Flags;
 with Iirs_Utils; use Iirs_Utils;
 
 package body Back_End is
@@ -27,11 +26,13 @@
      return String
    is
    begin
-      case Flags.Vhdl_Std is
+      case Vhdl_Std is
          when Vhdl_87 =>
             return Image_Identifier (Library) & "-obj87.cf";
          when Vhdl_93c | Vhdl_93 | Vhdl_00 | Vhdl_02 =>
             return Image_Identifier (Library) & "-obj93.cf";
+         when Vhdl_08 =>
+            return Image_Identifier (Library) & "-obj08.cf";
       end case;
    end Default_Library_To_File_Name;
 end Back_End;
diff -urN ghdl-0.27/vhdl/back_end.ads ghdl-0.28dev/vhdl/back_end.ads
--- ghdl-0.27/vhdl/back_end.ads	2006-08-16 08:17:07.000000000 +0200
+++ ghdl-0.28dev/vhdl/back_end.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
diff -urN ghdl-0.27/vhdl/bug.adb ghdl-0.28dev/vhdl/bug.adb
--- ghdl-0.27/vhdl/bug.adb	2006-08-19 13:56:15.000000000 +0200
+++ ghdl-0.28dev/vhdl/bug.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Ada.Text_IO; use Ada.Text_IO;
diff -urN ghdl-0.27/vhdl/bug.ads ghdl-0.28dev/vhdl/bug.ads
--- ghdl-0.27/vhdl/bug.ads	2005-10-15 13:34:53.000000000 +0200
+++ ghdl-0.28dev/vhdl/bug.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Ada.Exceptions; use Ada.Exceptions;
diff -urN ghdl-0.27/vhdl/canon.adb ghdl-0.28dev/vhdl/canon.adb
--- ghdl-0.27/vhdl/canon.adb	2007-03-21 04:47:14.000000000 +0100
+++ ghdl-0.28dev/vhdl/canon.adb	2009-09-20 09:06:46.000000000 +0200
@@ -1,5 +1,5 @@
 --  Canonicalization pass
---  Copyright (C) 2002, 2003, 2004, 2005 Tristan Gingold
+--  Copyright (C) 2002, 2003, 2004, 2005, 2008 Tristan Gingold
 --
 --  GHDL is free software; you can redistribute it and/or modify it under
 --  the terms of the GNU General Public License as published by the Free
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Errorout; use Errorout;
@@ -21,9 +21,8 @@
 with Name_Table;
 with Sem;
 with Std_Names;
-with Types; use Types;
 with Iir_Chains; use Iir_Chains;
-with Flags;
+with Flags; use Flags;
 
 package body Canon is
    --  Canonicalize a list of declarations.  LIST can be null.
@@ -239,6 +238,10 @@
             --Canon_Extract_Sensitivity
             --  (Get_Prefix (Expr), Sensitivity_List, Is_Target);
 
+         when Iir_Kinds_Scalar_Type_Attribute =>
+            Canon_Extract_Sensitivity
+              (Get_Parameter (Expr), Sensitivity_List, Is_Target);
+
          when Iir_Kind_Aggregate =>
             declare
                Aggr_Type : Iir;
@@ -270,6 +273,226 @@
       end case;
    end Canon_Extract_Sensitivity;
 
+   procedure Canon_Extract_Sensitivity_If_Not_Null
+     (Expr: Iir; Sensitivity_List: Iir_List; Is_Target: Boolean := False) is
+   begin
+      if Expr /= Null_Iir then
+         Canon_Extract_Sensitivity (Expr, Sensitivity_List, Is_Target);
+      end if;
+   end Canon_Extract_Sensitivity_If_Not_Null;
+
+   procedure Canon_Extract_Sequential_Statement_Chain_Sensitivity
+     (Chain : Iir; List : Iir_List)
+   is
+      Stmt : Iir;
+   begin
+      Stmt := Chain;
+      while Stmt /= Null_Iir loop
+         case Get_Kind (Stmt) is
+            when Iir_Kind_Assertion_Statement =>
+               --  LRM08 11.3
+               --  * For each assertion, report, next, exit or return
+               --    statement, apply the rule of 10.2 to each expression
+               --    in the statement, and construct the union of the
+               --    resulting sets.
+               Canon_Extract_Sensitivity
+                 (Get_Assertion_Condition (Stmt), List);
+               Canon_Extract_Sensitivity
+                 (Get_Severity_Expression (Stmt), List);
+               Canon_Extract_Sensitivity
+                 (Get_Report_Expression (Stmt), List);
+            when Iir_Kind_Report_Statement =>
+               --  LRM08 11.3
+               --  See assertion_statement case.
+               Canon_Extract_Sensitivity
+                 (Get_Severity_Expression (Stmt), List);
+               Canon_Extract_Sensitivity
+                 (Get_Report_Expression (Stmt), List);
+            when Iir_Kind_Next_Statement
+              | Iir_Kind_Exit_Statement =>
+               --  LRM08 11.3
+               --  See assertion_statement case.
+               Canon_Extract_Sensitivity
+                 (Get_Condition (Stmt), List);
+            when Iir_Kind_Return_Statement =>
+               --  LRM08 11.3
+               --  See assertion_statement case.
+               Canon_Extract_Sensitivity_If_Not_Null
+                 (Get_Expression (Stmt), List);
+            when Iir_Kind_Variable_Assignment_Statement =>
+               --  LRM08 11.3
+               --  * For each assignment statement, apply the rule of 10.2 to
+               --    each expression occuring in the assignment, including any
+               --    expressions occuring in the index names or slice names in
+               --    the target, and construct the union of the resulting sets.
+               Canon_Extract_Sensitivity (Get_Target (Stmt), List, True);
+               Canon_Extract_Sensitivity (Get_Expression (Stmt), List, False);
+            when Iir_Kind_Signal_Assignment_Statement =>
+               --  LRM08 11.3
+               --  See variable assignment statement case.
+               Canon_Extract_Sensitivity (Get_Target (Stmt), List, True);
+               Canon_Extract_Sensitivity_If_Not_Null
+                 (Get_Reject_Time_Expression (Stmt), List);
+               declare
+                  We: Iir_Waveform_Element;
+               begin
+                  We := Get_Waveform_Chain (Stmt);
+                  while We /= Null_Iir loop
+                     Canon_Extract_Sensitivity (Get_We_Value (We), List);
+                     We := Get_Chain (We);
+                  end loop;
+               end;
+            when Iir_Kind_If_Statement =>
+               --  LRM08 11.3
+               --  * For each if statement, apply the rule of 10.2 to the
+               --    condition and apply this rule recursively to each
+               --    sequence of statements within the if statement, and
+               --    construct the union of the resuling sets.
+               declare
+                  El1 : Iir := Stmt;
+                  Cond : Iir;
+               begin
+                  loop
+                     Cond := Get_Condition (El1);
+                     if Cond /= Null_Iir then
+                        Canon_Extract_Sensitivity (Cond, List);
+                     end if;
+                     Canon_Extract_Sequential_Statement_Chain_Sensitivity
+                       (Get_Sequential_Statement_Chain (El1), List);
+                     El1 := Get_Else_Clause (El1);
+                     exit when El1 = Null_Iir;
+                  end loop;
+               end;
+            when Iir_Kind_Case_Statement =>
+               --  LRM08 11.3
+               --  * For each case statement, apply the rule of 10.2 to the
+               --    expression and apply this rule recursively to each
+               --    sequence of statements within the case statement, and
+               --    construct the union of the resulting sets.
+               Canon_Extract_Sensitivity (Get_Expression (Stmt), List);
+               declare
+                  Choice: Iir;
+               begin
+                  Choice := Get_Case_Statement_Alternative_Chain (Stmt);
+                  while Choice /= Null_Iir loop
+                     Canon_Extract_Sequential_Statement_Chain_Sensitivity
+                       (Get_Associated (Choice), List);
+                     Choice := Get_Chain (Choice);
+                  end loop;
+               end;
+            when Iir_Kind_While_Loop_Statement =>
+               --  LRM08 11.3
+               --  * For each loop statement, apply the rule of 10.2 to each
+               --    expression in the iteration scheme, if present, and apply
+               --    this rule recursively to the sequence of statements within
+               --    the loop statement, and construct the union of the
+               --    resulting sets.
+               Canon_Extract_Sensitivity_If_Not_Null
+                 (Get_Condition (Stmt), List);
+               Canon_Extract_Sequential_Statement_Chain_Sensitivity
+                 (Get_Sequential_Statement_Chain (Stmt), List);
+            when Iir_Kind_For_Loop_Statement =>
+               --  LRM08 11.3
+               --  See loop statement case.
+               declare
+                  It : constant Iir := Get_Iterator_Scheme (Stmt);
+                  It_Type : constant Iir := Get_Type (It);
+                  Rng : constant Iir := Get_Range_Constraint (It_Type);
+               begin
+                  if Get_Kind (Rng) = Iir_Kind_Range_Expression then
+                     Canon_Extract_Sensitivity (Rng, List);
+                  end if;
+               end;
+               Canon_Extract_Sequential_Statement_Chain_Sensitivity
+                 (Get_Sequential_Statement_Chain (Stmt), List);
+            when Iir_Kind_Null_Statement =>
+               --  LRM08 11.3
+               --  ?
+               null;
+            when Iir_Kind_Procedure_Call_Statement =>
+               --  LRM08 11.3
+               --  * For each procedure call statement, apply the rule of 10.2
+               --    to each actual designator (other than OPEN) associated
+               --    with each formal parameter of mode IN or INOUT, and
+               --    construct the union of the resulting sets.
+               declare
+                  Param : Iir;
+               begin
+                  Param := Get_Parameter_Association_Chain
+                    (Get_Procedure_Call (Stmt));
+                  while Param /= Null_Iir loop
+                     if (Get_Kind (Param)
+                           = Iir_Kind_Association_Element_By_Expression)
+                       and then (Get_Mode (Get_Base_Name (Get_Formal (Param)))
+                                   /= Iir_Out_Mode)
+                     then
+                        Canon_Extract_Sensitivity (Get_Actual (Param), List);
+                     end if;
+                     Param := Get_Chain (Param);
+                  end loop;
+               end;
+            when others =>
+               Error_Kind
+                 ("canon_extract_sequential_statement_chain_sensitivity",
+                  Stmt);
+         end case;
+         Stmt := Get_Chain (Stmt);
+      end loop;
+   end Canon_Extract_Sequential_Statement_Chain_Sensitivity;
+
+   procedure Canon_Extract_Sensitivity_From_Callees
+     (Callees_List : Iir_List; Sensitivity_List : Iir_List)
+   is
+      Callee : Iir;
+   begin
+      --  LRM08 11.3
+      --  Moreover, for each subprogram for which the process is a parent
+      --  (see 4.3), the sensitivity list includes members of the set
+      --  constructed by apply the preceding rule to the statements of the
+      --  subprogram, but excluding the members that denote formal signal
+      --  parameters or members of formal signal parameters of the subprogram
+      --  or any of its parents.
+      if Callees_List = Null_Iir_List then
+         return;
+      end if;
+      for I in Natural loop
+         Callee := Get_Nth_Element (Callees_List, I);
+         exit when Callee = Null_Iir;
+         if not Get_Seen_Flag (Callee) then
+            Set_Seen_Flag (Callee, True);
+            case Get_All_Sensitized_State (Callee) is
+               when Read_Signal =>
+                  Canon_Extract_Sequential_Statement_Chain_Sensitivity
+                    (Get_Sequential_Statement_Chain
+                       (Get_Subprogram_Body (Callee)),
+                     Sensitivity_List);
+                  Canon_Extract_Sensitivity_From_Callees
+                    (Get_Callees_List (Callee), Sensitivity_List);
+               when No_Signal =>
+                  null;
+               when Unknown | Invalid_Signal =>
+                  raise Internal_Error;
+            end case;
+         end if;
+      end loop;
+   end Canon_Extract_Sensitivity_From_Callees;
+
+   function Canon_Extract_Process_Sensitivity
+     (Proc : Iir_Sensitized_Process_Statement)
+     return Iir_List
+   is
+      Res : Iir_List;
+   begin
+      Res := Create_Iir_List;
+      Canon_Extract_Sequential_Statement_Chain_Sensitivity
+        (Get_Sequential_Statement_Chain (Proc), Res);
+      Canon_Extract_Sensitivity_From_Callees
+        (Get_Callees_List (Proc), Res);
+      Set_Seen_Flag (Proc, True);
+      Clear_Seen_Flag (Proc);
+      return Res;
+   end Canon_Extract_Process_Sensitivity;
+
 --   function Make_Aggregate (Array_Type : Iir_Array_Type_Definition; El : Iir)
 --      return Iir_Aggregate
 --    is
@@ -855,7 +1078,7 @@
    --  be PROC, or an 'if' statement if the assignment is guarded.
    -- See LRM93 9.5
    procedure Canon_Concurrent_Signal_Assignment
-     (Stmt: in out Iir;
+     (Stmt: Iir;
       Proc: out Iir_Sensitized_Process_Statement;
       Chain : out Iir)
    is
@@ -1709,7 +1932,7 @@
                end if;
             when Iir_Kind_Generate_Statement =>
                if False
-                 and then Flags.Vhdl_Std = Vhdl_87
+                 and then Vhdl_Std = Vhdl_87
                  and then
                  Get_Kind (Conf) = Iir_Kind_Configuration_Specification
                then
diff -urN ghdl-0.27/vhdl/canon.ads ghdl-0.28dev/vhdl/canon.ads
--- ghdl-0.27/vhdl/canon.ads	2005-09-22 23:08:22.000000000 +0200
+++ ghdl-0.28dev/vhdl/canon.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
@@ -58,4 +58,10 @@
    -- as indexes of an indexed name) are added.
    procedure Canon_Extract_Sensitivity
      (Expr: Iir; Sensitivity_List: Iir_List; Is_Target: Boolean := False);
+
+   --  Compute the sensitivity list of all-sensitized process PROC.
+   --  Used for vhdl 08.
+   function Canon_Extract_Process_Sensitivity
+     (Proc : Iir_Sensitized_Process_Statement)
+     return Iir_List;
 end Canon;
diff -urN ghdl-0.27/vhdl/configuration.adb ghdl-0.28dev/vhdl/configuration.adb
--- ghdl-0.27/vhdl/configuration.adb	2006-03-12 05:30:16.000000000 +0100
+++ ghdl-0.28dev/vhdl/configuration.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Libraries;
@@ -319,8 +319,9 @@
             --  A port of any mode other than IN may be unconnected or
             --  unassociated as long as its type is not an unconstrained array
             --  type.
-            if Get_Kind (Get_Type (Port))
-              in Iir_Kinds_Unconstrained_Array_Type_Definition
+            if Get_Kind (Get_Type (Port)) in Iir_Kinds_Array_Type_Definition
+              and then (Get_Constraint_State (Get_Type (Port))
+                          /= Fully_Constrained)
             then
                if Loc /= Null_Iir then
                   Error_Msg_Elab ("unconstrained " & Disp_Node (Port)
diff -urN ghdl-0.27/vhdl/configuration.ads ghdl-0.28dev/vhdl/configuration.ads
--- ghdl-0.27/vhdl/configuration.ads	2005-09-22 23:08:36.000000000 +0200
+++ ghdl-0.28dev/vhdl/configuration.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
diff -urN ghdl-0.27/vhdl/disp_tree.adb ghdl-0.28dev/vhdl/disp_tree.adb
--- ghdl-0.27/vhdl/disp_tree.adb	2006-08-15 21:47:31.000000000 +0200
+++ ghdl-0.28dev/vhdl/disp_tree.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Ada.Text_IO; use Ada.Text_IO;
@@ -25,7 +25,7 @@
 
 package body Disp_Tree is
    procedure Disp_Tab (Tab: Natural) is
-      Blanks : String (1 .. Tab) := (others => ' ');
+      Blanks : constant String (1 .. Tab) := (others => ' ');
    begin
       Put (Blanks);
    end Disp_Tab;
@@ -276,6 +276,9 @@
          when Iir_Kind_Element_Declaration =>
             Put ("element_declaration");
             Disp_Identifier (Tree);
+         when Iir_Kind_Record_Element_Constraint =>
+            Put ("record_element_constraint");
+            Disp_Identifier (Tree);
          when Iir_Kind_Attribute_Declaration =>
             Put ("attribute_declaration");
             Disp_Identifier (Tree);
@@ -549,7 +552,7 @@
    procedure Disp_Tree (Tree: Iir;
                         Tab: Natural := 0;
                         Flat_Decl: Boolean := false) is
-      Ntab: Natural := Inc_Tab (Tab);
+      Ntab: constant Natural := Inc_Tab (Tab);
       Kind : Iir_Kind;
 
       procedure Header (Str: String; Nl: Boolean := true) is
@@ -994,6 +997,11 @@
          when Iir_Kind_Element_Declaration =>
             Header ("type:");
             Disp_Tree (Get_Type (Tree), Ntab, True);
+         when Iir_Kind_Record_Element_Constraint =>
+            Header ("type:");
+            Disp_Tree (Get_Type (Tree), Ntab, True);
+            Header ("element_declaration:");
+            Disp_Tree (Get_Element_Declaration (Tree), Ntab);
          when Iir_Kind_Attribute_Declaration =>
             if Flat_Decl then
                return;
@@ -1018,7 +1026,8 @@
             end if;
             Header ("wait_state:", False);
             Disp_State (Get_Wait_State (Tree));
-
+            Header ("all_sensitized_state: " & Iir_All_Sensitized'Image
+                      (Get_All_Sensitized_State (Tree)));
             Header ("subprogram_depth:", False);
             Disp_Depth (Get_Subprogram_Depth (Tree));
             Header ("subprogram_body:");
@@ -1158,11 +1167,11 @@
             Disp_Tree_Flat (Get_Type_Declarator (Tree), Ntab);
             Header ("base type:");
             declare
-               Base : Iir := Get_Base_Type (Tree);
+               Base : constant Iir := Get_Base_Type (Tree);
                Fl : Boolean;
             begin
                if Base /= Null_Iir
-                 and then Kind = Iir_Kind_Array_Type_Definition
+                 and then Get_Kind (Base) = Iir_Kind_Array_Type_Definition
                then
                   Fl := Get_Type_Declarator (Base)
                     /= Get_Type_Declarator (Tree);
@@ -1176,29 +1185,13 @@
             Header ("index_subtype_list:");
             Disp_Tree_List (Get_Index_Subtype_List (Tree), Ntab, True);
             Header ("element_subtype:");
-            Disp_Tree_Flat (Get_Element_Subtype (Tree), Ntab);
-            Header ("resolution function:");
-            Disp_Tree_Flat (Get_Resolution_Function (Tree), Ntab);
-         when Iir_Kind_Unconstrained_Array_Subtype_Definition =>
-            if Flat_Decl and then Get_Type_Declarator (Tree) /= Null_Iir then
-               return;
-            end if;
-            Header ("type declarator:");
-            Disp_Tree_Flat (Get_Type_Declarator (Tree), Ntab);
-            Header ("resolved flag: ", False);
-            Disp_Type_Resolved_Flag (Tree);
-            Header ("signal_type_flag: ", False);
-            Disp_Flag (Get_Signal_Type_Flag (Tree));
-            Header ("has_signal_flag: ", False);
-            Disp_Flag (Get_Has_Signal_Flag (Tree));
-            Header ("base type:");
-            Disp_Tree (Get_Base_Type (Tree), Ntab, True);
-            Header ("type mark:");
-            Disp_Tree (Get_Type_Mark (Tree), Ntab, True);
+            Disp_Tree (Get_Element_Subtype (Tree), Ntab, True);
             Header ("resolution function:");
             Disp_Tree_Flat (Get_Resolution_Function (Tree), Ntab);
-            Header ("index_subtype_list:");
-            Disp_Tree_List (Get_Index_Subtype_List (Tree), Ntab, True);
+            Header ("index_constraint: ", False);
+            Disp_Flag (Get_Index_Constraint_Flag (Tree));
+            Header ("constraint_state: "
+                      & Iir_Constraint'Image (Get_Constraint_State (Tree)));
          when Iir_Kind_Array_Type_Definition  =>
             if Flat_Decl and then Get_Type_Declarator (Tree) /= Null_Iir then
                return;
@@ -1227,8 +1220,10 @@
             Disp_Flag (Get_Signal_Type_Flag (Tree));
             Header ("has_signal_flag: ", False);
             Disp_Flag (Get_Has_Signal_Flag (Tree));
+            Header ("constraint_state: "
+                      & Iir_Constraint'Image (Get_Constraint_State (Tree)));
             Header ("elements:");
-            Disp_Tree_Chain (Get_Element_Declaration_Chain (Tree), Ntab, True);
+            Disp_Tree_List (Get_Elements_Declaration_List (Tree), Ntab, True);
          when Iir_Kind_Record_Subtype_Definition =>
             if Flat_Decl and then not Is_Anonymous_Type_Definition (Tree) then
                return;
@@ -1245,6 +1240,10 @@
             Disp_Tree (Get_Type_Mark (Tree), Ntab, True);
             Header ("resolution function:");
             Disp_Tree_Flat (Get_Resolution_Function (Tree), Ntab);
+            Header ("constraint_state: "
+                      & Iir_Constraint'Image (Get_Constraint_State (Tree)));
+            Header ("elements:");
+            Disp_Tree_List (Get_Elements_Declaration_List (Tree), Ntab, True);
          when Iir_Kind_Physical_Type_Definition =>
             if Flat_Decl and then Get_Type_Declarator (Tree) /= Null_Iir then
                return;
@@ -1742,6 +1741,10 @@
             Disp_Tree_Flat (Get_Prefix (Tree), Ntab);
             Header ("type:");
             Disp_Tree_Flat (Get_Type (Tree), Ntab);
+            if Kind /= Iir_Kind_Transaction_Attribute then
+               Header ("parameter:");
+               Disp_Tree (Get_Parameter (Tree), Ntab);
+            end if;
             Header ("has_active_flag: ", False);
             Disp_Flag (Get_Has_Active_Flag (Tree));
          when Iir_Kind_Event_Attribute
diff -urN ghdl-0.27/vhdl/disp_tree.ads ghdl-0.28dev/vhdl/disp_tree.ads
--- ghdl-0.27/vhdl/disp_tree.ads	2005-09-22 23:09:11.000000000 +0200
+++ ghdl-0.28dev/vhdl/disp_tree.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
diff -urN ghdl-0.27/vhdl/disp_vhdl.adb ghdl-0.28dev/vhdl/disp_vhdl.adb
--- ghdl-0.27/vhdl/disp_vhdl.adb	2007-03-21 04:42:39.000000000 +0100
+++ ghdl-0.28dev/vhdl/disp_vhdl.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 
@@ -21,7 +21,6 @@
 -- Try to be as pretty as possible, and to keep line numbers and positions
 -- of the identifiers.
 with Ada.Text_IO; use Ada.Text_IO;
-with Types; use Types;
 with Std_Package;
 with Flags; use Flags;
 with Errorout; use Errorout;
@@ -136,6 +135,7 @@
            | Iir_Kind_File_Declaration
            | Iir_Kind_Subtype_Declaration
            | Iir_Kind_Element_Declaration
+           | Iir_Kind_Record_Element_Constraint
            | Iir_Kind_Package_Declaration
            | Iir_Kind_Object_Alias_Declaration
            | Iir_Kind_Non_Object_Alias_Declaration
@@ -222,12 +222,30 @@
    end Disp_Use_Clause;
 
    -- Disp the resolution function (if any) of type definition DEF.
-   procedure Disp_Resolution_Function (Def: Iir) is
-      Decl: Iir;
+   procedure Disp_Resolution_Function (Subtype_Def: Iir)
+   is
+      procedure Inner (Def : Iir)
+      is
+         Decl: Iir;
+      begin
+         Decl := Get_Resolution_Function (Def);
+         if Decl /= Null_Iir then
+            Disp_Name (Decl);
+         else
+            case Get_Kind (Def) is
+               when Iir_Kind_Array_Subtype_Definition =>
+                  Put ('(');
+                  Inner (Get_Element_Subtype (Def));
+                  Put (')');
+               when others =>
+                  Error_Kind ("disp_resolution_function", Def);
+            end case;
+         end if;
+      end Inner;
+
    begin
-      Decl := Get_Resolution_Function (Def);
-      if Decl /= Null_Iir then
-         Disp_Name (Decl);
+      if Get_Resolved_Flag (Subtype_Def) then
+         Inner (Subtype_Def);
          Put (' ');
       end if;
    end Disp_Resolution_Function;
@@ -276,12 +294,93 @@
       Put (";");
    end Disp_Floating_Subtype_Definition;
 
-   procedure Disp_Subtype_Indication (Def: Iir; Full_Decl: Boolean := False)
+   procedure Disp_Element_Constraint (Def : Iir; Type_Mark : Iir);
+
+   procedure Disp_Array_Element_Constraint (Def : Iir; Type_Mark : Iir)
+   is
+      Index : Iir;
+      Def_El : Iir;
+      Tm_El : Iir;
+      Has_Index : Boolean;
+      Has_Own_Element_Subtype : Boolean;
+   begin
+      Has_Index := Get_Index_Constraint_Flag (Def);
+      Def_El := Get_Element_Subtype (Def);
+      Tm_El := Get_Element_Subtype (Type_Mark);
+      Has_Own_Element_Subtype := Def_El /= Tm_El;
+
+      if not Has_Index and not Has_Own_Element_Subtype then
+         return;
+      end if;
+
+      Put (" (");
+      if Has_Index then
+         for I in Natural loop
+            Index := Get_Nth_Element (Get_Index_Subtype_List (Def), I);
+            exit when Index = Null_Iir;
+            if I /= 0 then
+               Put (", ");
+            end if;
+            --Disp_Expression (Get_Range_Constraint (Index));
+            Disp_Range (Index);
+         end loop;
+      else
+         Put ("open");
+      end if;
+      Put (")");
+
+      if Has_Own_Element_Subtype
+        and then Get_Kind (Def_El) in Iir_Kinds_Composite_Type_Definition
+      then
+         Disp_Element_Constraint (Def_El, Tm_El);
+      end if;
+   end Disp_Array_Element_Constraint;
+
+   procedure Disp_Record_Element_Constraint (Def : Iir)
+   is
+      El_List : constant Iir_List := Get_Elements_Declaration_List (Def);
+      El : Iir;
+      Has_El : Boolean := False;
+   begin
+      for I in Natural loop
+         El := Get_Nth_Element (El_List, I);
+         exit when El = Null_Iir;
+         if Get_Kind (El) = Iir_Kind_Record_Element_Constraint
+           and then Get_Parent (El) = Def
+         then
+            if Has_El then
+               Put (", ");
+            else
+               Put ("(");
+               Has_El := True;
+            end if;
+            Disp_Name_Of (El);
+            Disp_Element_Constraint (Get_Type (El),
+                                     Get_Base_Type (Get_Type (El)));
+         end if;
+      end loop;
+      if Has_El then
+         Put (")");
+      end if;
+   end Disp_Record_Element_Constraint;
+
+   procedure Disp_Element_Constraint (Def : Iir; Type_Mark : Iir) is
+   begin
+      case Get_Kind (Def) is
+         when Iir_Kind_Record_Subtype_Definition =>
+            Disp_Record_Element_Constraint (Def);
+         when Iir_Kind_Array_Subtype_Definition =>
+            Disp_Array_Element_Constraint (Def, Type_Mark);
+         when others =>
+            Error_Kind ("disp_element_constraint", Def);
+      end case;
+   end Disp_Element_Constraint;
+
+   procedure Disp_Subtype_Indication (Def : Iir; Full_Decl : Boolean := False)
    is
-      Type_Mark: Iir;
+      Type_Mark : Iir;
       Base_Type : Iir;
-      Index: Iir;
-      Decl: Iir;
+      Decl : Iir;
    begin
       Decl := Get_Type_Declarator (Def);
       if not Full_Decl and then Decl /= Null_Iir then
@@ -299,10 +398,6 @@
          Disp_Name_Of (Decl);
       end if;
 
-      if Get_Kind (Def) = Iir_Kind_Unconstrained_Array_Subtype_Definition then
-         return;
-      end if;
-
       Base_Type := Get_Base_Type (Def);
       case Get_Kind (Base_Type) is
          when Iir_Kind_Integer_Type_Definition
@@ -319,19 +414,9 @@
                Disp_Expression (Get_Range_Constraint (Def));
             end if;
          when Iir_Kind_Array_Type_Definition =>
-            Put (" (");
-            for I in Natural loop
-               Index := Get_Nth_Element (Get_Index_Subtype_List (Def), I);
-               exit when Index = Null_Iir;
-               if I /= 0 then
-                  Put (", ");
-               end if;
-               Disp_Expression (Get_Range_Constraint (Index));
-               --Disp_Range (Get_Range_Constraint (Index);
-            end loop;
-            Put (")");
+            Disp_Array_Element_Constraint (Def, Type_Mark);
          when Iir_Kind_Record_Type_Definition =>
-            null;
+            Disp_Record_Element_Constraint (Def);
          when others =>
             Error_Kind ("disp_subtype_indication", Base_Type);
       end case;
@@ -372,9 +457,7 @@
    procedure Disp_Enumeration_Subtype_Definition
      (Def: Iir_Enumeration_Subtype_Definition)
    is
-      Base_Type: Iir;
    begin
-      Base_Type := Get_Base_Type (Def);
       Disp_Resolution_Function (Def);
       Put ("range ");
       Disp_Range (Def);
@@ -385,11 +468,9 @@
      (Def: Iir_Array_Subtype_Definition)
    is
       Index: Iir;
-      A_Type: Iir_Array_Type_Definition;
    begin
       Disp_Resolution_Function (Def);
 
-      A_Type := Get_Base_Type (Def);
       Put ("array (");
       for I in Natural loop
          Index := Get_Nth_Element (Get_Index_Subtype_List (Def), I);
@@ -468,19 +549,21 @@
    procedure Disp_Record_Type_Definition
      (Def: Iir_Record_Type_Definition; Indent: Count)
    is
+      List : Iir_List;
       El: Iir_Element_Declaration;
    begin
       Put_Line ("record");
       Set_Col (Indent);
       Put_Line ("begin");
-      El := Get_Element_Declaration_Chain (Def);
-      while El /= Null_Iir loop
+      List := Get_Elements_Declaration_List (Def);
+      for I in Natural loop
+         El := Get_Nth_Element (List, I);
+         exit when El = Null_Iir;
          Set_Col (Indent + Indentation);
          Disp_Identifier (El);
          Put (" : ");
          Disp_Subtype_Indication (Get_Type (El));
          Put_Line (";");
-         El := Get_Chain (El);
       end loop;
       Set_Col (Indent);
       Put ("end record;");
@@ -893,11 +976,8 @@
       Put_Line (";");
    end Disp_Object_Declaration;
 
-   procedure Disp_Subprogram_Declaration (Subprg: Iir)
-   is
-      Indent: Count;
+   procedure Disp_Subprogram_Declaration (Subprg: Iir) is
    begin
-      Indent := Col;
       case Get_Kind (Subprg) is
          when Iir_Kind_Function_Declaration
            | Iir_Kind_Implicit_Function_Declaration =>
@@ -1507,7 +1587,6 @@
    is
       El: Iir;
       Formal: Iir;
-      Indent: Count;
       Need_Comma : Boolean;
       Conv : Iir;
    begin
@@ -1515,7 +1594,6 @@
          return;
       end if;
       Put ("(");
-      Indent := Col;
       Need_Comma := False;
 
       El := Chain;
@@ -2315,7 +2393,7 @@
 
    procedure Disp_Int64 (Val: Iir_Int64)
    is
-      Str: String := Iir_Int64'Image (Val);
+      Str: constant String := Iir_Int64'Image (Val);
    begin
       if Str(Str'First) = ' ' then
          Put (Str (Str'First + 1 .. Str'Last));
@@ -2326,7 +2404,7 @@
 
    procedure Disp_Int32 (Val: Iir_Int32)
    is
-      Str: String := Iir_Int32'Image (Val);
+      Str: constant String := Iir_Int32'Image (Val);
    begin
       if Str(Str'First) = ' ' then
          Put (Str (Str'First + 1 .. Str'Last));
@@ -2337,7 +2415,7 @@
 
    procedure Disp_Fp64 (Val: Iir_Fp64)
    is
-      Str: String := Iir_Fp64'Image (Val);
+      Str: constant String := Iir_Fp64'Image (Val);
    begin
       if Str(Str'First) = ' ' then
          Put (Str (Str'First + 1 .. Str'Last));
diff -urN ghdl-0.27/vhdl/disp_vhdl.ads ghdl-0.28dev/vhdl/disp_vhdl.ads
--- ghdl-0.27/vhdl/disp_vhdl.ads	2005-09-22 23:09:34.000000000 +0200
+++ ghdl-0.28dev/vhdl/disp_vhdl.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
diff -urN ghdl-0.27/vhdl/errorout.adb ghdl-0.28dev/vhdl/errorout.adb
--- ghdl-0.27/vhdl/errorout.adb	2006-06-05 08:55:40.000000000 +0200
+++ ghdl-0.28dev/vhdl/errorout.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,13 +12,11 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Ada.Text_IO;
 with Ada.Command_Line;
-with Types; use Types;
-with Iirs; use Iirs;
 with Scan;
 with Tokens; use Tokens;
 with Name_Table;
@@ -50,8 +48,9 @@
       Put_Line (Standard_Error, Str);
    end Put_Line;
 
-   procedure Disp_Natural (Val: Natural) is
-      Str: String := Natural'Image (Val);
+   procedure Disp_Natural (Val: Natural)
+   is
+      Str: constant String := Natural'Image (Val);
    begin
       Put (Str(Str'First + 1 .. Str'Last));
    end Disp_Natural;
@@ -404,6 +403,8 @@
             return "enumeration literal " & Iirs_Utils.Image_Identifier (Node);
          when Iir_Kind_Element_Declaration =>
             return Disp_Identifier (Node, "element");
+         when Iir_Kind_Record_Element_Constraint =>
+            return "record element constraint";
          when Iir_Kind_Null_Literal =>
             return "null literal";
          when Iir_Kind_Aggregate =>
@@ -437,8 +438,7 @@
 
          when Iir_Kind_Array_Type_Definition =>
             return Disp_Type (Node, "array type");
-         when Iir_Kind_Array_Subtype_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition =>
+         when Iir_Kind_Array_Subtype_Definition =>
             return Disp_Type (Node, "array subtype");
          when Iir_Kind_Record_Type_Definition =>
             return Disp_Type (Node, "record type");
@@ -810,8 +810,8 @@
      (Name : Name_Id; Line, Col : Natural; Filename : Boolean)
      return String
    is
-      Line_Str : String := Natural'Image (Line);
-      Col_Str : String := Natural'Image (Col);
+      Line_Str : constant String := Natural'Image (Line);
+      Col_Str : constant String := Natural'Image (Col);
    begin
       if Filename then
          return Name_Table.Image (Name)
@@ -861,7 +861,7 @@
 
    function Image (N : Iir_Int64) return String
    is
-      Res : String := Iir_Int64'Image (N);
+      Res : constant String := Iir_Int64'Image (N);
    begin
       if Res (1) = ' ' then
          return Res (2 .. Res'Last);
@@ -917,7 +917,7 @@
       declare
          use Name_Table;
 
-         Id : Name_Id := Get_Identifier (Subprg);
+         Id : constant Name_Id := Get_Identifier (Subprg);
       begin
          Image (Id);
          case Id is
diff -urN ghdl-0.27/vhdl/errorout.ads ghdl-0.28dev/vhdl/errorout.ads
--- ghdl-0.27/vhdl/errorout.ads	2005-09-22 23:09:47.000000000 +0200
+++ ghdl-0.28dev/vhdl/errorout.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
diff -urN ghdl-0.27/vhdl/evaluation.adb ghdl-0.28dev/vhdl/evaluation.adb
--- ghdl-0.27/vhdl/evaluation.adb	2008-04-07 05:21:05.000000000 +0200
+++ ghdl-0.28dev/vhdl/evaluation.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,16 +12,15 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
-with Types; use Types;
 with Errorout; use Errorout;
 with Name_Table; use Name_Table;
 with Str_Table;
 with Iirs_Utils; use Iirs_Utils;
 with Std_Package; use Std_Package;
-with Flags;
+with Flags; use Flags;
 with Std_Names;
 
 package body Evaluation is
@@ -336,6 +335,8 @@
       Append_Element (Get_Index_Subtype_List (Res), Index_Type);
       Set_Type_Staticness (Res, Min (Get_Type_Staticness (Res),
                                      Get_Type_Staticness (Index_Type)));
+      Set_Constraint_State (Res, Fully_Constrained);
+      Set_Index_Constraint_Flag (Res, True);
       return Res;
    end Create_Unidim_Array_From_Index;
 
@@ -354,7 +355,6 @@
 
    function Eval_String_Literal (Str : Iir) return Iir
    is
-      use Name_Table;
       Ptr : String_Fat_Acc;
       Len : Natural;
    begin
@@ -495,8 +495,8 @@
      return Iir
    is
       use Str_Table;
-      L_Str : String_Fat_Acc := Get_String_Fat_Acc (Left);
-      R_Str : String_Fat_Acc := Get_String_Fat_Acc (Right);
+      L_Str : constant String_Fat_Acc := Get_String_Fat_Acc (Left);
+      R_Str : constant String_Fat_Acc := Get_String_Fat_Acc (Right);
       Len : Natural;
       Id : String_Id;
    begin
@@ -1146,6 +1146,7 @@
            | Iir_Predefined_Write
            | Iir_Predefined_Read
            | Iir_Predefined_Read_Length
+           | Iir_Predefined_Flush
            | Iir_Predefined_File_Open
            | Iir_Predefined_File_Open_Status
            | Iir_Predefined_File_Close
@@ -1166,7 +1167,8 @@
            | Iir_Predefined_Attribute_Last_Event
            | Iir_Predefined_Attribute_Last_Active
            | Iir_Predefined_Attribute_Driving
-           | Iir_Predefined_Attribute_Driving_Value =>
+           | Iir_Predefined_Attribute_Driving_Value
+           | Iir_Predefined_Array_To_String =>
             --  Not binary or never locally static.
             Error_Internal (Orig, "eval_dyadic_operator: " &
                             Iir_Predefined_Functions'Image (Func));
@@ -1415,8 +1417,7 @@
                Error_Msg_Sem ("non matching length in type convertion", Conv);
             end if;
             return Res;
-         when Iir_Kind_Array_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition =>
+         when Iir_Kind_Array_Type_Definition =>
             if Get_Base_Type (Conv_Index_Type) = Get_Base_Type (Val_Index_Type)
             then
                Index_Type := Val_Index_Type;
@@ -1512,7 +1513,14 @@
          when Iir_Kind_Constant_Declaration =>
             Val := Get_Default_Value (Expr);
             Res := Build_Constant (Val, Expr);
-            Set_Type (Res, Get_Type (Val));
+            --  Type of the expression should be type of the constant
+            --  declaration at least in case of array subtype.
+            --  If the constant is declared as an unconstrained array, get type
+            --  from the default value.
+            --  FIXME: handle this during semantisation of the declaration.
+            if Get_Kind (Get_Type (Res)) = Iir_Kind_Array_Type_Definition then
+               Set_Type (Res, Get_Type (Val));
+            end if;
             return Res;
          when Iir_Kind_Object_Alias_Declaration =>
             return Build_Constant (Eval_Static_Expr (Get_Name (Expr)), Expr);
@@ -1816,6 +1824,15 @@
       end if;
    end Eval_Expr_If_Static;
 
+   function Eval_Expr_Check_If_Static (Expr : Iir; Atype : Iir) return Iir is
+   begin
+      if Expr /= Null_Iir and then Get_Expr_Staticness (Expr) = Locally then
+         return Eval_Expr_Check (Expr, Atype);
+      else
+         return Expr;
+      end if;
+   end Eval_Expr_Check_If_Static;
+
    function Eval_Int_In_Range (Val : Iir_Int64; Bound : Iir) return Boolean is
    begin
       case Get_Kind (Bound) is
diff -urN ghdl-0.27/vhdl/evaluation.ads ghdl-0.28dev/vhdl/evaluation.ads
--- ghdl-0.27/vhdl/evaluation.ads	2007-03-24 08:30:19.000000000 +0100
+++ ghdl-0.28dev/vhdl/evaluation.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
@@ -59,6 +59,9 @@
    --  computation.
    function Eval_Expr_Check (Expr : Iir; Sub_Type : Iir) return Iir;
 
+   --  Call Eval_Expr_Check only if EXPR is static.
+   function Eval_Expr_Check_If_Static (Expr : Iir; Atype : Iir) return Iir;
+
    --  Return TRUE iff VAL belongs to BOUND.
    function Eval_Int_In_Range (Val : Iir_Int64; Bound : Iir) return Boolean;
 
diff -urN ghdl-0.27/vhdl/files_map.adb ghdl-0.28dev/vhdl/files_map.adb
--- ghdl-0.27/vhdl/files_map.adb	2005-09-22 23:27:42.000000000 +0200
+++ ghdl-0.28dev/vhdl/files_map.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Interfaces.C;
@@ -22,7 +22,6 @@
 with GNAT.Table;
 with GNAT.OS_Lib;
 with GNAT.Directory_Operations;
-with System;
 with Name_Table; use Name_Table;
 with Str_Table;
 with Ada.Calendar;
@@ -859,8 +858,8 @@
    function Is_Eq (L : Time_Stamp_Id; R : Time_Stamp_Id) return Boolean
    is
       use Str_Table;
-      L_Str : String_Fat_Acc := Get_String_Fat_Acc (String_Id (L));
-      R_Str : String_Fat_Acc := Get_String_Fat_Acc (String_Id (R));
+      L_Str : constant String_Fat_Acc := Get_String_Fat_Acc (String_Id (L));
+      R_Str : constant String_Fat_Acc := Get_String_Fat_Acc (String_Id (R));
    begin
       return L_Str (1 .. Time_Stamp_String'Length)
         = R_Str (1 .. Time_Stamp_String'Length);
@@ -869,8 +868,8 @@
    function Is_Gt (L : Time_Stamp_Id; R : Time_Stamp_Id) return Boolean
    is
       use Str_Table;
-      L_Str : String_Fat_Acc := Get_String_Fat_Acc (String_Id (L));
-      R_Str : String_Fat_Acc := Get_String_Fat_Acc (String_Id (R));
+      L_Str : constant String_Fat_Acc := Get_String_Fat_Acc (String_Id (L));
+      R_Str : constant String_Fat_Acc := Get_String_Fat_Acc (String_Id (R));
    begin
       return L_Str (1 .. Time_Stamp_String'Length)
         > R_Str (1 .. Time_Stamp_String'Length);
diff -urN ghdl-0.27/vhdl/files_map.ads ghdl-0.28dev/vhdl/files_map.ads
--- ghdl-0.27/vhdl/files_map.ads	2005-09-22 23:10:15.000000000 +0200
+++ ghdl-0.28dev/vhdl/files_map.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
diff -urN ghdl-0.27/vhdl/flags.adb ghdl-0.28dev/vhdl/flags.adb
--- ghdl-0.27/vhdl/flags.adb	2006-08-18 08:49:46.000000000 +0200
+++ ghdl-0.28dev/vhdl/flags.adb	2009-09-20 09:06:46.000000000 +0200
@@ -1,5 +1,5 @@
---  Command line flags.
---  Copyright (C) 2002, 2003, 2004, 2005 Tristan Gingold
+--  Global flags.
+--  Copyright (C) 2002, 2003, 2004, 2005, 2008 Tristan Gingold
 --
 --  GHDL is free software; you can redistribute it and/or modify it under
 --  the terms of the GNU General Public License as published by the Free
@@ -12,209 +12,11 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
-with Ada.Text_IO; use Ada.Text_IO;
-with Name_Table;
-with Libraries;
-with Scan;
-with Back_End; use Back_End;
 
 package body Flags is
-   function Option_Warning (Opt: String; Val : Boolean) return Boolean is
-   begin
---      if Opt = "undriven" then
---         Warn_Undriven := True;
-      if Opt = "library" then
-         Warn_Library := Val;
-      elsif Opt = "default-binding" then
-         Warn_Default_Binding := Val;
-      elsif Opt = "binding" then
-         Warn_Binding := Val;
-      elsif Opt = "reserved" then
-         Warn_Reserved_Word := Val;
-      elsif Opt = "vital-generic" then
-         Warn_Vital_Generic := Val;
-      elsif Opt = "delayed-checks" then
-         Warn_Delayed_Checks := Val;
-      elsif Opt = "body" then
-         Warn_Body := Val;
-      elsif Opt = "specs" then
-         Warn_Specs := Val;
-      elsif Opt = "unused" then
-         Warn_Unused := Val;
-      elsif Opt = "error" then
-         Warn_Error := Val;
-      else
-         return False;
-      end if;
-      return True;
-   end Option_Warning;
-
-   function Parse_Option (Opt: String) return Boolean is
-      Beg: Integer := Opt'First;
-   begin
-      if Opt'Length > 5 and then Opt (Beg .. Beg + 5) = "--std=" then
-         if Opt'Length = 8 then
-            if Opt (Beg + 6 .. Beg + 7) = "87" then
-               Vhdl_Std := Vhdl_87;
-            elsif Opt (Beg + 6 .. Beg + 7) = "93" then
-               Vhdl_Std := Vhdl_93;
-            elsif Opt (Beg + 6 .. Beg + 7) = "00" then
-               Vhdl_Std := Vhdl_00;
-            elsif Opt (Beg + 6 .. Beg + 7) = "02" then
-               Vhdl_Std := Vhdl_02;
-            else
-               return False;
-            end if;
-         elsif Opt'Length = 9 and then Opt (Beg + 6 .. Beg + 8) = "93c" then
-            Vhdl_Std := Vhdl_93c;
-         else
-            return False;
-         end if;
-      elsif Opt'Length > 2 and then Opt (Beg .. Beg + 1) = "-P" then
-         Libraries.Add_Library_Path (Opt (Beg + 2 .. Opt'Last));
-      elsif Opt'Length > 10 and then Opt (Beg .. Beg + 9) = "--workdir=" then
-         Libraries.Set_Work_Library_Path (Opt (Beg + 10 .. Opt'Last));
-      elsif Opt'Length > 10 and then Opt (Beg .. Beg + 9) = "--warn-no-" then
-         return Option_Warning (Opt (Beg + 10 .. Opt'Last), False);
-      elsif Opt'Length > 7 and then Opt (Beg .. Beg + 6) = "--warn-" then
-         return Option_Warning (Opt (Beg + 7 .. Opt'Last), True);
-      elsif Opt'Length > 7 and then Opt (Beg .. Beg + 6) = "--work=" then
-         declare
-            use Name_Table;
-         begin
-            Name_Length := Opt'Last - (Beg + 7) + 1;
-            Name_Buffer (1 .. Name_Length) := Opt (Beg + 7 .. Opt'Last);
-            Scan.Convert_Identifier;
-            Libraries.Work_Library_Name := Get_Identifier;
-         end;
-      elsif Opt = "-C" or else Opt = "--mb-comments" then
-         Mb_Comment := True;
-      elsif Opt = "--bootstrap" then
-         Bootstrap := True;
-      elsif Opt = "-fexplicit" then
-         Flag_Explicit := True;
-      elsif Opt = "--syn-binding" then
-         Flag_Syn_Binding := True;
-      elsif Opt = "--no-vital-checks" then
-         Flag_Vital_Checks := False;
-      elsif Opt = "--vital-checks" then
-         Flag_Vital_Checks := True;
-      elsif Opt = "-dp" then
-         Dump_Parse := True;
-      elsif Opt = "-ds" then
-         Dump_Sem := True;
-      elsif Opt = "-dc" then
-         Dump_Canon := True;
-      elsif Opt = "-da" then
-         Dump_Annotate := True;
-      elsif Opt = "--dall" then
-         Dump_All := True;
-      elsif Opt = "-dstats" then
-         Dump_Stats := True;
-      elsif Opt = "--lall" then
-         List_All := True;
-      elsif Opt = "-lv" then
-         List_Verbose := True;
-      elsif Opt = "-ls" then
-         List_Sem := True;
-      elsif Opt = "-lc" then
-         List_Canon := True;
-      elsif Opt = "-la" then
-         List_Annotate := True;
-      elsif Opt = "-v" then
-         Verbose := True;
-      elsif Opt = "--finteger64" then
-         Flag_Integer_64 := True;
-      elsif Opt = "--ftime32" then
-         Flag_Time_64 := False;
---       elsif Opt'Length > 17
---         and then Opt (Beg .. Beg + 17) = "--time-resolution="
---       then
---          Beg := Beg + 18;
---          if Opt (Beg .. Beg + 1) = "fs" then
---             Time_Resolution := 'f';
---          elsif Opt (Beg .. Beg + 1) = "ps" then
---             Time_Resolution := 'p';
---          elsif Opt (Beg .. Beg + 1) = "ns" then
---             Time_Resolution := 'n';
---          elsif Opt (Beg .. Beg + 1) = "us" then
---             Time_Resolution := 'u';
---          elsif Opt (Beg .. Beg + 1) = "ms" then
---             Time_Resolution := 'm';
---          elsif Opt (Beg .. Beg + 2) = "sec" then
---             Time_Resolution := 's';
---          elsif Opt (Beg .. Beg + 2) = "min" then
---             Time_Resolution := 'M';
---          elsif Opt (Beg .. Beg + 1) = "hr" then
---             Time_Resolution := 'h';
---          else
---             return False;
---          end if;
-      elsif Back_End.Parse_Option /= null
-        and then Back_End.Parse_Option.all (Opt)
-      then
-         null;
-      else
-         return False;
-      end if;
-      return True;
-   end Parse_Option;
-
-   -- Disp help about these options.
-   procedure Disp_Options_Help
-   is
-      procedure P (S : String) renames Put_Line;
-   begin
-      P ("Main options:");
-      P ("  --work=LIB         use LIB as work library");
-      P ("  --workdir=DIR      use DIR for the file library");
-      P ("  -PPATH             add PATH in the library path list");
-      P ("  --std=87           select vhdl 87 standard");
-      P ("  --std=93           select vhdl 93 standard");
-      P ("  --std=93c          select vhdl 93 standard and allow 87 syntax");
-      P ("  --[no-]vital-checks  do [not] check VITAL restrictions");
-      P ("Warnings:");
---    P ("  --warn-undriven    disp undriven signals");
-      P ("  --warn-binding     warns for component not bound");
-      P ("  --warn-reserved    warns use of 93 reserved words in vhdl87");
-      P ("  --warn-library     warns for redefinition of a design unit");
-      P ("  --warn-vital-generic  warns of non-vital generic names");
-      P ("  --warn-delayed-checks warns for checks performed at elaboration");
-      P ("  --warn-body        warns for not necessary package body");
-      P ("  --warn-specs       warns if a all/others spec does not apply");
-      P ("  --warn-unused      warns if a subprogram is never used");
-      P ("  --warn-error       turns warnings into errors");
---    P ("Simulation option:");
---    P ("  --time-resolution=UNIT   set the resolution of type time");
---    P ("            UNIT can be fs, ps, ns, us, ms, sec, min or hr");
---    P ("  --assert-level=LEVEL     set the level which stop the");
---    P ("           simulation.  LEVEL is note, warning, error,");
---    P ("           failure or none");
-      P ("Illegal extensions:");
-      P ("  -fexplicit         give priority to explicitly declared operator");
-      P ("  -C  --mb-comments  allow multi-bytes chars in a comment");
-      P ("  --bootstrap        allow --work=std");
-      P ("  --syn-binding      use synthesis default binding rule");
-      P ("Compilation list:");
-      P ("  -ls                after semantics");
-      P ("  -lc                after canon");
-      P ("  -la                after annotation");
-      P ("  --lall             -lX options apply to all files");
-      P ("  -lv                verbose list");
-      P ("  -v                 disp compilation stages");
-      P ("Compilation dump:");
-      P ("  -dp                dump tree after parsing");
-      P ("  -ds                dump tree after semantics");
-      P ("  -da                dump tree after annotate");
-      P ("  --dall             -dX options apply to all files");
-      if Back_End.Disp_Option /= null then
-         Back_End.Disp_Option.all;
-      end if;
-   end Disp_Options_Help;
-
    procedure Create_Flag_String is
    begin
       case Vhdl_Std is
@@ -225,6 +27,8 @@
            | Vhdl_00
            | Vhdl_02 =>
             Flag_String (1 .. 2) := "93";
+         when Vhdl_08 =>
+            Flag_String (1 .. 2) := "08";
       end case;
       if Flag_Integer_64 then
          Flag_String (3) := 'I';
diff -urN ghdl-0.27/vhdl/flags.ads ghdl-0.28dev/vhdl/flags.ads
--- ghdl-0.27/vhdl/flags.ads	2006-06-17 02:14:31.000000000 +0200
+++ ghdl-0.28dev/vhdl/flags.ads	2009-09-20 09:06:46.000000000 +0200
@@ -1,5 +1,5 @@
---  Command line flags.
---  Copyright (C) 2002, 2003, 2004, 2005 Tristan Gingold
+--  Global flags.
+--  Copyright (C) 2002, 2003, 2004, 2005, 2008 Tristan Gingold
 --
 --  GHDL is free software; you can redistribute it and/or modify it under
 --  the terms of the GNU General Public License as published by the Free
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 
@@ -22,20 +22,15 @@
 --  Since the names are not prefixed, this package is expected to be with'ed
 --  but not to be use'd.
 
-with Types; use Types;
-
 package Flags is
+   --  List of vhdl standards.
+   --  VHDL_93c is vhdl_93 with backward compatibility with 87 (file).
+   type Vhdl_Std_Type is
+     (Vhdl_87, Vhdl_93c, Vhdl_93, Vhdl_00, Vhdl_02, Vhdl_08);
+
    -- Standard accepted.
    Vhdl_Std: Vhdl_Std_Type := Vhdl_93c;
 
-   -- Return true if opt is recognize by flags.
-   --  Note: std_names.std_names_initialize and files_map.init_pathes must have
-   --  been called before this subprogram.
-   function Parse_Option (Opt: String) return Boolean;
-
-   -- Disp help about these options.
-   procedure Disp_Options_Help;
-
    --  Some flags (such as vhdl version) must be the same for every design
    --  units of a hierarchy.
    --  The Flag_String is a signature of all these flags.
diff -urN ghdl-0.27/vhdl/ghdldrv/ghdldrv.adb ghdl-0.28dev/vhdl/ghdldrv/ghdldrv.adb
--- ghdl-0.27/vhdl/ghdldrv/ghdldrv.adb	2006-08-19 14:19:01.000000000 +0200
+++ ghdl-0.28dev/vhdl/ghdldrv/ghdldrv.adb	2009-09-20 09:06:42.000000000 +0200
@@ -36,6 +36,7 @@
 with Ghdlmain; use Ghdlmain;
 with Ghdllocal; use Ghdllocal;
 with Version;
+with Options;
 
 package body Ghdldrv is
    --  Name of the tools used.
@@ -43,6 +44,7 @@
    Post_Processor_Cmd : String_Access := null;
    Assembler_Cmd : constant String := "as";
    Linker_Cmd : constant String := "gcc";
+   Llvm_Linker_Cmd : constant String := "llvm-ld";
 
    --  Path of the tools.
    Compiler_Path : String_Access;
@@ -57,14 +59,9 @@
    --  "-o" string.
    Dash_O : String_Access;
 
-   --  "-S" string.
-   Dash_S : String_Access;
-
    --  "-quiet" option.
    Dash_Quiet : String_Access;
 
-   type Compile_Kind_Type is (Compile_Mcode, Compile_Gcc, Compile_Debug);
-   Compile_Kind : Compile_Kind_Type := Compile_Gcc;
 
    --  If set, do not assmble
    Flag_Asm : Boolean;
@@ -142,6 +139,8 @@
          when Compile_Gcc
            | Compile_Debug =>
             Asm_File := Append_Suffix (File, Asm_Suffix);
+         when Compile_Llvm =>
+            Asm_File := Append_Suffix (File, Llvm_Suffix);
          when Compile_Mcode =>
             null;
       end case;
@@ -155,7 +154,8 @@
       --  Compile.
       declare
          P : Natural;
-         Nbr_Args : Natural := Last (Compiler_Args) + Options'Length + 4;
+         Nbr_Args : constant Natural :=
+           Last (Compiler_Args) + Options'Length + 4;
          Args : Argument_List (1 .. Nbr_Args);
       begin
          P := 0;
@@ -178,7 +178,8 @@
          case Compile_Kind is
             when Compile_Debug =>
                Args (P + 2) := Post_File;
-            when Compile_Gcc =>
+            when Compile_Gcc
+              | Compile_Llvm =>
                Args (P + 2) := Asm_File;
             when Compile_Mcode =>
                Args (P + 2) := Obj_File;
@@ -199,7 +200,7 @@
       if Compile_Kind = Compile_Debug then
          declare
             P : Natural;
-            Nbr_Args : Natural := Last (Postproc_Args) + 4;
+            Nbr_Args : constant Natural := Last (Postproc_Args) + 4;
             Args : Argument_List (1 .. Nbr_Args);
          begin
             P := 0;
@@ -229,7 +230,7 @@
          elsif not Flag_Asm then
             declare
                P : Natural;
-               Nbr_Args : Natural := Last (Assembler_Args) + 4;
+               Nbr_Args : constant Natural := Last (Assembler_Args) + 4;
                Args : Argument_List (1 .. Nbr_Args);
                Success : Boolean;
             begin
@@ -259,6 +260,8 @@
       Table_Initial => 16,
       Table_Increment => 100);
 
+   Link_Obj_Suffix : String_Access;
+
    --  Read a list of files from file FILENAME.
    --  Lines starting with a '#' are ignored (comments)
    --  Lines starting with a '>' are directory lines
@@ -299,7 +302,7 @@
       Stream := fopen (Line'Address, Mode'Address);
       if Stream = NULL_Stream then
          Error ("cannot open " & Filename);
-         return;
+         raise Compile_Error;
       end if;
       Dir_Len := 0;
       loop
@@ -323,7 +326,7 @@
                if To_Obj then
                   File := new String'(Dir (1 .. Dir_Len)
                                       & Get_Base_Name (Line (1 .. L))
-                                      & Get_Object_Suffix.all);
+                                      & Link_Obj_Suffix.all);
                else
                   File := new String'(Substitute (Line (1 .. L)));
                end if;
@@ -358,7 +361,6 @@
    is
       use Files_Map;
 
-      Dir : Name_Id;
       Name : Name_Id;
 
       File : Source_File_Entry;
@@ -368,7 +370,6 @@
          return False;
       end if;
 
-      Dir := Get_Library_Directory (Get_Library (Design_File));
       Name := Get_Design_File_Filename (Design_File);
       declare
          Obj_Pathname : String := Get_Object_Filename (Design_File) & Nul;
@@ -508,6 +509,8 @@
                Compiler_Cmd := new String'(Default_Pathes.Compiler_Gcc);
             when Compile_Mcode =>
                Compiler_Cmd := new String'(Default_Pathes.Compiler_Mcode);
+            when Compile_Llvm =>
+               Compiler_Cmd := new String'(Default_Pathes.Compiler_Llvm);
          end case;
       end if;
       if Post_Processor_Cmd = null then
@@ -534,12 +537,18 @@
             Tool_Not_Found (Assembler_Cmd);
          end if;
       end if;
-      Linker_Path := Locate_Exec_On_Path (Linker_Cmd);
-      if Linker_Path = null then
-         Tool_Not_Found (Linker_Cmd);
+      if Compile_Kind = Compile_Llvm then
+         Linker_Path := Locate_Exec_On_Path (Llvm_Linker_Cmd);
+         if Linker_Path = null then
+            Tool_Not_Found (Llvm_Linker_Cmd);
+         end if;
+      else
+         Linker_Path := Locate_Exec_On_Path (Linker_Cmd);
+         if Linker_Path = null then
+            Tool_Not_Found (Linker_Cmd);
+         end if;
       end if;
       Dash_O := new String'("-o");
-      Dash_S := new String'("-S");
       Dash_Quiet := new String'("-quiet");
    end Locate_Tools;
 
@@ -578,7 +587,6 @@
       Flag_Not_Quiet := False;
       Flag_Disp_Commands := False;
       Flag_Asm := False;
-      Compile_Kind := Compile_Gcc;
       Flag_Expect_Failure := False;
       Output_File := null;
 
@@ -596,88 +604,90 @@
                             Res : out Option_Res)
    is
       Str : String_Access;
+      Opt : constant String (1 .. Option'Length) := Option;
    begin
       Res := Option_Bad;
-      if Option = "-v" and then Flag_Verbose = False then
+      if Opt = "-v" and then Flag_Verbose = False then
          --  Note: this is also decoded for command_lib, but we set
          --  Flag_Disp_Commands too.
          Flag_Verbose := True;
          --Flags.Verbose := True;
          Flag_Disp_Commands := True;
          Res := Option_Ok;
-      elsif Option'Length > 8 and then Option (1 .. 8) = "--GHDL1=" then
-         Compiler_Cmd := new String'(Option (9 .. Option'Last));
+      elsif Opt'Length > 8 and then Opt (1 .. 8) = "--GHDL1=" then
+         Compiler_Cmd := new String'(Opt (9 .. Opt'Last));
          Res := Option_Ok;
-      elsif Option = "-S" then
+      elsif Opt = "-S" then
          Flag_Asm := True;
          Res := Option_Ok;
-      elsif Option = "--post" then
+      elsif Opt = "--post" then
          Compile_Kind := Compile_Debug;
          Res := Option_Ok;
-      elsif Option = "--mcode" then
+      elsif Opt = "--mcode" then
          Compile_Kind := Compile_Mcode;
          Res := Option_Ok;
-      elsif Option = "-o" then
+      elsif Opt = "--llvm" then
+         Compile_Kind := Compile_Llvm;
+         Res := Option_Ok;
+      elsif Opt = "-o" then
          if Arg'Length = 0 then
             Res := Option_Arg_Req;
          else
             Output_File := new String'(Arg);
             Res := Option_Arg;
          end if;
-      elsif Option = "-m32" then
+      elsif Opt = "-m32" then
          Add_Argument (Compiler_Args, new String'("-m32"));
          Add_Argument (Assembler_Args, new String'("--32"));
          Add_Argument (Linker_Args, new String'("-m32"));
-         Decode_Option (Command_Lib (Cmd), Option, Arg, Res);
-      elsif Option'Length > 4
-        and then Option (2) = 'W' and then Option (4) = ','
+         Decode_Option (Command_Lib (Cmd), Opt, Arg, Res);
+      elsif Opt'Length > 4
+        and then Opt (2) = 'W' and then Opt (4) = ','
       then
-         if Option (3) = 'c' then
-            Add_Arguments (Compiler_Args, Option);
-         elsif Option (3) = 'a' then
-            Add_Arguments (Assembler_Args, Option);
-         elsif Option (3) = 'p' then
-            Add_Arguments (Postproc_Args, Option);
-         elsif Option (3) = 'l' then
-            Add_Arguments (Linker_Args, Option);
+         if Opt (3) = 'c' then
+            Add_Arguments (Compiler_Args, Opt);
+         elsif Opt (3) = 'a' then
+            Add_Arguments (Assembler_Args, Opt);
+         elsif Opt (3) = 'p' then
+            Add_Arguments (Postproc_Args, Opt);
+         elsif Opt (3) = 'l' then
+            Add_Arguments (Linker_Args, Opt);
          else
             Error
-              ("unknown tool name in '-W" & Option (3) & ",' option");
+              ("unknown tool name in '-W" & Opt (3) & ",' option");
             raise Option_Error;
          end if;
          Res := Option_Ok;
-      elsif Option'Length >= 2 and then Option (2) = 'g' then
+      elsif Opt'Length >= 2 and then Opt (2) = 'g' then
          --  Debugging option.
-         Str := new String'(Option);
+         Str := new String'(Opt);
          Add_Argument (Compiler_Args, Str);
          Add_Argument (Linker_Args, Str);
          Res := Option_Ok;
-      elsif Option = "-Q" then
+      elsif Opt = "-Q" then
          Flag_Not_Quiet := True;
          Res := Option_Ok;
-      elsif Option = "--expect-failure" then
-         Add_Argument (Compiler_Args, new String'(Option));
+      elsif Opt = "--expect-failure" then
+         Add_Argument (Compiler_Args, new String'(Opt));
          Flag_Expect_Failure := True;
          Res := Option_Ok;
-      elsif Flags.Parse_Option (Option) then
-         Add_Argument (Compiler_Args, new String'(Option));
+      elsif Options.Parse_Option (Opt) then
+         Add_Argument (Compiler_Args, new String'(Opt));
          Res := Option_Ok;
-      elsif Option'Length >= 2
-        and then (Option (2) = 'O' or Option (2) = 'f')
+      elsif Opt'Length >= 2
+        and then (Opt (2) = 'O' or Opt (2) = 'f')
       then
          --  Optimization option.
          --  This is put after Flags.Parse_Option, since it may catch -fxxx
          --  options.
-         Add_Argument (Compiler_Args, new String'(Option));
+         Add_Argument (Compiler_Args, new String'(Opt));
          Res := Option_Ok;
       else
-         Decode_Option (Command_Lib (Cmd), Option, Arg, Res);
+         Decode_Option (Command_Lib (Cmd), Opt, Arg, Res);
       end if;
    end Decode_Option;
 
-   procedure Disp_Long_Help (Cmd : Command_Comp)
-   is
-      use Ada.Text_IO;
+   procedure Disp_Long_Help (Cmd : Command_Comp) is
    begin
       Disp_Long_Help (Command_Lib (Cmd));
       Put_Line (" -v             Be verbose");
@@ -719,7 +729,6 @@
    procedure Perform_Action (Cmd : in out Command_Dispconfig;
                              Args : Argument_List)
    is
-      use Ada.Text_IO;
       use Libraries;
       pragma Unreferenced (Cmd);
    begin
@@ -901,7 +910,21 @@
                    Disp_Only : Boolean)
    is
       Last_File : Natural;
+      Final_Output_File : String_Access;
    begin
+      case Compile_Kind is
+         when Compile_Llvm =>
+            Link_Obj_Suffix := new String'(Llvm_Suffix);
+            --  Hacks for llvm:
+            --  1. Generate a native executable.
+            Add_Argument (Linker_Args, new String'("-native"));
+            --  2. Use an intermediate file.
+            Final_Output_File := Output_File;
+            Output_File := new String'(Output_File.all & "~e");
+         when others =>
+            Link_Obj_Suffix := Get_Object_Suffix;
+      end case;
+
       --  read files list
       if Filelist_Name /= null then
          Add_File_List (Filelist_Name.all, True);
@@ -912,13 +935,13 @@
       --  call the linker
       declare
          P : Natural;
-         Nbr_Args : Natural := Last (Linker_Args) + Filelist.Last + 4;
+         Nbr_Args : constant Natural := Last (Linker_Args) + Filelist.Last + 4;
          Args : Argument_List (1 .. Nbr_Args);
          Obj_File : String_Access;
          Std_File : String_Access;
+         Status : Boolean;
       begin
-         Obj_File := Append_Suffix
-           (Elab_Name.all, Get_Object_Suffix.all);
+         Obj_File := Append_Suffix (Elab_Name.all, Link_Obj_Suffix.all);
          P := 0;
          Args (P + 1) := Dash_O;
          Args (P + 2) := Output_File;
@@ -929,7 +952,7 @@
               String'(Get_Machine_Path_Prefix
                       & Get_Version_Path & Directory_Separator
                       & "std" & Directory_Separator
-                      & "std_standard" & Get_Object_Suffix.all);
+                      & "std_standard" & Link_Obj_Suffix.all);
             P := P + 1;
             Args (P) := Std_File;
          else
@@ -959,6 +982,14 @@
             end loop;
          else
             My_Spawn (Linker_Path.all, Args (1 .. P));
+            if Compile_Kind = Compile_Llvm then
+               Rename_File (Output_File.all, Final_Output_File.all, Status);
+               if not Status then
+                  raise Compile_Error;
+               end if;
+               Free (Output_File);
+               Output_File := Final_Output_File;
+            end if;
          end if;
 
          Free (Obj_File);
@@ -997,6 +1028,7 @@
    is
       pragma Unreferenced (Cmd);
       Success : Boolean;
+      pragma Unreferenced (Success);
    begin
       Set_Elab_Units ("-e", Args);
       Setup_Compiler (False);
@@ -1614,7 +1646,7 @@
       Put ("GHDLFLAGS=");
       for I in 2 .. Argument_Count loop
          declare
-            Arg : String := Argument (I);
+            Arg : constant String := Argument (I);
          begin
             if Arg (1) = '-' then
                if (Arg'Length > 10 and then Arg (1 .. 10) = "--workdir=")
diff -urN ghdl-0.27/vhdl/ghdldrv/ghdldrv.ads ghdl-0.28dev/vhdl/ghdldrv/ghdldrv.ads
--- ghdl-0.27/vhdl/ghdldrv/ghdldrv.ads	2005-09-22 23:48:24.000000000 +0200
+++ ghdl-0.28dev/vhdl/ghdldrv/ghdldrv.ads	2009-09-20 09:06:42.000000000 +0200
@@ -16,5 +16,10 @@
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 package Ghdldrv is
+   --  Compiler to use.
+   type Compile_Kind_Type is
+     (Compile_Mcode, Compile_Llvm, Compile_Gcc, Compile_Debug);
+   Compile_Kind : Compile_Kind_Type := Compile_Gcc;
+
    procedure Register_Commands;
 end Ghdldrv;
diff -urN ghdl-0.27/vhdl/ghdldrv/ghdl_gcc.adb ghdl-0.28dev/vhdl/ghdldrv/ghdl_gcc.adb
--- ghdl-0.27/vhdl/ghdldrv/ghdl_gcc.adb	2006-03-10 03:50:34.000000000 +0100
+++ ghdl-0.28dev/vhdl/ghdldrv/ghdl_gcc.adb	2009-09-20 09:06:42.000000000 +0200
@@ -25,6 +25,7 @@
    --  Manual elaboration so that the order is known (because it is the order
    --  used to display help).
    Ghdlmain.Version_String := new String'("GCC back-end code generator");
+   Ghdldrv.Compile_Kind := Ghdldrv.Compile_Gcc;
    Ghdldrv.Register_Commands;
    Ghdllocal.Register_Commands;
    Ghdlprint.Register_Commands;
diff -urN ghdl-0.27/vhdl/ghdldrv/ghdllocal.adb ghdl-0.28dev/vhdl/ghdldrv/ghdllocal.adb
--- ghdl-0.27/vhdl/ghdldrv/ghdllocal.adb	2006-08-19 14:22:56.000000000 +0200
+++ ghdl-0.28dev/vhdl/ghdldrv/ghdllocal.adb	2009-09-20 09:06:42.000000000 +0200
@@ -16,7 +16,6 @@
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Ada.Text_IO;
-with Ghdlmain;
 with Types; use Types;
 with Libraries;
 with Std_Package;
@@ -34,13 +33,14 @@
 with Files_Map;
 with Post_Sems;
 with Disp_Tree;
+with Options;
 
 package body Ghdllocal is
    --  Version of the IEEE library to use.  This just change pathes.
    type Ieee_Lib_Kind is (Lib_Standard, Lib_None, Lib_Synopsys, Lib_Mentor);
    Flag_Ieee : Ieee_Lib_Kind;
 
-   Flag_Create_Default_Config : Boolean := True;
+   Flag_Create_Default_Config : constant Boolean := True;
 
    --  If TRUE, generate 32bits code on 64bits machines.
    Flag_32bit : Boolean := False;
@@ -53,6 +53,10 @@
       Config : Iir_Design_Unit;
       Lib : Iir;
    begin
+      if (Main or Flags.Dump_All) and then Flags.Dump_Parse then
+         Disp_Tree.Disp_Tree (Unit);
+      end if;
+
       if Flags.Verbose then
          Put_Line ("semantize " & Disp_Node (Get_Library_Unit (Unit)));
       end if;
@@ -67,6 +71,10 @@
          raise Compilation_Error;
       end if;
 
+      if (Main or Flags.List_All) and then Flags.List_Sem then
+         Disp_Vhdl.Disp_Vhdl (Unit);
+      end if;
+
       Post_Sems.Post_Sem_Checks (Unit);
 
       if Errorout.Nbr_Errors > 0 then
@@ -108,36 +116,37 @@
    is
       pragma Unreferenced (Cmd);
       pragma Unreferenced (Arg);
+      Opt : constant String (1 .. Option'Length) := Option;
    begin
       Res := Option_Bad;
-      if Option = "-v" and then Flag_Verbose = False then
+      if Opt = "-v" and then Flag_Verbose = False then
          Flag_Verbose := True;
          Res := Option_Ok;
-      elsif Option'Length > 9 and then Option (1 .. 9) = "--PREFIX=" then
-         Prefix_Path := new String'(Option (10 .. Option'Last));
+      elsif Opt'Length > 9 and then Opt (1 .. 9) = "--PREFIX=" then
+         Prefix_Path := new String'(Opt (10 .. Opt'Last));
          Res := Option_Ok;
-      elsif Option = "--ieee=synopsys" then
+      elsif Opt = "--ieee=synopsys" then
          Flag_Ieee := Lib_Synopsys;
          Res := Option_Ok;
-      elsif Option = "--ieee=mentor" then
+      elsif Opt = "--ieee=mentor" then
          Flag_Ieee := Lib_Mentor;
          Res := Option_Ok;
-      elsif Option = "--ieee=none" then
+      elsif Opt = "--ieee=none" then
          Flag_Ieee := Lib_None;
          Res := Option_Ok;
-      elsif Option = "--ieee=standard" then
+      elsif Opt = "--ieee=standard" then
          Flag_Ieee := Lib_Standard;
          Res := Option_Ok;
-      elsif Option = "-m32" then
+      elsif Opt = "-m32" then
          Flag_32bit := True;
          Res := Option_Ok;
-      elsif Option'Length >= 2
-        and then (Option (2) = 'g' or Option (2) = 'O')
+      elsif Opt'Length >= 2
+        and then (Opt (2) = 'g' or Opt (2) = 'O')
       then
          --  Silently accept -g and -O.
          Res := Option_Ok;
       else
-         if Flags.Parse_Option (Option) then
+         if Options.Parse_Option (Opt) then
             Res := Option_Ok;
          end if;
       end if;
@@ -161,9 +170,11 @@
       P ("    none: do not use a predefined ieee library");
    end Disp_Long_Help;
 
-   function Get_Version_Path return String is
+   function Get_Version_Path return String
+   is
+      use Flags;
    begin
-      case Flags.Vhdl_Std is
+      case Vhdl_Std is
          when Vhdl_87 =>
             return "v87";
          when Vhdl_93c
@@ -171,6 +182,8 @@
            | Vhdl_00
            | Vhdl_02 =>
             return "v93";
+         when Vhdl_08 =>
+            return "v08";
       end case;
    end Get_Version_Path;
 
@@ -326,7 +339,7 @@
    function Append_Suffix (File : String; Suffix : String) return String_Access
    is
       use Name_Table;
-      Basename : String := Get_Base_Name (File);
+      Basename : constant String := Get_Base_Name (File);
    begin
       Image (Libraries.Work_Directory);
       Name_Buffer (Name_Length + 1 .. Name_Length + Basename'Length) :=
@@ -429,7 +442,7 @@
       Design_File : Iir_Design_File;
       Unit : Iir;
       Lib : Iir;
-      Flag_Add : Boolean := False;
+      Flag_Add : constant Boolean := False;
    begin
       Flags.Bootstrap := True;
       Libraries.Load_Std_Library;
@@ -646,7 +659,6 @@
 
    procedure Delete (Str : String)
    is
-      use GNAT.OS_Lib;
       use Ada.Text_IO;
       Status : Boolean;
    begin
@@ -659,7 +671,6 @@
    procedure Perform_Action (Cmd : in out Command_Clean; Args : Argument_List)
    is
       pragma Unreferenced (Cmd);
-      use GNAT.OS_Lib;
       use Name_Table;
 
       procedure Delete_Asm_Obj (Str : String) is
@@ -805,6 +816,7 @@
       procedure Extract_Library_Clauses (Unit : Iir_Design_Unit)
       is
          Lib1 : Iir_Library_Declaration;
+         pragma Unreferenced (Lib1);
          Ctxt_Item : Iir;
       begin
          --  Extract library clauses.
@@ -1059,7 +1071,7 @@
 
       if Args'Length >= 2 then
          declare
-            Sec : String_Access := Args (Next_Arg);
+            Sec : constant String_Access := Args (Next_Arg);
          begin
             if Sec (Sec'First) /= '-' then
                Sec_Name := Convert_Name (Sec);
diff -urN ghdl-0.27/vhdl/ghdldrv/ghdllocal.ads ghdl-0.28dev/vhdl/ghdldrv/ghdllocal.ads
--- ghdl-0.27/vhdl/ghdldrv/ghdllocal.ads	2006-08-19 14:09:08.000000000 +0200
+++ ghdl-0.28dev/vhdl/ghdldrv/ghdllocal.ads	2009-09-20 09:06:42.000000000 +0200
@@ -41,6 +41,9 @@
    --  Suffix for asm files.
    Asm_Suffix : constant String := ".s";
 
+   --  Suffix for llvm byte-code files.
+   Llvm_Suffix : constant String := ".bc";
+
    --  Suffix for post files.
    Post_Suffix : constant String := ".on";
 
diff -urN ghdl-0.27/vhdl/ghdldrv/ghdlmain.adb ghdl-0.28dev/vhdl/ghdldrv/ghdlmain.adb
--- ghdl-0.27/vhdl/ghdldrv/ghdlmain.adb	2008-06-11 03:54:15.000000000 +0200
+++ ghdl-0.28dev/vhdl/ghdldrv/ghdlmain.adb	2009-09-20 09:06:42.000000000 +0200
@@ -18,9 +18,8 @@
 with Ada.Text_IO;
 with Ada.Command_Line;
 with Version;
-with Flags;
 with Bug;
-with Errorout;
+with Options;
 
 package body Ghdlmain is
    procedure Init (Cmd : in out Command_Type)
@@ -184,7 +183,7 @@
          Error
            ("warning: command '--option-help' does not accept any argument");
       end if;
-      Flags.Disp_Options_Help;
+      Options.Disp_Options_Help;
    end Perform_Action;
 
    --  Command Version
@@ -275,7 +274,7 @@
       Arg_Index := 2;
       while Arg_Index <= Argument_Count loop
          declare
-            Arg : String := Argument (Arg_Index);
+            Arg : constant String := Argument (Arg_Index);
             Res : Option_Res;
          begin
             if Arg (1) = '-' then
diff -urN ghdl-0.27/vhdl/ghdldrv/ghdlprint.adb ghdl-0.28dev/vhdl/ghdldrv/ghdlprint.adb
--- ghdl-0.27/vhdl/ghdldrv/ghdlprint.adb	2006-08-19 13:55:44.000000000 +0200
+++ ghdl-0.28dev/vhdl/ghdldrv/ghdlprint.adb	2009-09-20 09:06:42.000000000 +0200
@@ -75,6 +75,7 @@
 
    procedure PP_Html_File (File : Source_File_Entry)
    is
+      use Flags;
       use Scan;
       use Tokens;
       use Files_Map;
@@ -84,9 +85,6 @@
       Buf : File_Buffer_Acc;
       Prev_Tok : Token_Type;
 
-      --  True if tokens are between 'end' and ';'
-      In_End : Boolean := False;
-
       --  Current logical column number.  Used to expand TABs.
       Col : Natural;
 
@@ -372,9 +370,7 @@
                Disp_Reserved;
             when Tok_End =>
                Disp_Reserved;
-               In_End := True;
             when Tok_Semi_Colon =>
-               In_End := False;
                Disp_Spaces;
                Disp_Text;
             when Tok_Xnor .. Tok_Ror =>
@@ -944,16 +940,14 @@
       end if;
    end Decode_Option;
 
-   procedure Disp_Long_Help (Cmd : Command_Html)
-   is
-      use Ada.Text_IO;
+   procedure Disp_Long_Help (Cmd : Command_Html) is
    begin
       Disp_Long_Help (Command_Lib (Cmd));
       Put_Line ("--format=html2  Use FONT attributes");
       Put_Line ("--format=css    Use ghdl.css file");
    end Disp_Long_Help;
 
-   --  Command --pp_html.
+   --  Command --pp-html.
    type Command_PP_Html is new Command_Html with null record;
    function Decode_Command (Cmd : Command_PP_Html; Name : String)
                            return Boolean;
@@ -1068,9 +1062,7 @@
       end if;
    end Decode_Option;
 
-   procedure Disp_Long_Help (Cmd : Command_Xref_Html)
-   is
-      use Ada.Text_IO;
+   procedure Disp_Long_Help (Cmd : Command_Xref_Html) is
    begin
       Disp_Long_Help (Command_Html (Cmd));
       Put_Line ("-o DIR          Put generated files into DIR (def: html/)");
@@ -1115,7 +1107,6 @@
 
       Files : File_Data_Array;
       Output : File_Type;
-      Prev_Output : File_Access;
    begin
       Xrefs.Init;
       Flags.Flag_Xref := True;
@@ -1220,8 +1211,6 @@
          Filexref_Info (Files (I).Fe).Output := Files (I).Output;
       end loop;
 
-      Prev_Output := Current_Input;
-
       for I in Files'Range loop
          if Cmd.Output_Dir /= null then
             Create (Output, Out_File,
@@ -1304,7 +1293,7 @@
         and then Cmd.Output_Dir /= null
       then
          declare
-            Css_Filename : String :=
+            Css_Filename : constant String :=
               Cmd.Output_Dir.all & Directory_Separator & "ghdl.css";
          begin
             if not Is_Regular_File (Css_Filename & Nul) then
@@ -1427,6 +1416,7 @@
                Loc_File : Source_File_Entry;
                Loc_Pos : Source_Ptr;
                C : Character;
+               Dir : Name_Id;
             begin
                New_Line;
                Cur_Decl := N;
@@ -1435,8 +1425,11 @@
                if Loc_File /= Cur_File then
                   Cur_File := Loc_File;
                   Put ("XFILE: ");
-                  Image (Get_Source_File_Directory (Cur_File));
-                  Put (Name_Buffer (1 .. Name_Length));
+                  Dir := Get_Source_File_Directory (Cur_File);
+                  if Dir /= Null_Identifier then
+                     Image (Dir);
+                     Put (Name_Buffer (1 .. Name_Length));
+                  end if;
                   Image (Get_File_Name (Cur_File));
                   Put (Name_Buffer (1 .. Name_Length));
                   New_Line;
@@ -1537,8 +1530,6 @@
                         Emit_Ref (I, 'r');
                      when Xref_Body =>
                         Emit_Ref (I, 'b');
-                     when others =>
-                        null;
                   end case;
                end if;
             end loop;
diff -urN ghdl-0.27/vhdl/ghdl.texi ghdl-0.28dev/vhdl/ghdl.texi
--- ghdl-0.27/vhdl/ghdl.texi	2008-06-27 02:26:06.000000000 +0200
+++ ghdl-0.28dev/vhdl/ghdl.texi	2009-09-20 09:06:40.000000000 +0200
@@ -16,7 +16,7 @@
 @c The following two commands start the copyright page.
 @page
 @vskip 0pt plus 1filll
-Copyright @copyright{} 2002, 2003, 2004, 2005, 2006, 2007, 2008 Tristan Gingold.
+Copyright @copyright{} 2002-2009 Tristan Gingold.
 
 Permission is granted to copy, distribute and/or modify this document
 under the terms of the GNU Free Documentation License, Version 1.1 or
@@ -518,6 +518,7 @@
 * Misc commands::               
 * Installation Directory::      
 * IEEE library pitfalls::       
+* IEEE math packages::          
 @end menu
 
 @node Building commands, GHDL options, Invoking GHDL, Invoking GHDL
@@ -1387,7 +1388,7 @@
 
 You should use the @option{--dispconfig} command (@pxref{Dispconfig command} for details) to disp and debug installation problems.
 
-@node IEEE library pitfalls,  , Installation Directory, Invoking GHDL
+@node IEEE library pitfalls, IEEE math packages, Installation Directory, Invoking GHDL
 @comment  node-name,  next,  previous,  up
 @section IEEE library pitfalls
 When you use options @option{--ieee=synopsys} or @option{--ieee=mentor},
@@ -1515,6 +1516,46 @@
 end good;
 @end example
 
+@node IEEE math packages,  , IEEE library pitfalls, Invoking GHDL
+@comment  node-name,  next,  previous,  up
+@section IEEE math packages
+@cindex Math_Real
+@cindex Math_Complex
+
+The @samp{ieee} math packages (@samp{math_real} and
+@samp{math_complex}) provided with @code{GHDL} are not fully compliant with
+the @code{IEEE} standard.  They are based on an early draft which can be
+redistributed contrary to the final version of the package.
+
+This is unfortunate and may generate errors as some declarations are missing
+or have slightly changed.
+
+If you have bought the standard from @samp{ieee} then you can download
+the sources of the packages from
+@url{http://standards.ieee.org/downloads/1076/1076.2-1996}
+(unrestricted access).  You'd better to just download
+@file{math_real.vhdl}, @file{math_real-body.vhdl},
+@file{math_complex.vhdl} and @file{math_complex-body.vhdl}.  The other files
+are not necessary: the @samp{std_logic_1164} package has to be updated for
+@code{VHDL} 1993 (the @code{xnor} functions are commented out).
+
+If you want to replace math packages for the standard version of the
+@code{ieee} library, do:
+@smallexample
+$ cp math_real.vhdl math_real-body.vhdl @file{ieee_install_dir}
+$ cp math_complex.vhdl math_complex-body.vhdl @file{ieee_install_dir}
+$ cd @file{ieee_install_dir}
+$ ghdl -a --work=ieee math_real.vhdl math_real-body.vhdl
+$ ghdl -a --work=ieee math_complex.vhdl math_complex-body.vhdl
+@end smallexample
+(Replace @file{ieee_install_dir} by the location of the @code{ieee} library as
+displayed by @samp{ghdl -dispconfig}).
+
+You can repeat this for the @samp{synopsys} version of the @code{ieee} library.
+
+Don't forget that the math packages are only defined for the 1993 standard.
+
+
 @node Simulation and run time, GHDL implementation of VHDL, Invoking GHDL, Top
 @comment  node-name,  next,  previous,  up
 @chapter Simulation and run time
diff -urN ghdl-0.27/vhdl/grt/grt.adc ghdl-0.28dev/vhdl/grt/grt.adc
--- ghdl-0.27/vhdl/grt/grt.adc	2005-11-08 21:01:08.000000000 +0100
+++ ghdl-0.28dev/vhdl/grt/grt.adc	2009-09-20 09:06:43.000000000 +0200
@@ -28,10 +28,12 @@
 --  This files is *not* names gnat.adc, in order to ease the possibility of
 --  not using it.
 pragma Restrictions (No_Exception_Handlers);
-pragma restrictions (No_Exceptions);
+--pragma restrictions (No_Exceptions);
 pragma Restrictions (No_Secondary_Stack);
 --pragma Restrictions (No_Elaboration_Code);
 pragma Restrictions (No_Io);
+pragma restrictions (no_dependence => Ada.Tags);
+pragma restrictions (no_dependence => GNAT);
 pragma Restrictions (Max_Tasks => 0);
 pragma Restrictions (No_Implicit_Heap_Allocations);
 pragma No_Run_Time;
diff -urN ghdl-0.27/vhdl/grt/grt-astdio.adb ghdl-0.28dev/vhdl/grt/grt-astdio.adb
--- ghdl-0.27/vhdl/grt/grt-astdio.adb	2005-12-11 15:03:37.000000000 +0100
+++ ghdl-0.28dev/vhdl/grt/grt-astdio.adb	2009-09-20 09:06:43.000000000 +0200
@@ -21,6 +21,7 @@
    procedure Put (Stream : FILEs; Str : String)
    is
       S : size_t;
+      pragma Unreferenced (S);
    begin
       S := fwrite (Str'Address, Str'Length, 1, Stream);
    end Put;
@@ -28,6 +29,7 @@
    procedure Put (Stream : FILEs; C : Character)
    is
       R : int;
+      pragma Unreferenced (R);
    begin
       R := fputc (Character'Pos (C), Stream);
    end Put;
@@ -36,6 +38,7 @@
    is
       Len : Natural;
       S : size_t;
+      pragma Unreferenced (S);
    begin
       Len := strlen (Str);
       S := fwrite (Str (1)'Address, size_t (Len), 1, Stream);
@@ -49,6 +52,7 @@
    procedure Put (Str : String)
    is
       S : size_t;
+      pragma Unreferenced (S);
    begin
       S := fwrite (Str'Address, Str'Length, 1, stdout);
    end Put;
@@ -56,6 +60,7 @@
    procedure Put (C : Character)
    is
       R : int;
+      pragma Unreferenced (R);
    begin
       R := fputc (Character'Pos (C), stdout);
    end Put;
@@ -64,6 +69,7 @@
    is
       Len : Natural;
       S : size_t;
+      pragma Unreferenced (S);
    begin
       Len := strlen (Str);
       S := fwrite (Str (1)'Address, size_t (Len), 1, stdout);
diff -urN ghdl-0.27/vhdl/grt/grt-avhpi.adb ghdl-0.28dev/vhdl/grt/grt-avhpi.adb
--- ghdl-0.27/vhdl/grt/grt-avhpi.adb	2008-05-25 07:56:02.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-avhpi.adb	2009-09-20 09:06:43.000000000 +0200
@@ -126,9 +126,9 @@
             case Res.N_Type.Kind is
                when Ghdl_Rtik_Subtype_Array =>
                   declare
-                     St : Ghdl_Rtin_Subtype_Array_Acc :=
+                     St : constant Ghdl_Rtin_Subtype_Array_Acc :=
                        To_Ghdl_Rtin_Subtype_Array_Acc (Res.N_Type);
-                     Bt : Ghdl_Rtin_Type_Array_Acc := St.Basetype;
+                     Bt : constant Ghdl_Rtin_Type_Array_Acc := St.Basetype;
                      Rngs : Ghdl_Range_Array (0 .. Bt.Nbr_Dim - 1);
                   begin
                      Bound_To_Range
@@ -155,6 +155,7 @@
                        El_Type : Ghdl_Rti_Access;
                        Off : Ghdl_Index_Type) return Address
    is
+      pragma Unreferenced (Ctxt);
       Is_Sig : Boolean;
       El_Size : Ghdl_Index_Type;
       El_Type1 : Ghdl_Rti_Access;
@@ -389,7 +390,6 @@
    is
       Blk : Ghdl_Rtin_Block_Acc;
       Ch : Ghdl_Rti_Access;
-      Obj : Ghdl_Rtin_Object_Acc;
    begin
       Blk := To_Ghdl_Rtin_Block_Acc (Iterator.Ctxt.Block);
 
@@ -420,7 +420,6 @@
             exit when Iterator.It_Cur >= Blk.Nbr_Child;
 
             Ch := Blk.Children (Iterator.It_Cur);
-            Obj := To_Ghdl_Rtin_Object_Acc (Ch);
 
             Iterator.It_Cur := Iterator.It_Cur + 1;
 
@@ -874,11 +873,12 @@
                when VhpiSubtypeIndicK =>
                   if Ref.Atype.Kind = Ghdl_Rtik_Subtype_Array then
                      declare
-                        Arr_Subtype : Ghdl_Rtin_Subtype_Array_Acc :=
+                        Arr_Subtype : constant Ghdl_Rtin_Subtype_Array_Acc :=
                           To_Ghdl_Rtin_Subtype_Array_Acc (Ref.Atype);
-                        Basetype : Ghdl_Rtin_Type_Array_Acc :=
+                        Basetype : constant Ghdl_Rtin_Type_Array_Acc :=
                           Arr_Subtype.Basetype;
-                        Idx : Ghdl_Index_Type := Ghdl_Index_Type (Index);
+                        Idx : constant Ghdl_Index_Type :=
+                          Ghdl_Index_Type (Index);
                         Bounds : Ghdl_Range_Array (0 .. Basetype.Nbr_Dim - 1);
                         Range_Basetype : Ghdl_Rti_Access;
                      begin
@@ -961,6 +961,7 @@
       case Property is
          when VhpiLeftBoundP =>
             if Obj.Kind /= VhpiIntRangeK then
+               Res := 0;
                Error := AvhpiErrorBadRel;
                return;
             end if;
@@ -999,6 +1000,7 @@
       case Property is
          when VhpiIsUpP =>
             if Obj.Kind /= VhpiIntRangeK then
+               Res := False;
                Error := AvhpiErrorBadRel;
                return;
             end if;
diff -urN ghdl-0.27/vhdl/grt/grt-c.ads ghdl-0.28dev/vhdl/grt/grt-c.ads
--- ghdl-0.27/vhdl/grt/grt-c.ads	2005-10-06 18:27:10.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-c.ads	2009-09-20 09:06:43.000000000 +0200
@@ -33,4 +33,15 @@
 
    --  Type int.  It is an alias on Integer for simplicity.
    subtype int is Integer;
+
+   --  Low level memory management.
+   procedure Free (Addr : System.Address);
+   function Malloc (Size : size_t) return System.Address;
+   function Realloc (Ptr : System.Address; Size : size_t)
+                    return System.Address;
+
+private
+   pragma Import (C, Free);
+   pragma Import (C, Malloc);
+   pragma Import (C, Realloc);
 end Grt.C;
diff -urN ghdl-0.27/vhdl/grt/grt-disp.adb ghdl-0.28dev/vhdl/grt/grt-disp.adb
--- ghdl-0.27/vhdl/grt/grt-disp.adb	2006-09-07 07:08:08.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-disp.adb	2009-09-20 09:06:43.000000000 +0200
@@ -16,8 +16,7 @@
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with System.Storage_Elements; --  Work around GNAT bug.
-with Grt.Types; use Grt.Types;
-with Grt.Signals; use Grt.Signals;
+pragma Unreferenced (System.Storage_Elements);
 with Grt.Astdio; use Grt.Astdio;
 with Grt.Stdio; use Grt.Stdio;
 --with Grt.Errors; use Grt.Errors;
diff -urN ghdl-0.27/vhdl/grt/grt-disp_rti.adb ghdl-0.28dev/vhdl/grt/grt-disp_rti.adb
--- ghdl-0.27/vhdl/grt/grt-disp_rti.adb	2006-05-29 21:36:38.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-disp_rti.adb	2009-09-20 09:06:43.000000000 +0200
@@ -17,7 +17,6 @@
 --  02111-1307, USA.
 with Grt.Astdio; use Grt.Astdio;
 with Grt.Errors; use Grt.Errors;
-with Grt.Rtis_Addr; use Grt.Rtis_Addr;
 with Grt.Hooks; use Grt.Hooks;
 
 package body Grt.Disp_Rti is
@@ -153,7 +152,7 @@
                                Vals : Ghdl_Uc_Array_Acc;
                                Is_Sig : Boolean)
    is
-      Nbr_Dim : Ghdl_Index_Type := Rti.Nbr_Dim;
+      Nbr_Dim : constant Ghdl_Index_Type := Rti.Nbr_Dim;
       Rngs : Ghdl_Range_Array (0 .. Nbr_Dim - 1);
       Obj : Address;
    begin
@@ -166,7 +165,7 @@
    procedure Disp_Record_Value (Stream : FILEs;
                                 Rti : Ghdl_Rtin_Type_Record_Acc;
                                 Ctxt : Rti_Context;
-                                Obj : in out Address;
+                                Obj : Address;
                                 Is_Sig : Boolean)
    is
       El : Ghdl_Rtin_Element_Acc;
@@ -214,9 +213,9 @@
                               To_Ghdl_Uc_Array_Acc (Obj), Is_Sig);
          when Ghdl_Rtik_Subtype_Array =>
             declare
-               St : Ghdl_Rtin_Subtype_Array_Acc :=
+               St : constant Ghdl_Rtin_Subtype_Array_Acc :=
                  To_Ghdl_Rtin_Subtype_Array_Acc (Rti);
-               Bt : Ghdl_Rtin_Type_Array_Acc := St.Basetype;
+               Bt : constant Ghdl_Rtin_Type_Array_Acc := St.Basetype;
                Rngs : Ghdl_Range_Array (0 .. Bt.Nbr_Dim - 1);
                B : Address;
             begin
@@ -228,9 +227,9 @@
             end;
          when Ghdl_Rtik_Subtype_Array_Ptr =>
             declare
-               St : Ghdl_Rtin_Subtype_Array_Acc :=
+               St : constant Ghdl_Rtin_Subtype_Array_Acc :=
                  To_Ghdl_Rtin_Subtype_Array_Acc (Rti);
-               Bt : Ghdl_Rtin_Type_Array_Acc := St.Basetype;
+               Bt : constant Ghdl_Rtin_Type_Array_Acc := St.Basetype;
                Rngs : Ghdl_Range_Array (0 .. Bt.Nbr_Dim - 1);
                B : Address;
             begin
diff -urN ghdl-0.27/vhdl/grt/grt-disp_signals.adb ghdl-0.28dev/vhdl/grt/grt-disp_signals.adb
--- ghdl-0.27/vhdl/grt/grt-disp_signals.adb	2006-09-27 03:11:26.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-disp_signals.adb	2009-09-20 09:06:43.000000000 +0200
@@ -17,18 +17,15 @@
 --  02111-1307, USA.
 with System; use System;
 with System.Storage_Elements; --  Work around GNAT bug.
+pragma Unreferenced (System.Storage_Elements);
 with Ada.Unchecked_Conversion;
-with Grt.Types; use Grt.Types;
 with Grt.Rtis; use Grt.Rtis;
 with Grt.Rtis_Addr; use Grt.Rtis_Addr;
 with Grt.Rtis_Utils; use Grt.Rtis_Utils;
-with Grt.Rtis; use Grt.Rtis;
 with Grt.Astdio; use Grt.Astdio;
 with Grt.Errors; use Grt.Errors;
 pragma Elaborate_All (Grt.Rtis_Utils);
 with Grt.Vstrings; use Grt.Vstrings;
-with Grt.Stdio; use Grt.Stdio;
-with Grt.Signals; use Grt.Signals;
 with Grt.Options;
 with Grt.Disp; use Grt.Disp;
 
@@ -231,6 +228,7 @@
    procedure Disp_All_Signals
    is
       Res : Traverse_Result;
+      pragma Unreferenced (Res);
    begin
       if Boolean'(False) then
          for I in Sig_Table.First .. Sig_Table.Last loop
@@ -308,6 +306,7 @@
    procedure Disp_Signals_Map
    is
       Res : Traverse_Result;
+      pragma Unreferenced (Res);
    begin
       Res := Disp_Signals_Map_Blocks (Get_Top_Context);
       Grt.Stdio.fflush (stdout);
@@ -351,7 +350,6 @@
 
    procedure Disp_Signals_Table
    is
-      use Grt.Disp;
       Sig : Ghdl_Signal_Ptr;
    begin
       for I in Sig_Table.First .. Sig_Table.Last loop
@@ -458,6 +456,7 @@
         (Process_Block);
 
       Res_Status : Traverse_Result;
+      pragma Unreferenced (Res_Status);
    begin
       Res_Status := Foreach_Block (Get_Top_Context);
       if not Found then
diff -urN ghdl-0.27/vhdl/grt/grt-disp_tree.adb ghdl-0.28dev/vhdl/grt/grt-disp_tree.adb
--- ghdl-0.27/vhdl/grt/grt-disp_tree.adb	2005-12-11 18:16:59.000000000 +0100
+++ ghdl-0.28dev/vhdl/grt/grt-disp_tree.adb	2009-09-20 09:06:43.000000000 +0200
@@ -83,7 +83,8 @@
            | Ghdl_Rtik_Block
            | Ghdl_Rtik_If_Generate =>
             declare
-               Blk : Ghdl_Rtin_Block_Acc := To_Ghdl_Rtin_Block_Acc (Rti);
+               Blk : constant Ghdl_Rtin_Block_Acc :=
+                 To_Ghdl_Rtin_Block_Acc (Rti);
             begin
                Disp_Name (Blk.Name);
             end;
@@ -104,7 +105,8 @@
             end;
          when Ghdl_Rtik_For_Generate =>
             declare
-               Blk : Ghdl_Rtin_Block_Acc := To_Ghdl_Rtin_Block_Acc (Rti);
+               Blk : constant Ghdl_Rtin_Block_Acc :=
+                 To_Ghdl_Rtin_Block_Acc (Rti);
                Iter : Ghdl_Rtin_Object_Acc;
                Addr : Address;
             begin
@@ -231,7 +233,8 @@
             when Ghdl_Rtik_Process
               | Ghdl_Rtik_Block =>
                declare
-                  Nblk : Ghdl_Rtin_Block_Acc := To_Ghdl_Rtin_Block_Acc (Child);
+                  Nblk : constant Ghdl_Rtin_Block_Acc :=
+                    To_Ghdl_Rtin_Block_Acc (Child);
                   Nctxt : Rti_Context;
                begin
                   Nctxt := (Base => Ctxt.Base + Nblk.Loc.Off,
@@ -241,7 +244,8 @@
                end;
             when Ghdl_Rtik_For_Generate =>
                declare
-                  Nblk : Ghdl_Rtin_Block_Acc := To_Ghdl_Rtin_Block_Acc (Child);
+                  Nblk : constant Ghdl_Rtin_Block_Acc :=
+                    To_Ghdl_Rtin_Block_Acc (Child);
                   Nctxt : Rti_Context;
                   Length : Ghdl_Index_Type;
                   Old_Child2 : Ghdl_Rti_Access;
@@ -268,7 +272,8 @@
                end;
             when Ghdl_Rtik_If_Generate =>
                declare
-                  Nblk : Ghdl_Rtin_Block_Acc := To_Ghdl_Rtin_Block_Acc (Child);
+                  Nblk : constant Ghdl_Rtin_Block_Acc :=
+                    To_Ghdl_Rtin_Block_Acc (Child);
                   Nctxt : Rti_Context;
                begin
                   Nctxt := (Base => To_Addr_Acc (Ctxt.Base + Nblk.Loc.Off).all,
@@ -402,8 +407,9 @@
       end loop;
    end Disp_Hierarchy;
 
-   function Disp_Tree_Option (Opt : String) return Boolean
+   function Disp_Tree_Option (Option : String) return Boolean
    is
+      Opt : constant String (1 .. Option'Length) := Option;
    begin
       if Opt'Length >= 11 and then Opt (1 .. 11) = "--disp-tree" then
          if Opt'Length = 11 then
diff -urN ghdl-0.27/vhdl/grt/grt-errors.adb ghdl-0.28dev/vhdl/grt/grt-errors.adb
--- ghdl-0.27/vhdl/grt/grt-errors.adb	2007-12-02 03:00:40.000000000 +0100
+++ ghdl-0.28dev/vhdl/grt/grt-errors.adb	2009-09-20 09:06:43.000000000 +0200
@@ -17,7 +17,6 @@
 --  02111-1307, USA.
 with Grt.Stdio; use Grt.Stdio;
 with Grt.Astdio; use Grt.Astdio;
-with Grt.Types; use Grt.Types;
 with Grt.Options; use Grt.Options;
 
 package body Grt.Errors is
@@ -106,7 +105,7 @@
 
    procedure Report_C (Str : Ghdl_C_String)
    is
-      Len : Natural := strlen (Str);
+      Len : constant Natural := strlen (Str);
    begin
       Put_Err (Str (1 .. Len));
    end Report_C;
@@ -154,7 +153,7 @@
 
    procedure Error_C (Str : Ghdl_C_String)
    is
-      Len : Natural := strlen (Str);
+      Len : constant Natural := strlen (Str);
    begin
       if not Cont then
          Error_H;
diff -urN ghdl-0.27/vhdl/grt/grt-files.adb ghdl-0.28dev/vhdl/grt/grt-files.adb
--- ghdl-0.27/vhdl/grt/grt-files.adb	2007-12-02 02:57:52.000000000 +0100
+++ ghdl-0.28dev/vhdl/grt/grt-files.adb	2009-09-20 09:06:43.000000000 +0200
@@ -18,8 +18,9 @@
 with Grt.Errors; use Grt.Errors;
 with Grt.Stdio; use Grt.Stdio;
 with Grt.C; use Grt.C;
-with GNAT.Table;
+with Grt.Table;
 with System; use System;
+pragma Elaborate_All (Grt.Table);
 
 package body Grt.Files is
    subtype C_Files is Grt.Stdio.FILEs;
@@ -31,12 +32,11 @@
       Is_Alive : Boolean;
    end record;
 
-   package Files_Table is new GNAT.Table
+   package Files_Table is new Grt.Table
      (Table_Component_Type => File_Entry_Type,
       Table_Index_Type => Ghdl_File_Index,
       Table_Low_Bound => 1,
-      Table_Initial => 2,
-      Table_Increment => 100);
+      Table_Initial => 2);
 
    function Get_File (Index : Ghdl_File_Index) return C_Files
    is
@@ -56,17 +56,13 @@
    end Check_File_Mode;
 
    function Create_File (Is_Text : Boolean; Sig : Ghdl_C_String)
-                        return Ghdl_File_Index
-   is
-      Res : Ghdl_File_Index;
+                        return Ghdl_File_Index is
    begin
-      Files_Table.Increment_Last;
-      Res := Files_Table.Last;
-      Files_Table.Table (Res) := (Stream => NULL_Stream,
-                                  Signature => Sig,
-                                  Is_Text => Is_Text,
-                                  Is_Alive => True);
-      return Res;
+      Files_Table.Append ((Stream => NULL_Stream,
+                           Signature => Sig,
+                           Is_Text => Is_Text,
+                           Is_Alive => True));
+      return Files_Table.Last;
    end Create_File;
 
    procedure Destroy_File (Is_Text : Boolean; Index : Ghdl_File_Index) is
@@ -289,6 +285,7 @@
       Res : C_Files;
       R : size_t;
       R1 : int;
+      pragma Unreferenced (R, R1);
    begin
       Res := Get_File (File);
       Check_File_Mode (File, True);
@@ -311,6 +308,7 @@
       Res : C_Files;
       R : size_t;
       R1 : int;
+      pragma Unreferenced (R1);
    begin
       Res := Get_File (File);
       Check_File_Mode (File, False);
diff -urN ghdl-0.27/vhdl/grt/grt-files.ads ghdl-0.28dev/vhdl/grt/grt-files.ads
--- ghdl-0.27/vhdl/grt/grt-files.ads	2005-09-23 00:26:54.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-files.ads	2009-09-20 09:06:43.000000000 +0200
@@ -83,7 +83,7 @@
    procedure Ghdl_Text_File_Close (File : Ghdl_File_Index);
    procedure Ghdl_File_Close (File : Ghdl_File_Index);
 private
-   pragma Export (C, Ghdl_File_Endfile, "__ghdl_file_endfile");
+   pragma Export (Ada, Ghdl_File_Endfile, "__ghdl_file_endfile");
 
    pragma Export (C, Ghdl_Text_File_Elaborate, "__ghdl_text_file_elaborate");
    pragma Export (C, Ghdl_File_Elaborate, "__ghdl_file_elaborate");
diff -urN ghdl-0.27/vhdl/grt/grt-images.adb ghdl-0.28dev/vhdl/grt/grt-images.adb
--- ghdl-0.27/vhdl/grt/grt-images.adb	2006-05-29 21:37:45.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-images.adb	2009-09-20 09:06:43.000000000 +0200
@@ -17,6 +17,7 @@
 --  02111-1307, USA.
 with System; use System;
 with System.Storage_Elements; --  Work around GNAT bug.
+pragma Unreferenced (System.Storage_Elements);
 with Ada.Unchecked_Conversion;
 with Grt.Processes; use Grt.Processes;
 with Grt.Vstrings; use Grt.Vstrings;
@@ -98,7 +99,7 @@
       Unit := To_Ghdl_Rtin_Unit_Acc (Phys.Units (0)).Name;
       Unit_Len := strlen (Unit);
       declare
-         L : Natural := Str'Last + 1 - First;
+         L : constant Natural := Str'Last + 1 - First;
          Str2 : String (1 .. L + 1 + Unit_Len);
       begin
          Str2 (1 .. L) := Str (First .. Str'Last);
@@ -122,7 +123,7 @@
       Unit := To_Ghdl_Rtin_Unit_Acc (Phys.Units (0)).Name;
       Unit_Len := strlen (Unit);
       declare
-         L : Natural := Str'Last + 1 - First;
+         L : constant Natural := Str'Last + 1 - First;
          Str2 : String (1 .. L + 1 + Unit_Len);
       begin
          Str2 (1 .. L) := Str (First .. Str'Last);
diff -urN ghdl-0.27/vhdl/grt/grt-images.ads ghdl-0.28dev/vhdl/grt/grt-images.ads
--- ghdl-0.27/vhdl/grt/grt-images.ads	2006-05-29 21:38:17.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-images.ads	2009-09-20 09:06:43.000000000 +0200
@@ -32,7 +32,7 @@
    procedure Ghdl_Image_P32
      (Res : Std_String_Ptr; Val : Ghdl_I32; Rti : Ghdl_Rti_Access);
 private
-   pragma Export (C, Ghdl_Image_B2, "__ghdl_image_b2");
+   pragma Export (Ada, Ghdl_Image_B2, "__ghdl_image_b2");
    pragma Export (C, Ghdl_Image_E8, "__ghdl_image_e8");
    pragma Export (C, Ghdl_Image_E32, "__ghdl_image_e32");
    pragma Export (C, Ghdl_Image_I32, "__ghdl_image_i32");
diff -urN ghdl-0.27/vhdl/grt/grt-lib.adb ghdl-0.28dev/vhdl/grt/grt-lib.adb
--- ghdl-0.27/vhdl/grt/grt-lib.adb	2008-06-27 02:26:06.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-lib.adb	2009-09-20 09:06:43.000000000 +0200
@@ -41,7 +41,7 @@
                         Unit : Ghdl_Rti_Access)
    is
       use Grt.Options;
-      Level : Integer := Severity mod 256;
+      Level : constant Integer := Severity mod 256;
    begin
       --  Assertions from ieee library can be disabled.
       if Unit /= null
@@ -51,9 +51,11 @@
                           and Current_Time = 0))
       then
          declare
-            Blk : Ghdl_Rtin_Block_Acc := To_Ghdl_Rtin_Block_Acc (Unit);
-            Pkg : Ghdl_Rtin_Block_Acc := To_Ghdl_Rtin_Block_Acc (Blk.Parent);
-            Lib : Ghdl_Rtin_Type_Scalar_Acc :=
+            Blk : constant Ghdl_Rtin_Block_Acc :=
+              To_Ghdl_Rtin_Block_Acc (Unit);
+            Pkg : constant Ghdl_Rtin_Block_Acc :=
+              To_Ghdl_Rtin_Block_Acc (Blk.Parent);
+            Lib : constant Ghdl_Rtin_Type_Scalar_Acc :=
               To_Ghdl_Rtin_Type_Scalar_Acc (Pkg.Parent);
          begin
             --  Return now if this assert comes from the ieee library.
diff -urN ghdl-0.27/vhdl/grt/grt-main.adb ghdl-0.28dev/vhdl/grt/grt-main.adb
--- ghdl-0.27/vhdl/grt/grt-main.adb	2005-12-12 03:47:44.000000000 +0100
+++ ghdl-0.28dev/vhdl/grt/grt-main.adb	2009-09-20 09:06:43.000000000 +0200
@@ -16,6 +16,7 @@
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with System.Storage_Elements; --  Work around GNAT bug.
+pragma Unreferenced (System.Storage_Elements);
 with Grt.Types; use Grt.Types;
 with Grt.Errors;
 with Grt.Stacks;
@@ -60,6 +61,9 @@
    is
       Err : Boolean;
    begin
+      --  The conditions may be statically known.
+      pragma Warnings (Off);
+
       Err := False;
       if (Std_Integer'Size = 32 and Flag_String (3) /= 'i')
         or else (Std_Integer'Size = 64 and Flag_String (3) /= 'I')
@@ -71,6 +75,9 @@
       then
          Err := True;
       end if;
+
+      pragma Warnings (On);
+
       if Err then
          Grt.Errors.Error
            ("GRT is not consistent with the flags used for your design");
diff -urN ghdl-0.27/vhdl/grt/grt-modules.adb ghdl-0.28dev/vhdl/grt/grt-modules.adb
--- ghdl-0.27/vhdl/grt/grt-modules.adb	2005-12-12 03:47:22.000000000 +0100
+++ ghdl-0.28dev/vhdl/grt/grt-modules.adb	2009-09-20 09:06:43.000000000 +0200
@@ -16,6 +16,7 @@
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with System.Storage_Elements; --  Work around GNAT bug.
+pragma Unreferenced (System.Storage_Elements);
 with Grt.Vcd;
 with Grt.Vcdz;
 with Grt.Vpi;
diff -urN ghdl-0.27/vhdl/grt/grt-names.adb ghdl-0.28dev/vhdl/grt/grt-names.adb
--- ghdl-0.27/vhdl/grt/grt-names.adb	2005-10-08 14:03:33.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-names.adb	2009-09-20 09:06:43.000000000 +0200
@@ -18,6 +18,7 @@
 --with Grt.Errors; use Grt.Errors;
 with Ada.Unchecked_Conversion;
 with System.Storage_Elements; --  Work around GNAT bug.
+pragma Unreferenced (System.Storage_Elements);
 with Grt.Processes; use Grt.Processes;
 with Grt.Rtis_Addr; use Grt.Rtis_Addr;
 with Grt.Rtis_Utils; use Grt.Rtis_Utils;
diff -urN ghdl-0.27/vhdl/grt/grt-options.adb ghdl-0.28dev/vhdl/grt/grt-options.adb
--- ghdl-0.27/vhdl/grt/grt-options.adb	2008-06-27 02:26:06.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-options.adb	2009-09-20 09:06:43.000000000 +0200
@@ -253,7 +253,7 @@
          Arg := Argv (I);
          Len := strlen (Arg);
          declare
-            Argument : String := Arg (1 .. Len);
+            Argument : constant String := Arg (1 .. Len);
          begin
             if Argument = "--" then
                Last_Opt := I;
diff -urN ghdl-0.27/vhdl/grt/grt-options.ads ghdl-0.28dev/vhdl/grt/grt-options.ads
--- ghdl-0.27/vhdl/grt/grt-options.ads	2008-06-27 02:26:06.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-options.ads	2009-09-20 09:06:43.000000000 +0200
@@ -41,7 +41,7 @@
 
    --  Consistent flags used for analysis.
    --  Format is "VVitr", where:
-   --    'VV' is the version (87 or 93).
+   --    'VV' is the version (87, 93 or 08).
    --    'i' is the integer size ('i' for 32 bits, 'I' for 64 bits).
    --    't' is the time size ('t' for 32 bits, 'T' for 64 bits).
    --    'r' is the resolution ('?' for to be set by the user, '-' for any).
diff -urN ghdl-0.27/vhdl/grt/grt-processes.adb ghdl-0.28dev/vhdl/grt/grt-processes.adb
--- ghdl-0.27/vhdl/grt/grt-processes.adb	2008-06-28 16:59:12.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-processes.adb	2009-09-20 09:06:43.000000000 +0200
@@ -15,14 +15,13 @@
 --  along with GCC; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
-with GNAT.Table;
+with Grt.Table;
 with Ada.Unchecked_Conversion;
 with Ada.Unchecked_Deallocation;
 with System.Storage_Elements; --  Work around GNAT bug.
-with Grt.Stack2; use Grt.Stack2;
+pragma Unreferenced (System.Storage_Elements);
 with Grt.Disp;
 with Grt.Astdio;
-with Grt.Signals; use Grt.Signals;
 with Grt.Errors; use Grt.Errors;
 with Grt.Stacks; use Grt.Stacks;
 with Grt.Options;
@@ -30,28 +29,26 @@
 with Grt.Rtis_Utils;
 with Grt.Hooks;
 with Grt.Disp_Signals;
-with Grt.Stdio;
 with Grt.Stats;
 with Grt.Threads; use Grt.Threads;
+pragma Elaborate_All (Grt.Table);
 
 package body Grt.Processes is
    Last_Time : constant Std_Time := Std_Time'Last;
 
    --  Table of processes.
-   package Process_Table is new GNAT.Table
+   package Process_Table is new Grt.Table
      (Table_Component_Type => Process_Type,
       Table_Index_Type => Process_Id,
       Table_Low_Bound => 1,
-      Table_Initial => 16,
-      Table_Increment => 100);
+      Table_Initial => 16);
 
    --  List of non_sensitized processes.
-   package Non_Sensitized_Process_Table is new GNAT.Table
+   package Non_Sensitized_Process_Table is new Grt.Table
      (Table_Component_Type => Process_Id,
       Table_Index_Type => Natural,
       Table_Low_Bound => 1,
-      Table_Initial => 2,
-      Table_Increment => 100);
+      Table_Initial => 2);
 
    --  List of processes to be resume at next cycle.
    type Process_Id_Array is array (Natural range <>) of Process_Id;
@@ -74,7 +71,7 @@
 
    procedure Init is
    begin
-      Process_Table.Init;
+      null;
    end Init;
 
    function Get_Nbr_Processes return Natural is
@@ -380,7 +377,7 @@
 
    procedure Ghdl_Protected_Enter (Obj : System.Address)
    is
-      Lock : Object_Lock_Acc := To_Lock_Acc_Acc (Obj).all;
+      Lock : constant Object_Lock_Acc := To_Lock_Acc_Acc (Obj).all;
    begin
       if Lock.Process = Nul_Process_Id then
          if Lock.Count /= 0 then
@@ -398,13 +395,13 @@
 
    procedure Ghdl_Protected_Leave (Obj : System.Address)
    is
-      Lock : Object_Lock_Acc := To_Lock_Acc_Acc (Obj).all;
+      Lock : constant Object_Lock_Acc := To_Lock_Acc_Acc (Obj).all;
    begin
       if Lock.Process /= Get_Current_Process_Id then
          Internal_Error ("protected_leave(1)");
       end if;
 
-      if Lock.Count <= 0 then
+      if Lock.Count = 0 then
          Internal_Error ("protected_leave(2)");
       end if;
       Lock.Count := Lock.Count - 1;
@@ -415,7 +412,7 @@
 
    procedure Ghdl_Protected_Init (Obj : System.Address)
    is
-      Lock : Object_Lock_Acc_Acc := To_Lock_Acc_Acc (Obj);
+      Lock : constant Object_Lock_Acc_Acc := To_Lock_Acc_Acc (Obj);
    begin
       Lock.all := new Object_Lock'(Process => Nul_Process_Id,
                                    Count => 0);
@@ -426,7 +423,7 @@
       procedure Deallocate is new Ada.Unchecked_Deallocation
         (Object => Object_Lock, Name => Object_Lock_Acc);
 
-      Lock : Object_Lock_Acc_Acc := To_Lock_Acc_Acc (Obj);
+      Lock : constant Object_Lock_Acc_Acc := To_Lock_Acc_Acc (Obj);
    begin
       if Lock.all.Count /= 0 or Lock.all.Process /= Nul_Process_Id then
          Internal_Error ("protected_fini");
@@ -455,7 +452,8 @@
         Non_Sensitized_Process_Table.Last
       loop
          declare
-            Pid : Process_Id := Non_Sensitized_Process_Table.Table (I);
+            Pid : constant Process_Id :=
+              Non_Sensitized_Process_Table.Table (I);
             Proc : Process_Type renames Process_Table.Table (Pid);
          begin
             if Proc.State = State_Wait
@@ -488,7 +486,7 @@
    --  pragma Convention (C, Run_Handler);
 
    function Run_Through_Longjump (Hand : Run_Handler) return Integer;
-   pragma Import (C, Run_Through_Longjump, "__ghdl_run_through_longjump");
+   pragma Import (Ada, Run_Through_Longjump, "__ghdl_run_through_longjump");
 
    --  Run resumed processes.
    --  If POSTPONED is true, resume postponed processes, else resume
@@ -703,7 +701,8 @@
         Non_Sensitized_Process_Table.Last
       loop
          declare
-            Pid : Process_Id := Non_Sensitized_Process_Table.Table (I);
+            Pid : constant Process_Id :=
+              Non_Sensitized_Process_Table.Table (I);
             Proc : Process_Type renames Process_Table.Table (Pid);
             El : Sensitivity_Acc;
          begin
diff -urN ghdl-0.27/vhdl/grt/grt-processes.ads ghdl-0.28dev/vhdl/grt/grt-processes.ads
--- ghdl-0.27/vhdl/grt/grt-processes.ads	2005-12-07 06:46:16.000000000 +0100
+++ ghdl-0.28dev/vhdl/grt/grt-processes.ads	2009-09-20 09:06:43.000000000 +0200
@@ -205,7 +205,7 @@
                   "__ghdl_process_wait_add_sensitivity");
    pragma Export (C, Ghdl_Process_Wait_Set_Timeout,
                   "__ghdl_process_wait_set_timeout");
-   pragma Export (C, Ghdl_Process_Wait_Suspend,
+   pragma Export (Ada, Ghdl_Process_Wait_Suspend,
                   "__ghdl_process_wait_suspend");
    pragma Export (C, Ghdl_Process_Wait_Close,
                   "__ghdl_process_wait_close");
diff -urN ghdl-0.27/vhdl/grt/grt-rtis_addr.adb ghdl-0.28dev/vhdl/grt/grt-rtis_addr.adb
--- ghdl-0.27/vhdl/grt/grt-rtis_addr.adb	2006-07-29 21:49:26.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-rtis_addr.adb	2009-09-20 09:06:43.000000000 +0200
@@ -15,7 +15,6 @@
 --  along with GCC; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
-with Ada.Unchecked_Conversion;
 with Grt.Errors; use Grt.Errors;
 
 package body Grt.Rtis_Addr is
diff -urN ghdl-0.27/vhdl/grt/grt-rtis_utils.adb ghdl-0.28dev/vhdl/grt/grt-rtis_utils.adb
--- ghdl-0.27/vhdl/grt/grt-rtis_utils.adb	2006-05-29 21:36:38.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-rtis_utils.adb	2009-09-20 09:06:43.000000000 +0200
@@ -15,9 +15,6 @@
 --  along with GCC; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
-with System; use System;
-with Grt.Rtis; use Grt.Rtis;
-with Grt.Types; use Grt.Types;
 --with Grt.Disp; use Grt.Disp;
 with Grt.Errors; use Grt.Errors;
 
@@ -318,7 +315,7 @@
       procedure Handle_Array (Rti : Ghdl_Rtin_Type_Array_Acc;
                               Vals : Ghdl_Uc_Array_Acc)
       is
-         Nbr_Dim : Ghdl_Index_Type := Rti.Nbr_Dim;
+         Nbr_Dim : constant Ghdl_Index_Type := Rti.Nbr_Dim;
          Rngs : Ghdl_Range_Array (0 .. Nbr_Dim - 1);
       begin
          Bound_To_Range (Vals.Bounds, Rti, Rngs);
@@ -367,9 +364,9 @@
                              To_Ghdl_Uc_Array_Acc (Addr));
             when Ghdl_Rtik_Subtype_Array =>
                declare
-                  St : Ghdl_Rtin_Subtype_Array_Acc :=
+                  St : constant Ghdl_Rtin_Subtype_Array_Acc :=
                     To_Ghdl_Rtin_Subtype_Array_Acc (Rti);
-                  Bt : Ghdl_Rtin_Type_Array_Acc := St.Basetype;
+                  Bt : constant Ghdl_Rtin_Type_Array_Acc := St.Basetype;
                   Rngs : Ghdl_Range_Array (0 .. Bt.Nbr_Dim - 1);
                begin
                   Bound_To_Range
@@ -385,9 +382,9 @@
                end;
             when Ghdl_Rtik_Subtype_Array_Ptr =>
                declare
-                  St : Ghdl_Rtin_Subtype_Array_Acc :=
+                  St : constant Ghdl_Rtin_Subtype_Array_Acc :=
                     To_Ghdl_Rtin_Subtype_Array_Acc (Rti);
-                  Bt : Ghdl_Rtin_Type_Array_Acc := St.Basetype;
+                  Bt : constant Ghdl_Rtin_Type_Array_Acc := St.Basetype;
                   Rngs : Ghdl_Range_Array (0 .. Bt.Nbr_Dim - 1);
                begin
                   Bound_To_Range
@@ -521,7 +518,7 @@
                         Addr : Address;
                         Type_Rti : Ghdl_Rti_Access)
    is
-      Value : Ghdl_Value_Ptr := To_Ghdl_Value_Ptr (Addr);
+      Value : constant Ghdl_Value_Ptr := To_Ghdl_Value_Ptr (Addr);
    begin
       case Type_Rti.Kind is
          when Ghdl_Rtik_Type_I32 =>
@@ -569,6 +566,12 @@
                   Link := To_Ghdl_Entity_Link_Acc (Ctxt.Base);
                   Ctxt := (Base => Ctxt.Base,
                            Block => Link.Rti);
+                  if Ctxt.Block = null then
+                     --  Process in an entity.
+                     --  FIXME: check.
+                     Prepend (Rstr, Blk.Name);
+                     return;
+                  end if;
                end;
             when Ghdl_Rtik_Architecture =>
                declare
diff -urN ghdl-0.27/vhdl/grt/grt-sdf.adb ghdl-0.28dev/vhdl/grt/grt-sdf.adb
--- ghdl-0.27/vhdl/grt/grt-sdf.adb	2008-05-01 07:44:46.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-sdf.adb	2009-09-20 09:06:43.000000000 +0200
@@ -16,7 +16,7 @@
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with System.Storage_Elements; --  Work around GNAT bug.
-with Grt.Types; use Grt.Types;
+pragma Unreferenced (System.Storage_Elements);
 with Grt.Stdio; use Grt.Stdio;
 with Grt.C; use Grt.C;
 with Grt.Errors; use Grt.Errors;
diff -urN ghdl-0.27/vhdl/grt/grt-signals.adb ghdl-0.28dev/vhdl/grt/grt-signals.adb
--- ghdl-0.27/vhdl/grt/grt-signals.adb	2008-05-13 03:06:31.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-signals.adb	2009-09-20 09:06:43.000000000 +0200
@@ -17,8 +17,8 @@
 --  02111-1307, USA.
 with System; use System;
 with System.Storage_Elements; --  Work around GNAT bug.
+pragma Unreferenced (System.Storage_Elements);
 with Ada.Unchecked_Deallocation;
-with Ada.Unchecked_Conversion;
 with Grt.Errors; use Grt.Errors;
 with Grt.Processes; use Grt.Processes;
 with Grt.Options; use Grt.Options;
@@ -1750,7 +1750,8 @@
 
    procedure Compute_Resolved_Signal (Resolv : Resolved_Signal_Acc)
    is
-      Sig : Ghdl_Signal_Ptr := Sig_Table.Table (Resolv.Sig_Range.First);
+      Sig : constant Ghdl_Signal_Ptr :=
+        Sig_Table.Table (Resolv.Sig_Range.First);
       Length : Ghdl_Index_Type;
       type Bool_Array_Type is array (1 .. Sig.S.Nbr_Drivers) of Boolean;
       Vec : Bool_Array_Type;
@@ -2135,7 +2136,7 @@
 
             declare
                S : Ghdl_Signal_Ptr;
-               Old : Signal_Net_Type := Sig.Net;
+               Old : constant Signal_Net_Type := Sig.Net;
             begin
                --  Merge the old net into NET.
                S := Sig;
@@ -3051,8 +3052,8 @@
                Mark_Active (Sig);
 
                Trans := Sig.S.Drivers (0).Last_Trans;
-               Sig.Driving_Value := Trans.Val_Ptr.all;
-               Sig.S.Drivers (0).First_Trans.Val := Trans.Val_Ptr.all;
+               Direct_Assign (Sig.Driving_Value, Trans.Val_Ptr, Sig.Mode);
+               Sig.S.Drivers (0).First_Trans.Val := Sig.Driving_Value;
                Set_Effective_Value (Sig, Sig.Driving_Value);
 
             when Net_One_Resolved =>
diff -urN ghdl-0.27/vhdl/grt/grt-signals.ads ghdl-0.28dev/vhdl/grt/grt-signals.ads
--- ghdl-0.27/vhdl/grt/grt-signals.ads	2006-09-07 06:11:32.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-signals.ads	2009-09-20 09:06:43.000000000 +0200
@@ -17,9 +17,10 @@
 --  02111-1307, USA.
 with System;
 with Ada.Unchecked_Conversion;
-with GNAT.Table;
+with Grt.Table;
 with Grt.Types; use Grt.Types;
 with Grt.Rtis; use Grt.Rtis;
+pragma Elaborate_All (Grt.Table);
 
 package Grt.Signals is
    pragma Suppress (All_Checks);
@@ -264,12 +265,11 @@
    end record;
 
    --  Each simple signal declared can be accessed by SIG_TABLE.
-   package Sig_Table is new GNAT.Table
+   package Sig_Table is new Grt.Table
      (Table_Component_Type => Ghdl_Signal_Ptr,
       Table_Index_Type => Sig_Table_Index,
       Table_Low_Bound => 0,
-      Table_Initial => 128,
-      Table_Increment => 100);
+      Table_Initial => 128);
 
    --  Return the next time at which a driver becomes active.
    function Find_Next_Time return Std_Time;
@@ -380,12 +380,11 @@
       end case;
    end record;
 
-   package Propagation is new GNAT.Table
+   package Propagation is new Grt.Table
      (Table_Component_Type => Propagation_Type,
       Table_Index_Type => Signal_Net_Type,
       Table_Low_Bound => 1,
-      Table_Initial => 128,
-      Table_Increment => 100);
+      Table_Initial => 128);
 
    --  Get the signal index of PTR.
    function Signal_Ptr_To_Index (Ptr : Ghdl_Signal_Ptr) return Sig_Table_Index;
@@ -660,22 +659,22 @@
    pragma Export (C, Ghdl_Signal_Disconnect,
                   "__ghdl_signal_disconnect");
 
-   pragma Export (C, Ghdl_Signal_Driving,
+   pragma Export (Ada, Ghdl_Signal_Driving,
                   "__ghdl_signal_driving");
 
-   pragma Export (C, Ghdl_Create_Signal_B2,
+   pragma Export (Ada, Ghdl_Create_Signal_B2,
                   "__ghdl_create_signal_b2");
-   pragma Export (C, Ghdl_Signal_Init_B2,
+   pragma Export (Ada, Ghdl_Signal_Init_B2,
                   "__ghdl_signal_init_b2");
-   pragma Export (C, Ghdl_Signal_Associate_B2,
+   pragma Export (Ada, Ghdl_Signal_Associate_B2,
                   "__ghdl_signal_associate_b2");
-   pragma Export (C, Ghdl_Signal_Simple_Assign_B2,
+   pragma Export (Ada, Ghdl_Signal_Simple_Assign_B2,
                   "__ghdl_signal_simple_assign_b2");
-   pragma Export (C, Ghdl_Signal_Start_Assign_B2,
+   pragma Export (Ada, Ghdl_Signal_Start_Assign_B2,
                   "__ghdl_signal_start_assign_b2");
-   pragma Export (C, Ghdl_Signal_Next_Assign_B2,
+   pragma Export (Ada, Ghdl_Signal_Next_Assign_B2,
                   "__ghdl_signal_next_assign_b2");
-   pragma Export (C, Ghdl_Signal_Driving_Value_B2,
+   pragma Export (Ada, Ghdl_Signal_Driving_Value_B2,
                   "__ghdl_signal_driving_value_b2");
 
    pragma Export (C, Ghdl_Create_Signal_E8,
@@ -781,7 +780,7 @@
    pragma Export (C, Ghdl_Create_Delayed_Signal,
                   "__ghdl_create_delayed_signal");
 
-   pragma Export (C, Ghdl_Signal_Create_Guard,
+   pragma Export (Ada, Ghdl_Signal_Create_Guard,
                   "__ghdl_signal_create_guard");
    pragma Export (C, Ghdl_Signal_Guard_Dependence,
                   "__ghdl_signal_guard_dependence");
diff -urN ghdl-0.27/vhdl/grt/grt-stats.adb ghdl-0.28dev/vhdl/grt/grt-stats.adb
--- ghdl-0.27/vhdl/grt/grt-stats.adb	2006-09-04 06:50:27.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-stats.adb	2009-09-20 09:06:43.000000000 +0200
@@ -17,6 +17,7 @@
 --  02111-1307, USA.
 with System; use System;
 with System.Storage_Elements; --  Work around GNAT bug.
+pragma Unreferenced (System.Storage_Elements);
 with Grt.Stdio; use Grt.Stdio;
 with Grt.Astdio; use Grt.Astdio;
 with Grt.Signals;
diff -urN ghdl-0.27/vhdl/grt/grt-table.adb ghdl-0.28dev/vhdl/grt/grt-table.adb
--- ghdl-0.27/vhdl/grt/grt-table.adb	1970-01-01 01:00:00.000000000 +0100
+++ ghdl-0.28dev/vhdl/grt/grt-table.adb	2009-09-20 09:06:43.000000000 +0200
@@ -0,0 +1,113 @@
+--  GHDL Run Time (GRT) - Resizable array
+--  Copyright (C) 2008 Tristan Gingold
+--
+--  GHDL is free software; you can redistribute it and/or modify it under
+--  the terms of the GNU General Public License as published by the Free
+--  Software Foundation; either version 2, or (at your option) any later
+--  version.
+--
+--  GHDL is distributed in the hope that it will be useful, but WITHOUT ANY
+--  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+--  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+--  for more details.
+--
+--  You should have received a copy of the GNU General Public License
+--  along with GCC; see the file COPYING.  If not, write to the Free
+--  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+--  02111-1307, USA.
+
+with System; use System;
+with Grt.C; use Grt.C;
+
+package body Grt.Table is
+
+   --  Maximum index of table before resizing.
+   Max : Table_Index_Type := Table_Low_Bound - 1;
+
+   --  Current value of Last
+   Last_Val : Table_Index_Type;
+
+   function Malloc (Size : size_t) return Table_Ptr;
+   pragma Import (C, Malloc);
+
+   procedure Free (T : Table_Ptr);
+   pragma Import (C, Free);
+
+   --  Resize and reallocate the table according to LAST_VAL.
+   procedure Resize is
+      function Realloc (T : Table_Ptr; Size : size_t) return Table_Ptr;
+      pragma Import (C, Realloc);
+
+      New_Size : size_t;
+   begin
+      while Max < Last_Val loop
+         Max := Max + (Max - Table_Low_Bound + 1);
+      end loop;
+
+      New_Size := size_t ((Max - Table_Low_Bound + 1) *
+                            (Table_Type'Component_Size / Storage_Unit));
+
+      Table := Realloc (Table, New_Size);
+
+      if Table = null then
+         raise Storage_Error;
+      end if;
+   end Resize;
+
+   procedure Append (New_Val : Table_Component_Type) is
+   begin
+      Increment_Last;
+      Table (Last_Val) := New_Val;
+   end Append;
+
+   procedure Decrement_Last is
+   begin
+      Last_Val := Last_Val - 1;
+   end Decrement_Last;
+
+   procedure Free is
+   begin
+      Free (Table);
+      Table := null;
+   end Free;
+
+   procedure Increment_Last is
+   begin
+      Last_Val := Last_Val + 1;
+
+      if Last_Val > Max then
+         Resize;
+      end if;
+   end Increment_Last;
+
+   function Last return Table_Index_Type is
+   begin
+      return Last_Val;
+   end Last;
+
+   procedure Release is
+   begin
+      Max := Last_Val;
+      Resize;
+   end Release;
+
+   procedure Set_Last (New_Val : Table_Index_Type) is
+   begin
+      if New_Val < Last_Val then
+         Last_Val := New_Val;
+      else
+         Last_Val := New_Val;
+
+         if Last_Val > Max then
+            Resize;
+         end if;
+      end if;
+   end Set_Last;
+
+begin
+   Last_Val := Table_Low_Bound - 1;
+   Max := Table_Low_Bound + Table_Index_Type (Table_Initial) - 1;
+
+   Table := Malloc (size_t (Table_Initial *
+                              (Table_Type'Component_Size / Storage_Unit)));
+end Grt.Table;
diff -urN ghdl-0.27/vhdl/grt/grt-table.ads ghdl-0.28dev/vhdl/grt/grt-table.ads
--- ghdl-0.27/vhdl/grt/grt-table.ads	1970-01-01 01:00:00.000000000 +0100
+++ ghdl-0.28dev/vhdl/grt/grt-table.ads	2009-09-20 09:06:43.000000000 +0200
@@ -0,0 +1,68 @@
+--  GHDL Run Time (GRT) - Resizable array
+--  Copyright (C) 2008 Tristan Gingold
+--
+--  GHDL is free software; you can redistribute it and/or modify it under
+--  the terms of the GNU General Public License as published by the Free
+--  Software Foundation; either version 2, or (at your option) any later
+--  version.
+--
+--  GHDL is distributed in the hope that it will be useful, but WITHOUT ANY
+--  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+--  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+--  for more details.
+--
+--  You should have received a copy of the GNU General Public License
+--  along with GCC; see the file COPYING.  If not, write to the Free
+--  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+--  02111-1307, USA.
+
+generic
+   type Table_Component_Type is private;
+   type Table_Index_Type     is range <>;
+
+   Table_Low_Bound : Table_Index_Type;
+   Table_Initial   : Positive;
+
+package Grt.Table is
+   pragma Elaborate_Body;
+
+   type Table_Type is
+     array (Table_Index_Type range <>) of Table_Component_Type;
+   subtype Fat_Table_Type is
+     Table_Type (Table_Low_Bound .. Table_Index_Type'Last);
+
+   --  Thin pointer.
+   type Table_Ptr is access all Fat_Table_Type;
+
+   --  The table itself.
+   Table : aliased Table_Ptr := null;
+
+   --  Get the high bound.
+   function Last return Table_Index_Type;
+   pragma Inline (Last);
+
+   --  Get the low bound.
+   First : constant Table_Index_Type := Table_Low_Bound;
+
+   --  Increase the length by 1.
+   procedure Increment_Last;
+   pragma Inline (Increment_Last);
+
+   --  Decrease the length by 1.
+   procedure Decrement_Last;
+   pragma Inline (Decrement_Last);
+
+   --  Set the last bound.
+   procedure Set_Last (New_Val : Table_Index_Type);
+
+   --  Release extra memory.
+   procedure Release;
+
+   --  Free all the memory used by the table.
+   --  The table won't be useable anymore.
+   procedure Free;
+
+   --  Append a new element.
+   procedure Append (New_Val : Table_Component_Type);
+   pragma Inline (Append);
+end Grt.Table;
diff -urN ghdl-0.27/vhdl/grt/grt-unithread.adb ghdl-0.28dev/vhdl/grt/grt-unithread.adb
--- ghdl-0.27/vhdl/grt/grt-unithread.adb	2005-11-05 14:44:25.000000000 +0100
+++ ghdl-0.28dev/vhdl/grt/grt-unithread.adb	2009-09-20 09:06:43.000000000 +0200
@@ -15,7 +15,6 @@
 --  along with GCC; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
-with Grt.Types; use Grt.Types;
 
 package body Grt.Unithread is
    procedure Init is
diff -urN ghdl-0.27/vhdl/grt/grt-unithread.ads ghdl-0.28dev/vhdl/grt/grt-unithread.ads
--- ghdl-0.27/vhdl/grt/grt-unithread.ads	2005-11-11 09:36:57.000000000 +0100
+++ ghdl-0.28dev/vhdl/grt/grt-unithread.ads	2009-09-20 09:06:43.000000000 +0200
@@ -16,6 +16,7 @@
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with System.Storage_Elements; --  Work around GNAT bug.
+pragma Unreferenced (System.Storage_Elements);
 with Grt.Signals; use Grt.Signals;
 with Grt.Stack2; use Grt.Stack2;
 with Grt.Stacks; use Grt.Stacks;
diff -urN ghdl-0.27/vhdl/grt/grt-vcd.adb ghdl-0.28dev/vhdl/grt/grt-vcd.adb
--- ghdl-0.27/vhdl/grt/grt-vcd.adb	2005-11-11 15:41:37.000000000 +0100
+++ ghdl-0.28dev/vhdl/grt/grt-vcd.adb	2009-09-20 09:06:43.000000000 +0200
@@ -17,53 +17,48 @@
 --  02111-1307, USA.
 with Interfaces;
 with Grt.Stdio; use Grt.Stdio;
-with System; use System;
 with System.Storage_Elements; --  Work around GNAT bug.
+pragma Unreferenced (System.Storage_Elements);
 with Grt.Errors; use Grt.Errors;
-with Grt.Types; use Grt.Types;
 with Grt.Signals; use Grt.Signals;
-with GNAT.Table;
+with Grt.Table;
 with Grt.Astdio; use Grt.Astdio;
 with Grt.C; use Grt.C;
 with Grt.Hooks; use Grt.Hooks;
-with Grt.Avhpi; use Grt.Avhpi;
 with Grt.Rtis; use Grt.Rtis;
 with Grt.Rtis_Addr; use Grt.Rtis_Addr;
 with Grt.Rtis_Types; use Grt.Rtis_Types;
 with Grt.Vstrings;
+pragma Elaborate_All (Grt.Table);
 
 package body Grt.Vcd is
    --  If TRUE, put $date in vcd file.
    --  Can be set to FALSE to make vcd comparaison easier.
    Flag_Vcd_Date : Boolean := True;
 
-   type Vcd_IO_Simple is new Vcd_IO_Handler with record
-      Stream : FILEs;
-   end record;
-   type IO_Simple_Acc is access Vcd_IO_Simple;
-   procedure Vcd_Put (Handler : access Vcd_IO_Simple; Str : String);
-   procedure Vcd_Putc (Handler : access Vcd_IO_Simple; C : Character);
-   procedure Vcd_Close (Handler : access Vcd_IO_Simple);
+   Stream : FILEs;
 
-   procedure Vcd_Put (Handler : access Vcd_IO_Simple; Str : String)
+   procedure My_Vcd_Put (Str : String)
    is
       R : size_t;
+      pragma Unreferenced (R);
    begin
-      R := fwrite (Str'Address, Str'Length, 1, Handler.Stream);
-   end Vcd_Put;
+      R := fwrite (Str'Address, Str'Length, 1, Stream);
+   end My_Vcd_Put;
 
-   procedure Vcd_Putc (Handler : access Vcd_IO_Simple; C : Character)
+   procedure My_Vcd_Putc (C : Character)
    is
       R : int;
+      pragma Unreferenced (R);
    begin
-      R := fputc (Character'Pos (C), Handler.Stream);
-   end Vcd_Putc;
+      R := fputc (Character'Pos (C), Stream);
+   end My_Vcd_Putc;
 
-   procedure Vcd_Close (Handler : access Vcd_IO_Simple) is
+   procedure My_Vcd_Close is
    begin
-      fclose (Handler.Stream);
-      Handler.Stream := NULL_Stream;
-   end Vcd_Close;
+      fclose (Stream);
+      Stream := NULL_Stream;
+   end My_Vcd_Close;
 
    --  VCD filename.
    --  Stream corresponding to the VCD filename.
@@ -75,9 +70,8 @@
    --  Return TRUE if OPT is an option for VCD.
    function Vcd_Option (Opt : String) return Boolean
    is
-      F : Natural := Opt'First;
+      F : constant Natural := Opt'First;
       Mode : constant String := "wt" & NUL;
-      Handler : IO_Simple_Acc;
       Vcd_Filename : String_Access;
    begin
       if Opt'Length < 5 or else Opt (F .. F + 4) /= "--vcd" then
@@ -88,7 +82,7 @@
          return True;
       end if;
       if Opt'Length > 6 and then Opt (F + 5) = '=' then
-         if H /= null then
+         if Vcd_Close /= null then
             Error ("--vcd: file already set");
             return True;
          end if;
@@ -98,19 +92,20 @@
          Vcd_Filename (1 .. Opt'Length - 6) := Opt (F + 6 .. Opt'Last);
          Vcd_Filename (Vcd_Filename'Last) := NUL;
 
-         Handler := new Vcd_IO_Simple;
          if Vcd_Filename.all = "-" & NUL then
-            Handler.Stream := stdout;
+            Stream := stdout;
          else
-            Handler.Stream := fopen (Vcd_Filename.all'Address, Mode'Address);
-            if Handler.Stream = NULL_Stream then
+            Stream := fopen (Vcd_Filename.all'Address, Mode'Address);
+            if Stream = NULL_Stream then
                Error_C ("cannot open ");
                Error_E (Vcd_Filename (Vcd_Filename'First
                                       .. Vcd_Filename'Last - 1));
                return True;
             end if;
          end if;
-         H := Handler_Acc (Handler);
+         Vcd_Putc := My_Vcd_Putc'Access;
+         Vcd_Put := My_Vcd_Put'Access;
+         Vcd_Close := My_Vcd_Close'Access;
          return True;
       else
          return False;
@@ -123,24 +118,14 @@
       Put_Line (" --vcd-nodate       do not write date in VCD file");
    end Vcd_Help;
 
-   procedure Vcd_Put (Str : String) is
-   begin
-      Vcd_Put (H, Str);
-   end Vcd_Put;
-
-   procedure Vcd_Putc (C : Character) is
-   begin
-      Vcd_Putc (H, C);
-   end Vcd_Putc;
-
    procedure Vcd_Newline is
    begin
-      Vcd_Putc (H, Nl);
+      Vcd_Putc (Nl);
    end Vcd_Newline;
 
    procedure Vcd_Putline (Str : String) is
    begin
-      Vcd_Put (H, Str);
+      Vcd_Put (Str);
       Vcd_Newline;
    end Vcd_Putline;
 
@@ -200,7 +185,7 @@
    procedure Vcd_Init
    is
    begin
-      if H = null then
+      if Vcd_Close = null then
          return;
       end if;
       if Flag_Vcd_Date then
@@ -236,12 +221,11 @@
       Vcd_Put_End;
    end Vcd_Init;
 
-   package Vcd_Table is new GNAT.Table
+   package Vcd_Table is new Grt.Table
      (Table_Component_Type => Verilog_Wire_Info,
       Table_Index_Type => Vcd_Index_Type,
       Table_Low_Bound => 0,
-      Table_Initial => 32,
-      Table_Increment => 100);
+      Table_Initial => 32);
 
    procedure Avhpi_Error (Err : AvhpiErrorT)
    is
@@ -306,13 +290,10 @@
    procedure Get_Verilog_Wire (Sig : VhpiHandleT; Info : out Verilog_Wire_Info)
    is
       Sig_Type : VhpiHandleT;
-      Sig_Rti : Ghdl_Rtin_Object_Acc;
       Rti : Ghdl_Rti_Access;
       Error : AvhpiErrorT;
       Sig_Addr : Address;
    begin
-      Sig_Rti := To_Ghdl_Rtin_Object_Acc (Avhpi_Get_Rti (Sig));
-
       --  Extract type of the signal.
       Vhpi_Handle (VhpiSubtype, Sig, Sig_Type, Error);
       if Error /= AvhpiErrorOk then
@@ -711,7 +692,7 @@
       Root : VhpiHandleT;
    begin
       --  Do nothing if there is no VCD file to generate.
-      if H = null then
+      if Vcd_Close = null then
          return;
       end if;
 
@@ -752,8 +733,8 @@
    --  Called at the end of the simulation.
    procedure Vcd_End is
    begin
-      if H /= null then
-         Vcd_Close (H);
+      if Vcd_Close /= null then
+         Vcd_Close.all;
       end if;
    end Vcd_End;
 
diff -urN ghdl-0.27/vhdl/grt/grt-vcd.ads ghdl-0.28dev/vhdl/grt/grt-vcd.ads
--- ghdl-0.27/vhdl/grt/grt-vcd.ads	2005-10-06 18:25:54.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-vcd.ads	2009-09-20 09:06:43.000000000 +0200
@@ -21,16 +21,13 @@
 
 package Grt.Vcd is
    --  Abstract type for IO.
-   type Vcd_IO_Handler is abstract tagged null record;
-   procedure Vcd_Put (Handler : access Vcd_IO_Handler; Str : String)
-      is abstract;
-   procedure Vcd_Putc (Handler : access Vcd_IO_Handler; C : Character)
-      is abstract;
-   procedure Vcd_Close (Handler : access Vcd_IO_Handler)
-      is abstract;
-
-   type Handler_Acc is access all Vcd_IO_Handler'Class;
-   H : Handler_Acc := null;
+   type Vcd_Put_Acc is access procedure (Str : String);
+   type Vcd_Putc_Acc is access procedure (C : Character);
+   type Vcd_Close_Acc is access procedure;
+
+   Vcd_Put : Vcd_Put_Acc;
+   Vcd_Putc : Vcd_Putc_Acc;
+   Vcd_Close : Vcd_Close_Acc;
 
    type Vcd_Var_Kind is (Vcd_Bad,
                          Vcd_Bool,
diff -urN ghdl-0.27/vhdl/grt/grt-vcdz.adb ghdl-0.28dev/vhdl/grt/grt-vcdz.adb
--- ghdl-0.27/vhdl/grt/grt-vcdz.adb	2005-10-16 09:53:29.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-vcdz.adb	2009-09-20 09:06:43.000000000 +0200
@@ -16,6 +16,7 @@
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with System.Storage_Elements; --  Work around GNAT bug.
+pragma Unreferenced (System.Storage_Elements);
 with Grt.Vcd; use Grt.Vcd;
 with Grt.Errors; use Grt.Errors;
 with Grt.Types; use Grt.Types;
@@ -25,49 +26,44 @@
 with Grt.C; use Grt.C;
 
 package body Grt.Vcdz is
-   type Vcd_IO_Gzip is new Vcd_IO_Handler with record
-      Stream : gzFile;
-   end record;
-   type IO_Gzip_Acc is access Vcd_IO_Gzip;
-   procedure Vcd_Put (Handler : access Vcd_IO_Gzip; Str : String);
-   procedure Vcd_Putc (Handler : access Vcd_IO_Gzip; C : Character);
-   procedure Vcd_Close (Handler : access Vcd_IO_Gzip);
+   Stream : gzFile;
 
-   procedure Vcd_Put (Handler : access Vcd_IO_Gzip; Str : String)
+   procedure My_Vcd_Put (Str : String)
    is
       R : int;
+      pragma Unreferenced (R);
    begin
-      R := gzwrite (Handler.Stream, Str'Address, Str'Length);
-   end Vcd_Put;
+      R := gzwrite (Stream, Str'Address, Str'Length);
+   end My_Vcd_Put;
 
-   procedure Vcd_Putc (Handler : access Vcd_IO_Gzip; C : Character)
+   procedure My_Vcd_Putc (C : Character)
    is
       R : int;
+      pragma Unreferenced (R);
    begin
-      R := gzputc (Handler.Stream, Character'Pos (C));
-   end Vcd_Putc;
+      R := gzputc (Stream, Character'Pos (C));
+   end My_Vcd_Putc;
 
-   procedure Vcd_Close (Handler : access Vcd_IO_Gzip) is
+   procedure My_Vcd_Close is
    begin
-      gzclose (Handler.Stream);
-      Handler.Stream := NULL_gzFile;
-   end Vcd_Close;
+      gzclose (Stream);
+      Stream := NULL_gzFile;
+   end My_Vcd_Close;
 
    --  VCD filename.
 
    --  Return TRUE if OPT is an option for VCD.
    function Vcdz_Option (Opt : String) return Boolean
    is
-      F : Natural := Opt'First;
+      F : constant Natural := Opt'First;
       Vcd_Filename : String_Access := null;
-      Handler : IO_Gzip_Acc;
       Mode : constant String := "wb" & NUL;
    begin
       if Opt'Length < 7 or else Opt (F .. F + 6) /= "--vcdgz" then
          return False;
       end if;
       if Opt'Length > 7 and then Opt (F + 7) = '=' then
-         if H /= null then
+         if Vcd_Close /= null then
             Error ("--vcdgz: file already set");
             return True;
          end if;
@@ -77,15 +73,16 @@
          Vcd_Filename (1 .. Opt'Length - 8) := Opt (F + 8 .. Opt'Last);
          Vcd_Filename (Vcd_Filename'Last) := NUL;
 
-         Handler := new Vcd_IO_Gzip;
-         Handler.Stream := gzopen (Vcd_Filename.all'Address, Mode'Address);
-         if Handler.Stream = NULL_gzFile then
+         Stream := gzopen (Vcd_Filename.all'Address, Mode'Address);
+         if Stream = NULL_gzFile then
             Error_C ("cannot open ");
             Error_E (Vcd_Filename (Vcd_Filename'First
                                    .. Vcd_Filename'Last - 1));
             return True;
          end if;
-         H := Handler_Acc (Handler);
+         Vcd_Putc := My_Vcd_Putc'Access;
+         Vcd_Put := My_Vcd_Put'Access;
+         Vcd_Close := My_Vcd_Close'Access;
          return True;
       else
          return False;
diff -urN ghdl-0.27/vhdl/grt/grt-vital_annotate.adb ghdl-0.28dev/vhdl/grt/grt-vital_annotate.adb
--- ghdl-0.27/vhdl/grt/grt-vital_annotate.adb	2008-05-25 07:59:04.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-vital_annotate.adb	2009-09-20 09:06:43.000000000 +0200
@@ -15,7 +15,6 @@
 --  along with GCC; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
-with Grt.Sdf;
 with Grt.Types; use Grt.Types;
 with Grt.Hooks; use Grt.Hooks;
 with Grt.Astdio; use Grt.Astdio;
@@ -32,7 +31,7 @@
    Sdf_Inst : VhpiHandleT;
 
    Flag_Dump : Boolean := False;
-   Flag_Verbose : Boolean := False;
+   Flag_Verbose : constant Boolean := False;
 
    function Name_Compare (Handle : VhpiHandleT;
                           Name : String;
@@ -140,7 +139,7 @@
 
    end Find_Generic;
 
-   procedure Sdf_Header (Context : in out Sdf_Context_Type)
+   procedure Sdf_Header (Context : Sdf_Context_Type)
    is
    begin
       if Flag_Dump then
@@ -156,7 +155,7 @@
       end if;
    end Sdf_Header;
 
-   procedure Sdf_Celltype (Context : in out Sdf_Context_Type)
+   procedure Sdf_Celltype (Context : Sdf_Context_Type)
    is
    begin
       if Flag_Dump then
@@ -185,7 +184,7 @@
       Find_Instance (Sdf_Inst, Sdf_Inst, Instance, Status);
    end Sdf_Instance;
 
-   procedure Sdf_Instance_End (Context : in out Sdf_Context_Type;
+   procedure Sdf_Instance_End (Context : Sdf_Context_Type;
                                Status : out Boolean)
    is
    begin
@@ -319,6 +318,9 @@
       Right : VhpiIntT;
    begin
       Vhpi_Handle (VhpiSubtype, Port, Port_Type, Error);
+      Left := 0;
+      Len := 0;
+      Up := True;
       if Error /= AvhpiErrorOk then
          Internal_Error ("vhpiSubtype - port");
          return;
@@ -434,10 +436,10 @@
             then
                Generic_Get_Bounds (Port2, Left2, Len2, Up2);
                Pos := Pos * Len2;
-               if Up1 then
+               if Up2 then
                   Pos := Pos + Ghdl_Index_Type (Context.Ports (2).L - Left2);
                else
-                  Pos := Pos + Ghdl_Index_Type (Left1 - Context.Ports (2).L);
+                  Pos := Pos + Ghdl_Index_Type (Left2 - Context.Ports (2).L);
                end if;
             end if;
             Vhpi_Handle_By_Index
@@ -608,8 +610,9 @@
       end loop;
    end Sdf_Start;
 
-   function Sdf_Option (Opt : String) return Boolean
+   function Sdf_Option (Option : String) return Boolean
    is
+      Opt : constant String (1 .. Option'Length) := Option;
    begin
       if Opt'Length > 11 and then Opt (1 .. 11) = "--sdf-dump=" then
          Flag_Dump := True;
diff -urN ghdl-0.27/vhdl/grt/grt-vital_annotate.ads ghdl-0.28dev/vhdl/grt/grt-vital_annotate.ads
--- ghdl-0.27/vhdl/grt/grt-vital_annotate.ads	2005-09-23 00:18:59.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-vital_annotate.ads	2009-09-20 09:06:43.000000000 +0200
@@ -20,12 +20,12 @@
 package Grt.Vital_Annotate is
    pragma Elaborate_Body (Grt.Vital_Annotate);
 
-   procedure Sdf_Header (Context : in out Sdf_Context_Type);
-   procedure Sdf_Celltype (Context : in out Sdf_Context_Type);
+   procedure Sdf_Header (Context : Sdf_Context_Type);
+   procedure Sdf_Celltype (Context : Sdf_Context_Type);
    procedure Sdf_Instance (Context : in out Sdf_Context_Type;
                            Instance : String;
                            Status : out Boolean);
-   procedure Sdf_Instance_End (Context : in out Sdf_Context_Type;
+   procedure Sdf_Instance_End (Context : Sdf_Context_Type;
                                Status : out Boolean);
    procedure Sdf_Generic (Context : in out Sdf_Context_Type;
                           Name : String;
diff -urN ghdl-0.27/vhdl/grt/grt-vpi.adb ghdl-0.28dev/vhdl/grt/grt-vpi.adb
--- ghdl-0.27/vhdl/grt/grt-vpi.adb	2007-12-06 06:22:54.000000000 +0100
+++ ghdl-0.28dev/vhdl/grt/grt-vpi.adb	2009-09-20 09:06:43.000000000 +0200
@@ -40,15 +40,17 @@
 
 with Ada.Unchecked_Deallocation;
 with System.Storage_Elements; --  Work around GNAT bug.
+pragma Unreferenced (System.Storage_Elements);
 with Grt.Stdio; use Grt.Stdio;
 with Grt.C; use Grt.C;
 with Grt.Signals; use Grt.Signals;
-with GNAT.Table;
+with Grt.Table;
 with Grt.Astdio; use Grt.Astdio;
 with Grt.Hooks; use Grt.Hooks;
 with Grt.Vcd; use Grt.Vcd;
 with Grt.Errors; use Grt.Errors;
 with Grt.Rtis_Types;
+pragma Elaborate_All (Grt.Table);
 
 package body Grt.Vpi is
    --  The VPI interface requires libdl (dlopen, dlsym) to be linked in.
@@ -69,6 +71,7 @@
    procedure dbgPut (Str : String)
    is
       S : size_t;
+      pragma Unreferenced (S);
    begin
       S := fwrite (Str'Address, Str'Length, 1, stderr);
    end dbgPut;
@@ -76,6 +79,7 @@
    procedure dbgPut (C : Character)
    is
       R : int;
+      pragma Unreferenced (R);
    begin
       R := fputc (Character'Pos (C), stderr);
    end dbgPut;
@@ -722,12 +726,11 @@
       Cb   : s_cb_data;
    end record;
 
-   package Vpi_Table is new GNAT.Table
+   package Vpi_Table is new Grt.Table
      (Table_Component_Type => Vpi_Var_Type,
       Table_Index_Type     => Vpi_Index_Type,
       Table_Low_Bound      => 0,
-      Table_Initial        => 32,
-      Table_Increment      => 100);
+      Table_Initial        => 32);
 
    function vpi_register_cb (Data : p_cb_data) return vpiHandle
    is
@@ -865,7 +868,7 @@
    --  Return TRUE if OPT is an option for VPI.
    function Vpi_Option (Opt : String) return Boolean
    is
-      F : Natural := Opt'First;
+      F : constant Natural := Opt'First;
    begin
       if Opt'Length < 5 or else Opt (F .. F + 4) /= "--vpi" then
          return False;
@@ -918,6 +921,7 @@
    procedure Vpi_Start
    is
       Res : Integer;
+      pragma Unreferenced (Res);
    begin
       if Vpi_Filename = null then
          return;
@@ -935,6 +939,7 @@
    procedure Vpi_Cycle
    is
       Res : Integer;
+      pragma Unreferenced (Res);
    begin
       if g_cbReadOnlySync /= null
         and then g_cbReadOnlySync.Time.mLow < Integer (Sim_Time / 1_000_000)
@@ -959,6 +964,7 @@
    procedure Vpi_End
    is
       Res : Integer;
+      pragma Unreferenced (Res);
    begin
       if g_cbEndOfSimulation /= null then
          Res := g_cbEndOfSimulation.Cb_Rtn.all (g_cbEndOfSimulation);
diff -urN ghdl-0.27/vhdl/grt/grt-vstrings.adb ghdl-0.28dev/vhdl/grt/grt-vstrings.adb
--- ghdl-0.27/vhdl/grt/grt-vstrings.adb	2005-10-08 14:04:34.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-vstrings.adb	2009-09-20 09:06:43.000000000 +0200
@@ -16,6 +16,7 @@
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with System.Storage_Elements; --  Work around GNAT bug.
+pragma Unreferenced (System.Storage_Elements);
 with Grt.Errors; use Grt.Errors;
 with Grt.C; use Grt.C;
 
@@ -41,7 +42,7 @@
 
    procedure Grow (Vstr : in out Vstring; Sum : Natural)
    is
-      Nlen : Natural := Vstr.Len + Sum;
+      Nlen : constant Natural := Vstr.Len + Sum;
       Nmax : Natural;
    begin
       Vstr.Len := Nlen;
@@ -72,7 +73,7 @@
 
    procedure Append (Vstr : in out Vstring; Str : String)
    is
-      S : Natural := Vstr.Len;
+      S : constant Natural := Vstr.Len;
    begin
       Grow (Vstr, Str'Length);
       Vstr.Str (S + 1 .. S + Str'Length) := Str;
@@ -80,8 +81,8 @@
 
    procedure Append (Vstr : in out Vstring; Str : Ghdl_C_String)
    is
-      S : Natural := Vstr.Len;
-      L : Natural := strlen (Str);
+      S : constant Natural := Vstr.Len;
+      L : constant Natural := strlen (Str);
    begin
       Grow (Vstr, L);
       Vstr.Str (S + 1 .. S + L) := Str (1 .. L);
@@ -125,8 +126,8 @@
 
    procedure Grow (Rstr : in out Rstring; Min : Natural)
    is
-      Len : Natural := Length (Rstr);
-      Nlen : Natural := Len + Min;
+      Len : constant Natural := Length (Rstr);
+      Nlen : constant Natural := Len + Min;
       Nstr : Fat_String_Acc;
       Nfirst : Natural;
       Nmax : Natural;
@@ -171,7 +172,7 @@
 
    procedure Prepend (Rstr : in out Rstring; Str : Ghdl_C_String)
    is
-      L : Natural := strlen (Str);
+      L : constant Natural := strlen (Str);
    begin
       Grow (Rstr, L);
       Rstr.First := Rstr.First - L;
@@ -199,6 +200,7 @@
    procedure Put (Stream : FILEs; Rstr : Rstring)
    is
       S : size_t;
+      pragma Unreferenced (S);
    begin
       S := fwrite (Get_Address (Rstr), size_t (Length (Rstr)), 1, Stream);
    end Put;
diff -urN ghdl-0.27/vhdl/grt/grt-waves.adb ghdl-0.28dev/vhdl/grt/grt-waves.adb
--- ghdl-0.27/vhdl/grt/grt-waves.adb	2008-05-19 06:26:36.000000000 +0200
+++ ghdl-0.28dev/vhdl/grt/grt-waves.adb	2009-09-20 09:06:43.000000000 +0200
@@ -19,16 +19,15 @@
 with Ada.Unchecked_Deallocation;
 with Interfaces; use Interfaces;
 with System.Storage_Elements; --  Work around GNAT bug.
+pragma Unreferenced (System.Storage_Elements);
 with Grt.Types; use Grt.Types;
 with Grt.Avhpi; use Grt.Avhpi;
 with Grt.Stdio; use Grt.Stdio;
 with Grt.C; use Grt.C;
 with Grt.Errors; use Grt.Errors;
-with Grt.Types; use Grt.Types;
 with Grt.Astdio; use Grt.Astdio;
 with Grt.Hooks; use Grt.Hooks;
-with Grt.Avhpi; use Grt.Avhpi;
-with GNAT.Table;
+with Grt.Table;
 with Grt.Avls; use Grt.Avls;
 with Grt.Rtis; use Grt.Rtis;
 with Grt.Rtis_Addr; use Grt.Rtis_Addr;
@@ -39,11 +38,12 @@
 with Grt.Vstrings; use Grt.Vstrings;
 
 pragma Elaborate_All (Grt.Rtis_Utils);
+pragma Elaborate_All (Grt.Table);
 
 package body Grt.Waves is
    --  Waves filename.
    Wave_Filename : String_Access := null;
-   --  Stream corresponding to the VCD filename.
+   --  Stream corresponding to the GHW filename.
    Wave_Stream : FILEs;
 
    Ghw_Hie_Design       : constant Unsigned_8 := 1;
@@ -62,10 +62,13 @@
    Ghw_Hie_Port_Buffer  : constant Unsigned_8 := 20; --  Port
    Ghw_Hie_Port_Linkage : constant Unsigned_8 := 21; --  Port
 
+   pragma Unreferenced (Ghw_Hie_Design);
+   pragma Unreferenced (Ghw_Hie_Generic);
+
    --  Return TRUE if OPT is an option for wave.
    function Wave_Option (Opt : String) return Boolean
    is
-      F : Natural := Opt'First;
+      F : constant Natural := Opt'First;
    begin
       if Opt'Length < 6 or else Opt (F .. F + 5) /= "--wave" then
          return False;
@@ -89,6 +92,7 @@
    procedure Wave_Put (Str : String)
    is
       R : size_t;
+      pragma Unreferenced (R);
    begin
       R := fwrite (Str'Address, Str'Length, 1, Wave_Stream);
    end Wave_Put;
@@ -96,6 +100,7 @@
    procedure Wave_Putc (C : Character)
    is
       R : int;
+      pragma Unreferenced (R);
    begin
       R := fputc (Character'Pos (C), Wave_Stream);
    end Wave_Putc;
@@ -109,6 +114,7 @@
    is
       V : Unsigned_8 := B;
       R : size_t;
+      pragma Unreferenced (R);
    begin
       R := fwrite (V'Address, 1, 1, Wave_Stream);
    end Wave_Put_Byte;
@@ -180,6 +186,7 @@
    is
       V : Ghdl_I32 := Val;
       R : size_t;
+      pragma Unreferenced (R);
    begin
       R := fwrite (V'Address, 4, 1, Wave_Stream);
    end Wave_Put_I32;
@@ -188,6 +195,7 @@
    is
       V : Ghdl_I64 := Val;
       R : size_t;
+      pragma Unreferenced (R);
    begin
       R := fwrite (V'Address, 8, 1, Wave_Stream);
    end Wave_Put_I64;
@@ -196,6 +204,7 @@
    is
       V : Ghdl_F64 := F64;
       R : size_t;
+      pragma Unreferenced (R);
    begin
       R := fwrite (V'Address, Ghdl_F64'Size / Storage_Unit, 1, Wave_Stream);
    end Wave_Put_F64;
@@ -229,12 +238,11 @@
       Pos : long;
    end record;
 
-   package Section_Table is new GNAT.Table
+   package Section_Table is new Grt.Table
      (Table_Component_Type => Header_Type,
       Table_Index_Type => Natural,
       Table_Low_Bound => 1,
-      Table_Initial => 16,
-      Table_Increment => 100);
+      Table_Initial => 16);
 
    --  Create a new section.
    --  Write the header in the file.
@@ -270,13 +278,7 @@
          Wave_Put_Byte (V);
       end;
       --  Word size, 1 byte.
-      if Integer'Size = 32 then
-         Wave_Put_Byte (4);
-      elsif Integer'Size = 64 then
-         Wave_Put_Byte (8);
-      else
-         Wave_Put_Byte (0);
-      end if;
+      Wave_Put_Byte (Integer'Size / 8);
       --  File offset size, 1 byte
       Wave_Put_Byte (1);
       --  Unused, must be zero (MBZ).
@@ -347,19 +349,17 @@
       null;
    end Avhpi_Error;
 
-   package Str_Table is new GNAT.Table
+   package Str_Table is new Grt.Table
      (Table_Component_Type => Ghdl_C_String,
       Table_Index_Type => AVL_Value,
       Table_Low_Bound => 1,
-      Table_Initial => 16,
-      Table_Increment => 100);
+      Table_Initial => 16);
 
-   package Str_AVL is new GNAT.Table
+   package Str_AVL is new Grt.Table
      (Table_Component_Type => AVL_Node,
       Table_Index_Type => AVL_Nid,
       Table_Low_Bound => AVL_Root,
-      Table_Initial => 16,
-      Table_Increment => 100);
+      Table_Initial => 16);
 
    Strings_Len : Natural := 0;
 
@@ -394,6 +394,8 @@
       New_Line (stdout);
    end Disp_Str_Avl;
 
+   pragma Unreferenced (Disp_Str_Avl);
+
    function Create_Str_Index (Str : Ghdl_C_String) return AVL_Value
    is
       Res : AVL_Nid;
@@ -414,6 +416,8 @@
       return Str_AVL.Table (Res).Val;
    end Create_Str_Index;
 
+   pragma Unreferenced (Create_Str_Index);
+
    procedure Create_String_Id (Str : Ghdl_C_String)
    is
       Res : AVL_Nid;
@@ -472,23 +476,20 @@
       Context : Rti_Context;
    end record;
 
-   package Types_Table is new GNAT.Table
+   package Types_Table is new Grt.Table
      (Table_Component_Type => Type_Node,
       Table_Index_Type => AVL_Value,
       Table_Low_Bound => 1,
-      Table_Initial => 16,
-      Table_Increment => 100);
+      Table_Initial => 16);
 
-   package Types_AVL is new GNAT.Table
+   package Types_AVL is new Grt.Table
      (Table_Component_Type => AVL_Node,
       Table_Index_Type => AVL_Nid,
       Table_Low_Bound => AVL_Root,
-      Table_Initial => 16,
-      Table_Increment => 100);
+      Table_Initial => 16);
 
    function Type_Compare (L, R : AVL_Value) return Integer
    is
-      use System;
       function To_Ia is new
         Ada.Unchecked_Conversion (Ghdl_Rti_Access, Integer_Address);
 
@@ -524,7 +525,7 @@
       return 0;
    end Type_Compare;
 
-   --  Try to find typr (RTI, CTXT) in the types_AVL table.
+   --  Try to find type (RTI, CTXT) in the types_AVL table.
    --  The first step is to canonicalize CTXT, so that it is the CTXT of
    --   the type (and not a sub-scope of it).
    procedure Find_Type (Rti : Ghdl_Rti_Access;
@@ -538,6 +539,9 @@
          when Ghdl_Rtik_Type_B2
            | Ghdl_Rtik_Type_E8 =>
             N_Ctxt := Null_Context;
+         when Ghdl_Rtik_Port
+           | Ghdl_Rtik_Signal =>
+            N_Ctxt := Ctxt;
          when others =>
             --  Compute the canonical context.
             if Rti.Max_Depth < Rti.Depth then
@@ -582,6 +586,26 @@
       Write_Type_Id (Res);
    end Write_Type_Id;
 
+   procedure Add_Type (Rti : Ghdl_Rti_Access; Ctxt : Rti_Context)
+   is
+      Res : AVL_Nid;
+   begin
+      --  Then, create the type.
+      Types_Table.Append (Type_Node'(Type_Rti => Rti, Context => Ctxt));
+      Types_AVL.Append (AVL_Node'(Val => Types_Table.Last,
+                                  Left | Right => AVL_Nil,
+                                  Height => 1));
+
+      Get_Node
+        (AVL_Tree (Types_AVL.Table (Types_AVL.First .. Types_AVL.Last)),
+         Type_Compare'Access,
+         Types_AVL.Last, Res);
+      if Res /= Types_AVL.Last then
+         --raise Program_Error;
+         Internal_Error ("wave.create_type(2)");
+      end if;
+   end Add_Type;
+
    procedure Create_Type (Rti : Ghdl_Rti_Access; Ctxt : Rti_Context)
    is
       N_Ctxt : Rti_Context;
@@ -678,25 +702,14 @@
       end case;
 
       --  Then, create the type.
-      Types_Table.Append (Type_Node'(Type_Rti => Rti, Context => N_Ctxt));
-      Types_AVL.Append (AVL_Node'(Val => Types_Table.Last,
-                                  Left | Right => AVL_Nil,
-                                  Height => 1));
-
-      Get_Node
-        (AVL_Tree (Types_AVL.Table (Types_AVL.First .. Types_AVL.Last)),
-         Type_Compare'Access,
-         Types_AVL.Last, Res);
-      if Res /= Types_AVL.Last then
-         --raise Program_Error;
-         Internal_Error ("wave.create_type(2)");
-      end if;
+      Add_Type (Rti, N_Ctxt);
    end Create_Type;
 
    procedure Create_Object_Type (Obj : VhpiHandleT)
    is
       Obj_Type : VhpiHandleT;
       Error : AvhpiErrorT;
+      Rti : Ghdl_Rti_Access;
    begin
       --  Extract type of the signal.
       Vhpi_Handle (VhpiSubtype, Obj, Obj_Type, Error);
@@ -704,13 +717,22 @@
          Avhpi_Error (Error);
          return;
       end if;
-      Create_Type (Avhpi_Get_Rti (Obj_Type), Avhpi_Get_Context (Obj_Type));
+      Rti := Avhpi_Get_Rti (Obj_Type);
+      Create_Type (Rti, Avhpi_Get_Context (Obj_Type));
+
+      --  The the signal type is an unconstrained array, also put the object
+      --  in the type AVL.
+      --  The real type will be written to the file.
+      if Rti.Kind = Ghdl_Rtik_Type_Array then
+         Add_Type (Avhpi_Get_Rti (Obj), Avhpi_Get_Context (Obj));
+      end if;
    end Create_Object_Type;
 
    procedure Write_Object_Type (Obj : VhpiHandleT)
    is
       Obj_Type : VhpiHandleT;
       Error : AvhpiErrorT;
+      Rti : Ghdl_Rti_Access;
    begin
       --  Extract type of the signal.
       Vhpi_Handle (VhpiSubtype, Obj, Obj_Type, Error);
@@ -718,7 +740,12 @@
          Avhpi_Error (Error);
          return;
       end if;
-      Write_Type_Id (Avhpi_Get_Rti (Obj_Type), Avhpi_Get_Context (Obj_Type));
+      Rti := Avhpi_Get_Rti (Obj_Type);
+      if Rti.Kind = Ghdl_Rtik_Type_Array then
+         Write_Type_Id (Avhpi_Get_Rti (Obj), Avhpi_Get_Context (Obj));
+      else
+         Write_Type_Id (Rti, Avhpi_Get_Context (Obj_Type));
+      end if;
    end Write_Object_Type;
 
    procedure Create_Generate_Type (Gen : VhpiHandleT)
@@ -1049,6 +1076,8 @@
       fflush (Wave_Stream);
    end Write_Strings;
 
+   pragma Unreferenced (Write_Strings);
+
    procedure Freeze_Strings
    is
       type Str_Table1_Type is array (1 .. Str_Table.Last) of Ghdl_C_String;
@@ -1197,130 +1226,160 @@
       for I in Types_Table.First .. Types_Table.Last loop
          Rti := Types_Table.Table (I).Type_Rti;
          Ctxt := Types_Table.Table (I).Context;
-         --  Kind.
-         Wave_Put_Byte (Ghdl_Rtik'Pos (Rti.Kind));
-         case Rti.Kind is
-            when Ghdl_Rtik_Type_B2
-              | Ghdl_Rtik_Type_E8 =>
+
+         if Rti.Kind = Ghdl_Rtik_Signal or Rti.Kind = Ghdl_Rtik_Port then
+            declare
+               Obj_Rti : constant Ghdl_Rtin_Object_Acc :=
+                 To_Ghdl_Rtin_Object_Acc (Rti);
+               Arr : constant Ghdl_Rtin_Type_Array_Acc :=
+                 To_Ghdl_Rtin_Type_Array_Acc (Obj_Rti.Obj_Type);
+               Addr : Ghdl_Uc_Array_Acc;
+            begin
+               Wave_Put_Byte (Ghdl_Rtik'Pos (Ghdl_Rtik_Subtype_Array));
+               Write_String_Id (null);
+               Write_Type_Id (Obj_Rti.Obj_Type, Ctxt);
+               Addr := To_Ghdl_Uc_Array_Acc
+                 (Loc_To_Addr (Rti.Depth, Obj_Rti.Loc, Ctxt));
                declare
-                  Enum : Ghdl_Rtin_Type_Enum_Acc;
+                  Rngs : Ghdl_Range_Array (0 .. Arr.Nbr_Dim - 1);
                begin
-                  Enum := To_Ghdl_Rtin_Type_Enum_Acc (Rti);
-                  Write_String_Id (Enum.Name);
-                  Wave_Put_ULEB128 (Ghdl_E32 (Enum.Nbr));
-                  for I in 1 .. Enum.Nbr loop
-                     Write_String_Id (Enum.Names (I - 1));
+                  Bound_To_Range (Addr.Bounds, Arr, Rngs);
+                  for I in Rngs'Range loop
+                     Write_Range (Arr.Indexes (I), Rngs (I));
                   end loop;
                end;
-            when Ghdl_Rtik_Subtype_Array
-              | Ghdl_Rtik_Subtype_Array_Ptr =>
-               declare
-                  Arr : Ghdl_Rtin_Subtype_Array_Acc;
-               begin
-                  Arr := To_Ghdl_Rtin_Subtype_Array_Acc (Rti);
-                  Write_String_Id (Arr.Name);
-                  Write_Type_Id (To_Ghdl_Rti_Access (Arr.Basetype), Ctxt);
+            end;
+         else
+            --  Kind.
+            Wave_Put_Byte (Ghdl_Rtik'Pos (Rti.Kind));
+            case Rti.Kind is
+               when Ghdl_Rtik_Type_B2
+                 | Ghdl_Rtik_Type_E8 =>
                   declare
-                     Rngs : Ghdl_Range_Array (0 .. Arr.Basetype.Nbr_Dim - 1);
+                     Enum : Ghdl_Rtin_Type_Enum_Acc;
                   begin
-                     Bound_To_Range (Loc_To_Addr (Rti.Depth, Arr.Bounds, Ctxt),
-                                     Arr.Basetype, Rngs);
-                     for I in Rngs'Range loop
-                        Write_Range (Arr.Basetype.Indexes (I), Rngs (I));
+                     Enum := To_Ghdl_Rtin_Type_Enum_Acc (Rti);
+                     Write_String_Id (Enum.Name);
+                     Wave_Put_ULEB128 (Ghdl_E32 (Enum.Nbr));
+                     for I in 1 .. Enum.Nbr loop
+                        Write_String_Id (Enum.Names (I - 1));
                      end loop;
                   end;
-               end;
-            when Ghdl_Rtik_Type_Array =>
-               declare
-                  Arr : Ghdl_Rtin_Type_Array_Acc;
-               begin
-                  Arr := To_Ghdl_Rtin_Type_Array_Acc (Rti);
-                  Write_String_Id (Arr.Name);
-                  Write_Type_Id (Arr.Element, Ctxt);
-                  Wave_Put_ULEB128 (Ghdl_E32 (Arr.Nbr_Dim));
-                  for I in 1 .. Arr.Nbr_Dim loop
-                     Write_Type_Id (Arr.Indexes (I - 1), Ctxt);
-                  end loop;
-               end;
-         when Ghdl_Rtik_Type_Record =>
-            declare
-               Rec : Ghdl_Rtin_Type_Record_Acc;
-               El : Ghdl_Rtin_Element_Acc;
-            begin
-               Rec := To_Ghdl_Rtin_Type_Record_Acc (Rti);
-               Write_String_Id (Rec.Name);
-               Wave_Put_ULEB128 (Ghdl_E32 (Rec.Nbrel));
-               for I in 1 .. Rec.Nbrel loop
-                  El := To_Ghdl_Rtin_Element_Acc (Rec.Elements (I - 1));
-                  Write_String_Id (El.Name);
-                  Write_Type_Id (El.Eltype, Ctxt);
-               end loop;
-            end;
-            when Ghdl_Rtik_Subtype_Scalar =>
-               declare
-                  Sub : Ghdl_Rtin_Subtype_Scalar_Acc;
-               begin
-                  Sub := To_Ghdl_Rtin_Subtype_Scalar_Acc (Rti);
-                  Write_String_Id (Sub.Name);
-                  Write_Type_Id (Sub.Basetype, Ctxt);
-                  Write_Range (Sub.Basetype,
-                               To_Ghdl_Range_Ptr (Loc_To_Addr (Rti.Depth,
-                                                               Sub.Range_Loc,
-                                                               Ctxt)));
-               end;
-            when Ghdl_Rtik_Type_I32
-              | Ghdl_Rtik_Type_I64
-              | Ghdl_Rtik_Type_F64 =>
-               declare
-                  Base : Ghdl_Rtin_Type_Scalar_Acc;
-               begin
-                  Base := To_Ghdl_Rtin_Type_Scalar_Acc (Rti);
-                  Write_String_Id (Base.Name);
-               end;
-            when Ghdl_Rtik_Type_P32
-              | Ghdl_Rtik_Type_P64 =>
-               declare
-                  Base : Ghdl_Rtin_Type_Physical_Acc;
-                  Unit : Ghdl_Rtin_Unit_Acc;
-               begin
-                  Base := To_Ghdl_Rtin_Type_Physical_Acc (Rti);
-                  Write_String_Id (Base.Name);
-                  Wave_Put_ULEB128 (Ghdl_U32 (Base.Nbr));
-                  for I in 1 .. Base.Nbr loop
-                     Unit := To_Ghdl_Rtin_Unit_Acc (Base.Units (I - 1));
-                     Write_String_Id (Unit.Name);
-                     case Base.Common.Mode is
-                        when 0 =>
-                           --  Value is locally static.
-                           case Base.Common.Kind is
-                              when Ghdl_Rtik_Type_P32 =>
-                                 Wave_Put_SLEB128 (Unit.Value.Unit_32);
-                              when Ghdl_Rtik_Type_P64 =>
-                                 Wave_Put_LSLEB128 (Unit.Value.Unit_64);
-                              when others =>
-                                 Internal_Error
-                                   ("wave.write_types(P32/P64-0)");
-                           end case;
-                        when 1 =>
-                           case Rti.Kind is
-                              when Ghdl_Rtik_Type_P32 =>
-                                 Wave_Put_SLEB128 (Unit.Value.Unit_Addr.I32);
-                              when Ghdl_Rtik_Type_P64 =>
-                                 Wave_Put_LSLEB128 (Unit.Value.Unit_Addr.I64);
-                              when others =>
-                                 Internal_Error
-                                   ("wave.write_types(P32/P64-1)");
-                           end case;
-                        when others =>
-                           Internal_Error ("wave.write_types(P32/P64)");
-                     end case;
-                  end loop;
-               end;
-            when others =>
-               Internal_Error ("wave.write_types");
---             Internal_Error ("wave.write_types: does not handle " &
---                             Ghdl_Rtik'Image (Rti.Kind));
-         end case;
+               when Ghdl_Rtik_Subtype_Array
+                 | Ghdl_Rtik_Subtype_Array_Ptr =>
+                  declare
+                     Arr : Ghdl_Rtin_Subtype_Array_Acc;
+                  begin
+                     Arr := To_Ghdl_Rtin_Subtype_Array_Acc (Rti);
+                     Write_String_Id (Arr.Name);
+                     Write_Type_Id (To_Ghdl_Rti_Access (Arr.Basetype), Ctxt);
+                     declare
+                        Rngs : Ghdl_Range_Array
+                          (0 .. Arr.Basetype.Nbr_Dim - 1);
+                     begin
+                        Bound_To_Range
+                          (Loc_To_Addr (Rti.Depth, Arr.Bounds, Ctxt),
+                           Arr.Basetype, Rngs);
+                        for I in Rngs'Range loop
+                           Write_Range (Arr.Basetype.Indexes (I), Rngs (I));
+                        end loop;
+                     end;
+                  end;
+               when Ghdl_Rtik_Type_Array =>
+                  declare
+                     Arr : Ghdl_Rtin_Type_Array_Acc;
+                  begin
+                     Arr := To_Ghdl_Rtin_Type_Array_Acc (Rti);
+                     Write_String_Id (Arr.Name);
+                     Write_Type_Id (Arr.Element, Ctxt);
+                     Wave_Put_ULEB128 (Ghdl_E32 (Arr.Nbr_Dim));
+                     for I in 1 .. Arr.Nbr_Dim loop
+                        Write_Type_Id (Arr.Indexes (I - 1), Ctxt);
+                     end loop;
+                  end;
+               when Ghdl_Rtik_Type_Record =>
+                  declare
+                     Rec : Ghdl_Rtin_Type_Record_Acc;
+                     El : Ghdl_Rtin_Element_Acc;
+                  begin
+                     Rec := To_Ghdl_Rtin_Type_Record_Acc (Rti);
+                     Write_String_Id (Rec.Name);
+                     Wave_Put_ULEB128 (Ghdl_E32 (Rec.Nbrel));
+                     for I in 1 .. Rec.Nbrel loop
+                        El := To_Ghdl_Rtin_Element_Acc (Rec.Elements (I - 1));
+                        Write_String_Id (El.Name);
+                        Write_Type_Id (El.Eltype, Ctxt);
+                     end loop;
+                  end;
+               when Ghdl_Rtik_Subtype_Scalar =>
+                  declare
+                     Sub : Ghdl_Rtin_Subtype_Scalar_Acc;
+                  begin
+                     Sub := To_Ghdl_Rtin_Subtype_Scalar_Acc (Rti);
+                     Write_String_Id (Sub.Name);
+                     Write_Type_Id (Sub.Basetype, Ctxt);
+                     Write_Range
+                       (Sub.Basetype,
+                        To_Ghdl_Range_Ptr (Loc_To_Addr (Rti.Depth,
+                                                        Sub.Range_Loc,
+                                                        Ctxt)));
+                  end;
+               when Ghdl_Rtik_Type_I32
+                 | Ghdl_Rtik_Type_I64
+                 | Ghdl_Rtik_Type_F64 =>
+                  declare
+                     Base : Ghdl_Rtin_Type_Scalar_Acc;
+                  begin
+                     Base := To_Ghdl_Rtin_Type_Scalar_Acc (Rti);
+                     Write_String_Id (Base.Name);
+                  end;
+               when Ghdl_Rtik_Type_P32
+                 | Ghdl_Rtik_Type_P64 =>
+                  declare
+                     Base : Ghdl_Rtin_Type_Physical_Acc;
+                     Unit : Ghdl_Rtin_Unit_Acc;
+                  begin
+                     Base := To_Ghdl_Rtin_Type_Physical_Acc (Rti);
+                     Write_String_Id (Base.Name);
+                     Wave_Put_ULEB128 (Ghdl_U32 (Base.Nbr));
+                     for I in 1 .. Base.Nbr loop
+                        Unit := To_Ghdl_Rtin_Unit_Acc (Base.Units (I - 1));
+                        Write_String_Id (Unit.Name);
+                        case Base.Common.Mode is
+                           when 0 =>
+                              --  Value is locally static.
+                              case Base.Common.Kind is
+                                 when Ghdl_Rtik_Type_P32 =>
+                                    Wave_Put_SLEB128 (Unit.Value.Unit_32);
+                                 when Ghdl_Rtik_Type_P64 =>
+                                    Wave_Put_LSLEB128 (Unit.Value.Unit_64);
+                                 when others =>
+                                    Internal_Error
+                                      ("wave.write_types(P32/P64-0)");
+                              end case;
+                           when 1 =>
+                              case Rti.Kind is
+                                 when Ghdl_Rtik_Type_P32 =>
+                                    Wave_Put_SLEB128
+                                      (Unit.Value.Unit_Addr.I32);
+                                 when Ghdl_Rtik_Type_P64 =>
+                                    Wave_Put_LSLEB128
+                                      (Unit.Value.Unit_Addr.I64);
+                                 when others =>
+                                    Internal_Error
+                                      ("wave.write_types(P32/P64-1)");
+                              end case;
+                           when others =>
+                              Internal_Error ("wave.write_types(P32/P64)");
+                        end case;
+                     end loop;
+                  end;
+               when others =>
+                  Internal_Error ("wave.write_types");
+                  --   Internal_Error ("wave.write_types: does not handle " &
+                  --                   Ghdl_Rtik'Image (Rti.Kind));
+            end case;
+         end if;
       end loop;
       Wave_Put_Byte (0);
    end Write_Types;
@@ -1380,18 +1439,19 @@
    end Write_Known_Types;
 
    --  Table of signals to be dumped.
-   package Dump_Table is new GNAT.Table
+   package Dump_Table is new Grt.Table
      (Table_Component_Type => Ghdl_Signal_Ptr,
       Table_Index_Type => Natural,
       Table_Low_Bound => 1,
-      Table_Initial => 32,
-      Table_Increment => 100);
+      Table_Initial => 32);
 
    function Get_Dump_Entry (N : Natural) return Ghdl_Signal_Ptr is
    begin
       return Dump_Table.Table (N);
    end Get_Dump_Entry;
 
+   pragma Unreferenced (Get_Dump_Entry);
+
    procedure Write_Hierarchy (Root : VhpiHandleT)
    is
       N : Natural;
diff -urN ghdl-0.27/vhdl/ieee-std_logic_1164.adb ghdl-0.28dev/vhdl/ieee-std_logic_1164.adb
--- ghdl-0.27/vhdl/ieee-std_logic_1164.adb	2006-06-17 02:33:52.000000000 +0200
+++ ghdl-0.28dev/vhdl/ieee-std_logic_1164.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
@@ -113,15 +113,16 @@
       Decl := Get_Chain (Decl);
       Decl := Skip_Implicit (Decl);
       if Decl = Null_Iir
-        or else Get_Kind (Decl) /= Iir_Kind_Type_Declaration
+        or else (Get_Kind (Decl) /= Iir_Kind_Type_Declaration
+                   and then Get_Kind (Decl) /= Iir_Kind_Subtype_Declaration)
         or else Get_Identifier (Decl) /= Name_Std_Logic_Vector
       then
          raise Error;
       end if;
       Def := Get_Type (Decl);
-      if Get_Kind (Def) /= Iir_Kind_Array_Type_Definition then
-         raise Error;
-      end if;
+--      if Get_Kind (Def) /= Iir_Kind_Array_Type_Definition then
+--         raise Error;
+--      end if;
       Std_Logic_Vector_Type := Def;
 
       --  Skip any declarations but functions.
diff -urN ghdl-0.27/vhdl/ieee-std_logic_1164.ads ghdl-0.28dev/vhdl/ieee-std_logic_1164.ads
--- ghdl-0.27/vhdl/ieee-std_logic_1164.ads	2005-09-22 23:11:00.000000000 +0200
+++ ghdl-0.28dev/vhdl/ieee-std_logic_1164.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
diff -urN ghdl-0.27/vhdl/ieee-vital_timing.adb ghdl-0.28dev/vhdl/ieee-vital_timing.adb
--- ghdl-0.27/vhdl/ieee-vital_timing.adb	2006-06-17 02:20:00.000000000 +0200
+++ ghdl-0.28dev/vhdl/ieee-vital_timing.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
@@ -417,7 +417,7 @@
       use Name_Table;
 
       Len : Natural;
-      P : Natural := Gen_Name_Pos;
+      P : constant Natural := Gen_Name_Pos;
       C : Character;
    begin
       Len := 0;
@@ -969,8 +969,10 @@
      (Decl : Iir_Constant_Interface_Declaration)
    is
       Oport : Iir;
+      pragma Unreferenced (Oport);
       Pos : Natural;
       Kind : Timing_Generic_Type_Kind;
+      pragma Unreferenced (Kind);
    begin
       if not Check_Timing_Generic_Prefix (Decl, 8) then
          return;
@@ -1012,6 +1014,7 @@
       Iport : Iir;
       Oport : Iir;
       Cport : Iir;
+      pragma Unreferenced (Cport);
       Clock_Start : Natural;
       Clock_End : Natural;
    begin
@@ -1027,7 +1030,7 @@
       Check_Vital_Delay_Type (Iport, Oport);
 
       --  IEEE 1076.4  4.3.2.1.3.14  Biased propagation delay
-      --  There shall exit, in the same entity generic clause, a corresponding
+      --  There shall exist, in the same entity generic clause, a corresponding
       --  propagation delay generic denoting the same ports, condition name,
       --  and edge.
       declare
diff -urN ghdl-0.27/vhdl/ieee-vital_timing.ads ghdl-0.28dev/vhdl/ieee-vital_timing.ads
--- ghdl-0.27/vhdl/ieee-vital_timing.ads	2005-09-22 23:11:20.000000000 +0200
+++ ghdl-0.28dev/vhdl/ieee-vital_timing.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
diff -urN ghdl-0.27/vhdl/iir_chain_handling.adb ghdl-0.28dev/vhdl/iir_chain_handling.adb
--- ghdl-0.27/vhdl/iir_chain_handling.adb	2005-09-22 23:28:29.000000000 +0200
+++ ghdl-0.28dev/vhdl/iir_chain_handling.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 package body Iir_Chain_Handling is
diff -urN ghdl-0.27/vhdl/iir_chain_handling.ads ghdl-0.28dev/vhdl/iir_chain_handling.ads
--- ghdl-0.27/vhdl/iir_chain_handling.ads	2005-09-22 23:12:07.000000000 +0200
+++ ghdl-0.28dev/vhdl/iir_chain_handling.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
diff -urN ghdl-0.27/vhdl/iir_chains.adb ghdl-0.28dev/vhdl/iir_chains.adb
--- ghdl-0.27/vhdl/iir_chains.adb	2005-09-22 23:28:48.000000000 +0200
+++ ghdl-0.28dev/vhdl/iir_chains.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 package body Iir_Chains is
diff -urN ghdl-0.27/vhdl/iir_chains.ads ghdl-0.28dev/vhdl/iir_chains.ads
--- ghdl-0.27/vhdl/iir_chains.ads	2007-03-28 00:42:59.000000000 +0200
+++ ghdl-0.28dev/vhdl/iir_chains.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,12 +12,12 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
 with Iir_Chain_Handling;
-pragma Elaborate (Iir_Chain_Handling);
+pragma Elaborate_All (Iir_Chain_Handling);
 
 package Iir_Chains is
    --  Chains are simply linked list of iirs.
@@ -60,10 +60,6 @@
      (Get_Chain_Start => Get_Unit_Chain,
       Set_Chain_Start => Set_Unit_Chain);
 
-   package Element_Declaration_Chain_Handling is new Iir_Chain_Handling
-     (Get_Chain_Start => Get_Element_Declaration_Chain,
-      Set_Chain_Start => Set_Element_Declaration_Chain);
-
    package Configuration_Item_Chain_Handling is new Iir_Chain_Handling
      (Get_Chain_Start => Get_Configuration_Item_Chain,
       Set_Chain_Start => Set_Configuration_Item_Chain);
diff -urN ghdl-0.27/vhdl/iirs.adb ghdl-0.28dev/vhdl/iirs.adb
--- ghdl-0.27/vhdl/iirs.adb	2007-03-28 00:41:19.000000000 +0200
+++ ghdl-0.28dev/vhdl/iirs.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,10 +12,9 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
-with Ada.Unchecked_Deallocation;
 with Ada.Unchecked_Conversion;
 with Ada.Text_IO;
 with Errorout; use Errorout;
@@ -265,15 +264,15 @@
       return Token_Type'Pos (T);
    end Token_Type_To_Iir;
 
-   function Iir_To_Iir_Index32 (N : Iir) return Iir_Index32 is
-   begin
-      return Iir_Index32 (N);
-   end Iir_To_Iir_Index32;
-
-   function Iir_Index32_To_Iir (V : Iir_Index32) return Iir is
-   begin
-      return Iir_Index32'Pos (V);
-   end Iir_Index32_To_Iir;
+--     function Iir_To_Iir_Index32 (N : Iir) return Iir_Index32 is
+--     begin
+--        return Iir_Index32 (N);
+--     end Iir_To_Iir_Index32;
+
+--     function Iir_Index32_To_Iir (V : Iir_Index32) return Iir is
+--     begin
+--        return Iir_Index32'Pos (V);
+--     end Iir_Index32_To_Iir;
 
    function Iir_To_Name_Id (N : Iir) return Name_Id is
    begin
@@ -345,6 +344,7 @@
            | Iir_Kind_Aggregate_Info
            | Iir_Kind_Procedure_Call
            | Iir_Kind_Operator_Symbol
+           | Iir_Kind_Record_Element_Constraint
            | Iir_Kind_Disconnection_Specification
            | Iir_Kind_Configuration_Specification
            | Iir_Kind_Access_Type_Definition
@@ -482,7 +482,6 @@
            | Iir_Kind_Binding_Indication
            | Iir_Kind_Attribute_Specification
            | Iir_Kind_Array_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition
            | Iir_Kind_Array_Subtype_Definition
            | Iir_Kind_Entity_Declaration
            | Iir_Kind_Architecture_Declaration
@@ -2096,7 +2095,6 @@
            | Iir_Kind_Attribute_Declaration
            | Iir_Kind_Group_Template_Declaration
            | Iir_Kind_Group_Declaration
-           | Iir_Kind_Element_Declaration
            | Iir_Kind_Non_Object_Alias_Declaration
            | Iir_Kind_Function_Body
            | Iir_Kind_Function_Declaration
@@ -2221,6 +2219,7 @@
            | Iir_Kind_Bit_String_Literal
            | Iir_Kind_Simple_Aggregate
            | Iir_Kind_Attribute_Value
+           | Iir_Kind_Record_Element_Constraint
            | Iir_Kind_Disconnection_Specification
            | Iir_Kind_Range_Expression
            | Iir_Kind_Type_Declaration
@@ -3013,7 +3012,8 @@
    procedure Check_Kind_For_Element_Position (Target : Iir) is
    begin
       case Get_Kind (Target) is
-         when Iir_Kind_Element_Declaration =>
+         when Iir_Kind_Record_Element_Constraint
+           | Iir_Kind_Element_Declaration =>
             null;
          when others =>
             Failed ("Element_Position", Target);
@@ -3032,6 +3032,28 @@
       Set_Field4 (Target, Iir_Index32'Pos (Pos));
    end Set_Element_Position;
 
+   procedure Check_Kind_For_Element_Declaration (Target : Iir) is
+   begin
+      case Get_Kind (Target) is
+         when Iir_Kind_Record_Element_Constraint =>
+            null;
+         when others =>
+            Failed ("Element_Declaration", Target);
+      end case;
+   end Check_Kind_For_Element_Declaration;
+
+   function Get_Element_Declaration (Target : Iir) return Iir is
+   begin
+      Check_Kind_For_Element_Declaration (Target);
+      return Get_Field2 (Target);
+   end Get_Element_Declaration;
+
+   procedure Set_Element_Declaration (Target : Iir; El : Iir) is
+   begin
+      Check_Kind_For_Element_Declaration (Target);
+      Set_Field2 (Target, El);
+   end Set_Element_Declaration;
+
    procedure Check_Kind_For_Selected_Element (Target : Iir) is
    begin
       case Get_Kind (Target) is
@@ -3152,7 +3174,6 @@
            | Iir_Kind_Protected_Type_Declaration
            | Iir_Kind_Record_Type_Definition
            | Iir_Kind_Array_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition
            | Iir_Kind_Array_Subtype_Definition
            | Iir_Kind_Record_Subtype_Definition
            | Iir_Kind_Access_Subtype_Definition
@@ -3293,6 +3314,7 @@
            | Iir_Kind_Library_Clause
            | Iir_Kind_Character_Literal
            | Iir_Kind_Operator_Symbol
+           | Iir_Kind_Record_Element_Constraint
            | Iir_Kind_Protected_Type_Body
            | Iir_Kind_Type_Declaration
            | Iir_Kind_Anonymous_Type_Declaration
@@ -3416,6 +3438,7 @@
    begin
       case Get_Kind (Target) is
          when Iir_Kind_Design_Unit
+           | Iir_Kind_Record_Element_Constraint
            | Iir_Kind_Type_Declaration
            | Iir_Kind_Subtype_Declaration
            | Iir_Kind_Unit_Declaration
@@ -3586,7 +3609,6 @@
            | Iir_Kind_Protected_Type_Declaration
            | Iir_Kind_Record_Type_Definition
            | Iir_Kind_Array_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition
            | Iir_Kind_Array_Subtype_Definition
            | Iir_Kind_Record_Subtype_Definition
            | Iir_Kind_Access_Subtype_Definition
@@ -3619,8 +3641,7 @@
    procedure Check_Kind_For_Resolution_Function (Target : Iir) is
    begin
       case Get_Kind (Target) is
-         when Iir_Kind_Unconstrained_Array_Subtype_Definition
-           | Iir_Kind_Array_Subtype_Definition
+         when Iir_Kind_Array_Subtype_Definition
            | Iir_Kind_Record_Subtype_Definition
            | Iir_Kind_Physical_Subtype_Definition
            | Iir_Kind_Floating_Subtype_Definition
@@ -3667,6 +3688,28 @@
       Set_Flag4 (Atype, Flag);
    end Set_Text_File_Flag;
 
+   procedure Check_Kind_For_Only_Characters_Flag (Target : Iir) is
+   begin
+      case Get_Kind (Target) is
+         when Iir_Kind_Enumeration_Type_Definition =>
+            null;
+         when others =>
+            Failed ("Only_Characters_Flag", Target);
+      end case;
+   end Check_Kind_For_Only_Characters_Flag;
+
+   function Get_Only_Characters_Flag (Atype : Iir) return Boolean is
+   begin
+      Check_Kind_For_Only_Characters_Flag (Atype);
+      return Get_Flag4 (Atype);
+   end Get_Only_Characters_Flag;
+
+   procedure Set_Only_Characters_Flag (Atype : Iir; Flag : Boolean) is
+   begin
+      Check_Kind_For_Only_Characters_Flag (Atype);
+      Set_Flag4 (Atype, Flag);
+   end Set_Only_Characters_Flag;
+
    procedure Check_Kind_For_Type_Staticness (Target : Iir) is
    begin
       case Get_Kind (Target) is
@@ -3677,7 +3720,6 @@
            | Iir_Kind_Protected_Type_Declaration
            | Iir_Kind_Record_Type_Definition
            | Iir_Kind_Array_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition
            | Iir_Kind_Array_Subtype_Definition
            | Iir_Kind_Record_Subtype_Definition
            | Iir_Kind_Access_Subtype_Definition
@@ -3707,11 +3749,35 @@
       Set_State1 (Atype, Iir_Staticness'Pos (Static));
    end Set_Type_Staticness;
 
+   procedure Check_Kind_For_Constraint_State (Target : Iir) is
+   begin
+      case Get_Kind (Target) is
+         when Iir_Kind_Record_Type_Definition
+           | Iir_Kind_Array_Type_Definition
+           | Iir_Kind_Array_Subtype_Definition
+           | Iir_Kind_Record_Subtype_Definition =>
+            null;
+         when others =>
+            Failed ("Constraint_State", Target);
+      end case;
+   end Check_Kind_For_Constraint_State;
+
+   function Get_Constraint_State (Atype : Iir) return Iir_Constraint is
+   begin
+      Check_Kind_For_Constraint_State (Atype);
+      return Iir_Constraint'Val (Get_State2 (Atype));
+   end Get_Constraint_State;
+
+   procedure Set_Constraint_State (Atype : Iir; State : Iir_Constraint) is
+   begin
+      Check_Kind_For_Constraint_State (Atype);
+      Set_State2 (Atype, Iir_Constraint'Pos (State));
+   end Set_Constraint_State;
+
    procedure Check_Kind_For_Index_Subtype_List (Target : Iir) is
    begin
       case Get_Kind (Target) is
          when Iir_Kind_Array_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition
            | Iir_Kind_Array_Subtype_Definition =>
             null;
          when others =>
@@ -3757,7 +3823,6 @@
    begin
       case Get_Kind (Target) is
          when Iir_Kind_Array_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition
            | Iir_Kind_Array_Subtype_Definition =>
             null;
          when others =>
@@ -3777,49 +3842,28 @@
       Set_Field1 (Decl, Sub_Type);
    end Set_Element_Subtype;
 
-   procedure Check_Kind_For_Element_Declaration_Chain (Target : Iir) is
-   begin
-      case Get_Kind (Target) is
-         when Iir_Kind_Record_Type_Definition =>
-            null;
-         when others =>
-            Failed ("Element_Declaration_Chain", Target);
-      end case;
-   end Check_Kind_For_Element_Declaration_Chain;
-
-   function Get_Element_Declaration_Chain (Decl : Iir) return Iir is
-   begin
-      Check_Kind_For_Element_Declaration_Chain (Decl);
-      return Get_Field2 (Decl);
-   end Get_Element_Declaration_Chain;
-
-   procedure Set_Element_Declaration_Chain (Decl : Iir; Chain : Iir) is
-   begin
-      Check_Kind_For_Element_Declaration_Chain (Decl);
-      Set_Field2 (Decl, Chain);
-   end Set_Element_Declaration_Chain;
-
-   procedure Check_Kind_For_Number_Element_Declaration (Target : Iir) is
+   procedure Check_Kind_For_Elements_Declaration_List (Target : Iir) is
    begin
       case Get_Kind (Target) is
-         when Iir_Kind_Record_Type_Definition =>
+         when Iir_Kind_Record_Type_Definition
+           | Iir_Kind_Record_Subtype_Definition =>
             null;
          when others =>
-            Failed ("Number_Element_Declaration", Target);
+            Failed ("Elements_Declaration_List", Target);
       end case;
-   end Check_Kind_For_Number_Element_Declaration;
+   end Check_Kind_For_Elements_Declaration_List;
 
-   function Get_Number_Element_Declaration (Decl : Iir) return Iir_Index32 is
+   function Get_Elements_Declaration_List (Decl : Iir) return Iir_List is
    begin
-      Check_Kind_For_Number_Element_Declaration (Decl);
-      return Iir_To_Iir_Index32 (Get_Field1 (Decl));
-   end Get_Number_Element_Declaration;
+      Check_Kind_For_Elements_Declaration_List (Decl);
+      return Iir_To_Iir_List (Get_Field1 (Decl));
+   end Get_Elements_Declaration_List;
 
-   procedure Set_Number_Element_Declaration (Decl : Iir; Val : Iir_Index32) is
+   procedure Set_Elements_Declaration_List (Decl : Iir; List : Iir_List) is
    begin
-      Check_Kind_For_Number_Element_Declaration (Decl);
-      Set_Field1 (Decl, Iir_Index32_To_Iir (Val));
-   end Set_Number_Element_Declaration;
+      Check_Kind_For_Elements_Declaration_List (Decl);
+      Set_Field1 (Decl, Iir_List_To_Iir (List));
+   end Set_Elements_Declaration_List;
 
    procedure Check_Kind_For_Designated_Type (Target : Iir) is
    begin
@@ -4157,6 +4201,30 @@
       Set_State1 (Proc, Tri_State_Type'Pos (State));
    end Set_Wait_State;
 
+   procedure Check_Kind_For_All_Sensitized_State (Target : Iir) is
+   begin
+      case Get_Kind (Target) is
+         when Iir_Kind_Function_Declaration
+           | Iir_Kind_Procedure_Declaration =>
+            null;
+         when others =>
+            Failed ("All_Sensitized_State", Target);
+      end case;
+   end Check_Kind_For_All_Sensitized_State;
+
+   function Get_All_Sensitized_State (Proc : Iir) return Iir_All_Sensitized is
+   begin
+      Check_Kind_For_All_Sensitized_State (Proc);
+      return Iir_All_Sensitized'Val (Get_State3 (Proc));
+   end Get_All_Sensitized_State;
+
+   procedure Set_All_Sensitized_State (Proc : Iir; State : Iir_All_Sensitized)
+      is
+   begin
+      Check_Kind_For_All_Sensitized_State (Proc);
+      Set_State3 (Proc, Iir_All_Sensitized'Pos (State));
+   end Set_All_Sensitized_State;
+
    procedure Check_Kind_For_Seen_Flag (Target : Iir) is
    begin
       case Get_Kind (Target) is
@@ -4242,7 +4310,6 @@
            | Iir_Kind_Protected_Type_Declaration
            | Iir_Kind_Record_Type_Definition
            | Iir_Kind_Array_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition
            | Iir_Kind_Array_Subtype_Definition
            | Iir_Kind_Record_Subtype_Definition
            | Iir_Kind_Access_Subtype_Definition
@@ -4282,7 +4349,6 @@
            | Iir_Kind_Protected_Type_Declaration
            | Iir_Kind_Record_Type_Definition
            | Iir_Kind_Array_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition
            | Iir_Kind_Array_Subtype_Definition
            | Iir_Kind_Record_Subtype_Definition
            | Iir_Kind_Access_Subtype_Definition
@@ -4319,7 +4385,6 @@
            | Iir_Kind_Incomplete_Type_Definition
            | Iir_Kind_Record_Type_Definition
            | Iir_Kind_Array_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition
            | Iir_Kind_Array_Subtype_Definition
            | Iir_Kind_Record_Subtype_Definition
            | Iir_Kind_Physical_Subtype_Definition
@@ -4393,6 +4458,29 @@
       Set_Flag3 (Design, Flag);
    end Set_Elab_Flag;
 
+   procedure Check_Kind_For_Index_Constraint_Flag (Target : Iir) is
+   begin
+      case Get_Kind (Target) is
+         when Iir_Kind_Array_Type_Definition
+           | Iir_Kind_Array_Subtype_Definition =>
+            null;
+         when others =>
+            Failed ("Index_Constraint_Flag", Target);
+      end case;
+   end Check_Kind_For_Index_Constraint_Flag;
+
+   function Get_Index_Constraint_Flag (Atype : Iir) return Boolean is
+   begin
+      Check_Kind_For_Index_Constraint_Flag (Atype);
+      return Get_Flag4 (Atype);
+   end Get_Index_Constraint_Flag;
+
+   procedure Set_Index_Constraint_Flag (Atype : Iir; Flag : Boolean) is
+   begin
+      Check_Kind_For_Index_Constraint_Flag (Atype);
+      Set_Flag4 (Atype, Flag);
+   end Set_Index_Constraint_Flag;
+
    procedure Check_Kind_For_Assertion_Condition (Target : Iir) is
    begin
       case Get_Kind (Target) is
@@ -4963,6 +5051,7 @@
            | Iir_Kind_Block_Configuration
            | Iir_Kind_Component_Configuration
            | Iir_Kind_Procedure_Call
+           | Iir_Kind_Record_Element_Constraint
            | Iir_Kind_Attribute_Specification
            | Iir_Kind_Disconnection_Specification
            | Iir_Kind_Configuration_Specification
@@ -6261,7 +6350,6 @@
    begin
       case Get_Kind (Target) is
          when Iir_Kind_File_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition
            | Iir_Kind_Array_Subtype_Definition
            | Iir_Kind_Record_Subtype_Definition
            | Iir_Kind_Access_Subtype_Definition
diff -urN ghdl-0.27/vhdl/iirs.ads ghdl-0.28dev/vhdl/iirs.ads
--- ghdl-0.27/vhdl/iirs.ads	2007-03-28 00:41:02.000000000 +0200
+++ ghdl-0.28dev/vhdl/iirs.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Ada.Unchecked_Deallocation;
@@ -865,7 +865,7 @@
    --
    -- Subprogram declaration.
    --
-   -- The declaration containing this type declaration.
+   -- The declaration containing this subrogram declaration.
    --   Get/Set_Parent (Field0)
    --
    -- Only for Iir_Kind_Function_Declaration:
@@ -913,10 +913,12 @@
    -- Only for Iir_Kind_Function_Declaration:
    --   Get/Set_Resolution_Function_Flag (Flag7)
    --
+   --   Get/Set_Wait_State (State1)
+   --
    -- Only for Iir_Kind_Procedure_Declaration:
    --   Get/Set_Purity_State (State2)
    --
-   --   Get/Set_Wait_State (State1)
+   --   Get/Set_All_Sensitized_State (State3)
 
    -- Iir_Kind_Function_Body (Short)
    -- Iir_Kind_Procedure_Body (Short)
@@ -1159,7 +1161,22 @@
    --
    --   Get/Set_Type (Field1)
    --
-   --   Get/Set_Chain (Field2)
+   --   Get/Set_Identifier (Field3)
+   --
+   -- Return the position of the element in the record, starting from 0 for the
+   -- first record element, increasing by one for each successive element.
+   --   Get/Set_Element_Position (Field4)
+   --
+   --   Get/Set_Visible_Flag (Flag4)
+
+   -- Iir_Kind_Record_Element_Constraint (Short)
+   --
+   -- Record subtype definition which defines this constraint.
+   --   Get/Set_Parent (Field0)
+   --
+   --   Get/Set_Type (Field1)
+   --
+   --   Get/Set_Element_Declaration (Field2)
    --
    --   Get/Set_Identifier (Field3)
    --
@@ -1287,6 +1304,8 @@
    --
    --   Get/Set_Has_Signal_Flag (Flag3)
    --
+   --   Get/Set_Only_Characters_Flag (Flag4)
+   --
    --   Get/Set_Type_Staticness (State1)
 
    -- Iir_Kind_Enumeration_Literal (Medium)
@@ -1389,17 +1408,19 @@
    --
    --   Get/Set_Type_Staticness (State1)
    --
+   --   Get/Set_Constraint_State (State2)
+   --
    --   Get/Set_Resolved_Flag (Flag1)
    --
    --   Get/Set_Signal_Type_Flag (Flag2)
    --
    --   Get/Set_Has_Signal_Flag (Flag3)
+   --
+   --   Get/Set_Index_Constraint_Flag (Flag4)
 
    -- Iir_Kind_Record_Type_Definition (Short)
    --
-   --   Get/Set_Number_Element_Declaration (Field1)
-   --
-   --   Get/Set_Element_Declaration_Chain (Field2)
+   --   Get/Set_Elements_Declaration_List (Field1)
    --
    --   Get/Set_Type_Declarator (Field3)
    --
@@ -1407,6 +1428,8 @@
    --
    --   Get/Set_Type_Staticness (State1)
    --
+   --   Get/Set_Constraint_State (State2)
+   --
    --   Get/Set_Resolved_Flag (Flag1)
    --
    --   Get/Set_Signal_Type_Flag (Flag2)
@@ -1541,6 +1564,8 @@
 
    -- Iir_Kind_Record_Subtype_Definition (Short)
    --
+   --   Get/Set_Elements_Declaration_List (Field1)
+   --
    --   Get/Set_Type_Mark (Field2)
    --
    --   Get/Set_Type_Declarator (Field3)
@@ -1556,18 +1581,10 @@
    --   Get/Set_Has_Signal_Flag (Flag3)
    --
    --   Get/Set_Type_Staticness (State1)
+   --
+   --   Get/Set_Constraint_State (State2)
 
    -- Iir_Kind_Array_Subtype_Definition (Medium)
-   -- Iir_Kind_Unconstrained_Array_Subtype_Definition (Medium)
-   --
-   -- Iir_Kind_Array_Subtype_definition defines a constrained array
-   -- subtype, which *must* be a subtype of an iir_array_type_definition.
-   --
-   -- Iir_Kind_Unconstrained_Array_Subtype_Definition defines a
-   -- unconstrained array subtype, which *must* be a subtype of an
-   -- iir_array_type_definition.  The only way to create such a
-   -- subtype is via a subtype declaration, without adding
-   -- constraints.
    --
    --   Get/Set_Element_Subtype (Field1)
    --
@@ -1583,11 +1600,15 @@
    --
    --   Get/Set_Type_Staticness (State1)
    --
+   --   Get/Set_Constraint_State (State2)
+   --
    --   Get/Set_Resolved_Flag (Flag1)
    --
    --   Get/Set_Signal_Type_Flag (Flag2)
    --
    --   Get/Set_Has_Signal_Flag (Flag3)
+   --
+   --   Get/Set_Index_Constraint_Flag (Flag4)
 
    -- Iir_Kind_Range_Expression (Short)
    --
@@ -2489,6 +2510,7 @@
        Iir_Kind_Aggregate_Info,
        Iir_Kind_Procedure_Call,
        Iir_Kind_Operator_Symbol,
+       Iir_Kind_Record_Element_Constraint,
 
        Iir_Kind_Attribute_Specification,
        Iir_Kind_Disconnection_Specification,
@@ -2503,7 +2525,6 @@
        Iir_Kind_Protected_Type_Declaration,
        Iir_Kind_Record_Type_Definition,                 -- composite
        Iir_Kind_Array_Type_Definition,                  -- composite, array
-       Iir_Kind_Unconstrained_Array_Subtype_Definition, -- composite, array, st
        Iir_Kind_Array_Subtype_Definition,               -- composite, array, st
        Iir_Kind_Record_Subtype_Definition,              -- composite, st
        Iir_Kind_Access_Subtype_Definition,              -- st
@@ -2911,9 +2932,13 @@
        Iir_Predefined_File_Close,
        Iir_Predefined_Read,
        Iir_Predefined_Read_Length,
+       Iir_Predefined_Flush,
        Iir_Predefined_Write,
        Iir_Predefined_Endfile,
 
+   --  To_String
+       Iir_Predefined_Array_To_String,
+
    --  Predefined function.
        Iir_Predefined_Now_Function
        );
@@ -2973,6 +2998,28 @@
    --    PURE.
    type Iir_Pure_State is (Unknown, Pure, Maybe_Impure, Impure);
 
+   --  State of subprograms for validity of use in all-sensitized process.
+   --  INVALID_SIGNAL means that the subprogram is in a package and
+   --    reads a signal or that the subprogram calls (indirectly) such
+   --    a subprogram.  In this case, the subprogram cannot be called from
+   --    an all-sensitized process.
+   --  READ_SIGNAL means that the subprogram reads a signal and is defined
+   --    in an entity or an architecture or that the subprogram calls
+   --    (indirectly) such a subprogram.  In this case, the subprogram can
+   --    be called from an all-sensitized process and the reference will be
+   --    part of the sensitivity list.
+   --  NO_SIGNAL means that the subprogram doesn't read any signal and don't
+   --    call such a subprogram.  The subprogram can be called from an
+   --    all-sensitized process but there is no need to track this call.
+   --  UNKNOWN means that the state is not yet defined.
+   type Iir_All_Sensitized is
+     (Unknown, No_Signal, Read_Signal, Invalid_Signal);
+
+   --  Constraint state of a type.
+   --  See LRM08 5.1 for definition.
+   type Iir_Constraint is
+     (Unconstrained, Partially_Constrained, Fully_Constrained);
+
    ---------------
    -- subranges --
    ---------------
@@ -3011,7 +3058,6 @@
 
    subtype Iir_Kinds_Array_Type_Definition is Iir_Kind range
      Iir_Kind_Array_Type_Definition ..
-   --Iir_Kind_Unconstrained_Array_Subtype_Definition
      Iir_Kind_Array_Subtype_Definition;
 
    subtype Iir_Kinds_Type_And_Subtype_Definition is Iir_Kind range
@@ -3021,7 +3067,6 @@
    --Iir_Kind_Protected_Type_Declaration
    --Iir_Kind_Record_Type_Definition
    --Iir_Kind_Array_Type_Definition
-   --Iir_Kind_Unconstrained_Array_Subtype_Definition
    --Iir_Kind_Array_Subtype_Definition
    --Iir_Kind_Record_Subtype_Definition
    --Iir_Kind_Access_Subtype_Definition
@@ -3035,8 +3080,7 @@
      Iir_Kind_Physical_Type_Definition;
 
    subtype Iir_Kinds_Subtype_Definition is Iir_Kind range
-     Iir_Kind_Unconstrained_Array_Subtype_Definition ..
-   --Iir_Kind_Array_Subtype_Definition
+     Iir_Kind_Array_Subtype_Definition ..
    --Iir_Kind_Record_Subtype_Definition
    --Iir_Kind_Access_Subtype_Definition
    --Iir_Kind_Physical_Subtype_Definition
@@ -3068,18 +3112,9 @@
    subtype Iir_Kinds_Composite_Type_Definition is Iir_Kind range
      Iir_Kind_Record_Type_Definition ..
    --Iir_Kind_Array_Type_Definition
-   --Iir_Kind_Unconstrained_Array_Subtype_Definition
    --Iir_Kind_Array_Subtype_Definition
      Iir_Kind_Record_Subtype_Definition;
 
-   subtype Iir_Kinds_Unconstrained_Array_Type_Definition is Iir_Kind range
-     Iir_Kind_Array_Type_Definition ..
-     Iir_Kind_Unconstrained_Array_Subtype_Definition;
-
-   subtype Iir_Kinds_Array_Subtype_Definition is Iir_Kind range
-     Iir_Kind_Unconstrained_Array_Subtype_Definition ..
-     Iir_Kind_Array_Subtype_Definition;
-
    subtype Iir_Kinds_Type_Declaration is Iir_Kind range
      Iir_Kind_Type_Declaration ..
    --Iir_Kind_Anonymous_Type_Declaration
@@ -3527,8 +3562,6 @@
 
    subtype Iir_Array_Subtype_Definition is Iir;
 
-   subtype Iir_Unconstrained_Array_Subtype_Definition is Iir;
-
    subtype Iir_Physical_Type_Definition is Iir;
 
    subtype Iir_Physical_Subtype_Definition is Iir;
@@ -4301,6 +4334,10 @@
    procedure Set_Element_Position (Target : Iir; Pos : Iir_Index32);
 
    --  Field: Field2
+   function Get_Element_Declaration (Target : Iir) return Iir;
+   procedure Set_Element_Declaration (Target : Iir; El : Iir);
+
+   --  Field: Field2
    function Get_Selected_Element (Target : Iir) return Iir;
    procedure Set_Selected_Element (Target : Iir; El : Iir);
 
@@ -4400,10 +4437,19 @@
    function Get_Text_File_Flag (Atype : Iir) return Boolean;
    procedure Set_Text_File_Flag (Atype : Iir; Flag : Boolean);
 
+   --  True if enumeration type ATYPE has only character literals.
+   --  Field: Flag4
+   function Get_Only_Characters_Flag (Atype : Iir) return Boolean;
+   procedure Set_Only_Characters_Flag (Atype : Iir; Flag : Boolean);
+
    --  Field: State1 (pos)
    function Get_Type_Staticness (Atype : Iir) return Iir_Staticness;
    procedure Set_Type_Staticness (Atype : Iir; Static : Iir_Staticness);
 
+   --  Field: State2 (pos)
+   function Get_Constraint_State (Atype : Iir) return Iir_Constraint;
+   procedure Set_Constraint_State (Atype : Iir; State : Iir_Constraint);
+
    --  Field: Field6 (uc)
    function Get_Index_Subtype_List (Decl : Iir) return Iir_List;
    procedure Set_Index_Subtype_List (Decl : Iir; List : Iir_List);
@@ -4417,14 +4463,9 @@
    procedure Set_Element_Subtype (Decl : Iir; Sub_Type : Iir);
 
    --  Chains of elements of a record.
-   --  Field: Field2
-   function Get_Element_Declaration_Chain (Decl : Iir) return Iir;
-   procedure Set_Element_Declaration_Chain (Decl : Iir; Chain : Iir);
-
-   --  Number of elements in the record.
    --  Field: Field1 (uc)
-   function Get_Number_Element_Declaration (Decl : Iir) return Iir_Index32;
-   procedure Set_Number_Element_Declaration (Decl : Iir; Val : Iir_Index32);
+   function Get_Elements_Declaration_List (Decl : Iir) return Iir_List;
+   procedure Set_Elements_Declaration_List (Decl : Iir; List : Iir_List);
 
    --  Field: Field2
    function Get_Designated_Type (Target : Iir) return Iir;
@@ -4498,6 +4539,18 @@
    function Get_Wait_State (Proc : Iir) return Tri_State_Type;
    procedure Set_Wait_State (Proc : Iir; State : Tri_State_Type);
 
+   --  Get/Set wether the subprogram may be called by a sensitized process
+   --  whose sensitivity list is ALL.
+   --  FALSE if declared in a package unit and reads a signal that is not
+   --    one of its interface, or if it calls such a subprogram.
+   --  TRUE if it doesn't call a subprogram whose state is False and
+   --    either doesn't read a signal or declared within an entity or
+   --    architecture.
+   --  UNKNOWN if the status is not yet known.
+   --  Field: State3 (pos)
+   function Get_All_Sensitized_State (Proc : Iir) return Iir_All_Sensitized;
+   procedure Set_All_Sensitized_State (Proc : Iir; State : Iir_All_Sensitized);
+
    --  Get/Set the seen flag.
    --  Used when the graph of callees is walked, to avoid infinite loops, since
    --  the graph is not a DAG (there may be cycles).
@@ -4550,6 +4603,12 @@
    function Get_Elab_Flag (Design : Iir) return Boolean;
    procedure Set_Elab_Flag (Design : Iir; Flag : Boolean);
 
+   --  Set on an array_subtype if there is an index constraint.
+   --  If not set, the subtype is unconstrained.
+   --  Field: Flag4
+   function Get_Index_Constraint_Flag (Atype : Iir) return Boolean;
+   procedure Set_Index_Constraint_Flag (Atype : Iir; Flag : Boolean);
+
    --  Condition of an assertion.
    --  Field: Field1
    function Get_Assertion_Condition (Target : Iir) return Iir;
diff -urN ghdl-0.27/vhdl/iirs_utils.adb ghdl-0.28dev/vhdl/iirs_utils.adb
--- ghdl-0.27/vhdl/iirs_utils.adb	2007-09-19 00:08:18.000000000 +0200
+++ ghdl-0.28dev/vhdl/iirs_utils.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,17 +12,16 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
-with Types; use Types;
 with Scan; use Scan;
 with Tokens; use Tokens;
 with Errorout; use Errorout;
 with Name_Table;
 with Str_Table;
 with Std_Names; use Std_Names;
-with Flags;
+with Flags; use Flags;
 
 package body Iirs_Utils is
    -- Transform the current token into an iir literal.
@@ -514,10 +513,11 @@
       return Get_Type_Declarator (Def) = Null_Iir;
    end Is_Anonymous_Type_Definition;
 
-   function Is_Unconstrained_Type_Definition (Def : Iir) return Boolean is
+   function Is_Fully_Constrained_Type (Def : Iir) return Boolean is
    begin
-      return Get_Kind (Def) in Iir_Kinds_Unconstrained_Array_Type_Definition;
-   end Is_Unconstrained_Type_Definition;
+      return Get_Kind (Def) not in Iir_Kinds_Composite_Type_Definition
+        or else Get_Constraint_State (Def) = Fully_Constrained;
+   end Is_Fully_Constrained_Type;
 
    function Is_Same_Profile (L, R: Iir) return Boolean
    is
@@ -653,7 +653,7 @@
 
    function Is_Unidim_Array_Type (A_Type : Iir) return Boolean
    is
-      Base_Type : Iir := Get_Base_Type (A_Type);
+      Base_Type : constant Iir := Get_Base_Type (A_Type);
    begin
       if Get_Kind (Base_Type) = Iir_Kind_Array_Type_Definition
         and then Get_Nbr_Elements (Get_Index_Subtype_List (Base_Type)) = 1
@@ -838,6 +838,4 @@
          end case;
       end loop;
    end Is_Signal_Object;
-
-
 end Iirs_Utils;
diff -urN ghdl-0.27/vhdl/iirs_utils.ads ghdl-0.28dev/vhdl/iirs_utils.ads
--- ghdl-0.27/vhdl/iirs_utils.ads	2006-09-25 15:52:03.000000000 +0200
+++ ghdl-0.28dev/vhdl/iirs_utils.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
@@ -87,8 +87,8 @@
    function Is_Anonymous_Type_Definition (Def : Iir) return Boolean;
    pragma Inline (Is_Anonymous_Type_Definition);
 
-   --  Return TRUE iff DEF is an unconstrained type (or subtype) definition.
-   function Is_Unconstrained_Type_Definition (Def : Iir) return Boolean;
+   --  Return TRUE iff DEF is a fully constrained type (or subtype) definition.
+   function Is_Fully_Constrained_Type (Def : Iir) return Boolean;
 
    --  Return true iff L and R have the same profile.
    --  L and R must be subprograms specification (or spec_body).
diff -urN ghdl-0.27/vhdl/lang.opt ghdl-0.28dev/vhdl/lang.opt
--- ghdl-0.27/vhdl/lang.opt	2006-09-04 06:08:17.000000000 +0200
+++ ghdl-0.28dev/vhdl/lang.opt	2009-09-20 09:06:45.000000000 +0200
@@ -76,3 +76,11 @@
 l
 vhdl Joined Separate
 -l<filename>	Put list of files for link in <filename>
+
+C
+vhdl
+Allow any character in comments
+
+-mb-comments
+vhdl
+Allow any character in comments
\ No newline at end of file
diff -urN ghdl-0.27/vhdl/libraries/std/textio_body.vhdl ghdl-0.28dev/vhdl/libraries/std/textio_body.vhdl
--- ghdl-0.27/vhdl/libraries/std/textio_body.vhdl	2006-06-20 03:01:56.000000000 +0200
+++ ghdl-0.28dev/vhdl/libraries/std/textio_body.vhdl	2009-09-20 09:06:45.000000000 +0200
@@ -1305,9 +1305,17 @@
       return;
     end if;
     if l'left < l'right then
+      --  Ascending (expected common case).
       value := l (l'left to l'left + len - 1);
       trim (l, l'left + len);
+    elsif l'left = l'right then
+      --  String of 1 character.  We don't know the direction and therefore
+      --  can't use the code below which does a slice.
+      value := l.all;
+      deallocate (l);
+      l := new string'("");
     else
+      --  Descending.
       value := l (l'left downto l'left - len + 1);
       trim (l, l'left - len);
     end if;
diff -urN ghdl-0.27/vhdl/libraries.adb ghdl-0.28dev/vhdl/libraries.adb
--- ghdl-0.27/vhdl/libraries.adb	2008-06-16 06:41:40.000000000 +0200
+++ ghdl-0.28dev/vhdl/libraries.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Ada.Text_IO; use Ada.Text_IO;
@@ -29,7 +29,6 @@
 with Tokens;
 with Files_Map;
 with Flags;
-with Std_Names;
 with Std_Package;
 
 package body Libraries is
@@ -114,7 +113,7 @@
                                    Library: Iir_Library_Declaration)
      return Boolean
    is
-      File_Name : String := Back_End.Library_To_File_Name (Library);
+      File_Name : constant String := Back_End.Library_To_File_Name (Library);
       Fe : Source_File_Entry;
    begin
       Fe := Files_Map.Load_Source_File (Dir, Get_Identifier (File_Name));
@@ -362,7 +361,8 @@
       if Dir = Null_Identifier then
          --  Search in the library path.
          declare
-            File_Name : String := Back_End.Library_To_File_Name (Library);
+            File_Name : constant String :=
+              Back_End.Library_To_File_Name (Library);
             L : Natural;
          begin
             for I in Pathes.First .. Pathes.Last loop
@@ -580,7 +580,6 @@
    procedure Create_Virtual_Locations
    is
       use Files_Map;
-      use Name_Table;
       Implicit_Source_File : Source_File_Entry;
       Command_Source_File : Source_File_Entry;
    begin
@@ -1038,6 +1037,7 @@
             end if;
             Design_File := Get_Chain (Design_File);
          end loop;
+         Last_Design_File := Design_File;
       end if;
 
       if Design_File /= Null_Iir
@@ -1140,7 +1140,7 @@
       -- FIXME: directory
       declare
          use Files_Map;
-         File_Name: String := Image (Work_Directory)
+         File_Name: constant String := Image (Work_Directory)
            & Back_End.Library_To_File_Name (Library);
       begin
          Create (File, Out_File, File_Name);
@@ -1415,7 +1415,6 @@
       Line, Off: Natural;
       Pos: Source_Ptr;
       Res: Iir;
-      Library : Iir_Library_Declaration;
       Design_File : Iir_Design_File;
       Fe : Source_File_Entry;
    begin
@@ -1425,7 +1424,6 @@
 
       --  Load and parse the unit.
       Design_File := Get_Design_File (Design_Unit);
-      Library := Get_Library (Design_File);
       Fe := Files_Map.Load_Source_File
         (Get_Design_File_Directory (Design_File),
          Get_Design_File_Filename (Design_File));
diff -urN ghdl-0.27/vhdl/libraries.ads ghdl-0.28dev/vhdl/libraries.ads
--- ghdl-0.27/vhdl/libraries.ads	2005-12-12 02:59:35.000000000 +0100
+++ ghdl-0.28dev/vhdl/libraries.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
diff -urN ghdl-0.27/vhdl/lists.adb ghdl-0.28dev/vhdl/lists.adb
--- ghdl-0.27/vhdl/lists.adb	2005-09-22 23:29:51.000000000 +0200
+++ ghdl-0.28dev/vhdl/lists.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with System;
@@ -36,11 +36,11 @@
       Table_Initial => 128,
       Table_Increment => 100);
 
-   function Get_Max_Nbr_Elements (List : List_Type) return Natural;
-   pragma Inline (Get_Max_Nbr_Elements);
+   --function Get_Max_Nbr_Elements (List : List_Type) return Natural;
+   --pragma Inline (Get_Max_Nbr_Elements);
 
-   procedure Set_Max_Nbr_Elements (List : List_Type; Max : Natural);
-   pragma Inline (Set_Max_Nbr_Elements);
+   --procedure Set_Max_Nbr_Elements (List : List_Type; Max : Natural);
+   --pragma Inline (Set_Max_Nbr_Elements);
 
    procedure List_Set_Nbr_Elements (List : List_Type; Nbr : Natural);
    pragma Inline (List_Set_Nbr_Elements);
@@ -55,15 +55,15 @@
       Listt.Table (List).Nbr := Nbr;
    end List_Set_Nbr_Elements;
 
-   function Get_Max_Nbr_Elements (List : List_Type) return Natural is
-   begin
-      return Listt.Table (List).Max;
-   end Get_Max_Nbr_Elements;
-
-   procedure Set_Max_Nbr_Elements (List : List_Type; Max : Natural) is
-   begin
-      Listt.Table (List).Max := Max;
-   end Set_Max_Nbr_Elements;
+   --function Get_Max_Nbr_Elements (List : List_Type) return Natural is
+   --begin
+   --   return Listt.Table (List).Max;
+   --end Get_Max_Nbr_Elements;
+
+   --procedure Set_Max_Nbr_Elements (List : List_Type; Max : Natural) is
+   --begin
+   --   Listt.Table (List).Max := Max;
+   --end Set_Max_Nbr_Elements;
 
    function Get_Nth_Element (List: List_Type; N: Natural)
      return Node_Type
@@ -152,7 +152,7 @@
    -- Add (append) an element only if it was not already present in the list.
    procedure Add_Element (List: List_Type; El: Node_Type)
    is
-      Nbr : Natural := Get_Nbr_Elements (List);
+      Nbr : constant Natural := Get_Nbr_Elements (List);
    begin
       for I in 0 .. Nbr - 1 loop
          if Listt.Table (List).Els (I) = El then
@@ -165,7 +165,7 @@
 
    procedure Remove_Nth_Element (List: List_Type; N: Natural)
    is
-      Nbr : Natural := Get_Nbr_Elements (List);
+      Nbr : constant Natural := Get_Nbr_Elements (List);
    begin
       if N >= Nbr then
          raise Program_Error;
diff -urN ghdl-0.27/vhdl/lists.ads ghdl-0.28dev/vhdl/lists.ads
--- ghdl-0.27/vhdl/lists.ads	2005-09-22 23:13:36.000000000 +0200
+++ ghdl-0.28dev/vhdl/lists.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
diff -urN ghdl-0.27/vhdl/Makefile.in ghdl-0.28dev/vhdl/Makefile.in
--- ghdl-0.27/vhdl/Makefile.in	2008-07-01 01:59:58.000000000 +0200
+++ ghdl-0.28dev/vhdl/Makefile.in	2009-09-20 09:07:53.000000000 +0200
@@ -80,7 +80,6 @@
 X_ADAFLAGS =
 T_ADAFLAGS =
 
-CC = cc
 ADAC = $(CC)
 
 ECHO = echo
@@ -251,35 +250,44 @@
 
 STD87_BSRCS := $(STD_SRCS:.vhdl=.v87)
 STD93_BSRCS := $(STD_SRCS:.vhdl=.v93)
+STD08_BSRCS := $(STD_SRCS:.vhdl=.v08)
 IEEE87_BSRCS := $(IEEE_SRCS:.vhdl=.v87)
 IEEE93_BSRCS := $(IEEE_SRCS:.vhdl=.v93) $(MATH_SRCS)
 SYNOPSYS87_BSRCS := $(SYNOPSYS_BSRCS)
 SYNOPSYS93_BSRCS := $(SYNOPSYS_BSRCS)
 MENTOR93_BSRCS := $(MENTOR_BSRCS)
 
-.PREFIXES: .vhdl .v93 .v87
+.PREFIXES: .vhdl .v93 .v87 .v08
 
 %.v93: %.vhdl
 	sed -e '/--V87/s/^/  --/' < $< > $@
 
+%.v08: %.vhdl
+	sed -e '/--V87/s/^/  --/' < $< > $@
+
 %.v87: %.vhdl
 	sed -e '/--V93/s/^/  --/' -e '/--START-V93/,/--END-V93/s/^/--/' \
 	  < $< > $@
 
+STD87_DIR:=$(LIB87_DIR)/std
+IEEE87_DIR:=$(LIB87_DIR)/ieee
+SYN87_DIR:=$(LIB87_DIR)/synopsys
+
 STD93_DIR:=$(LIB93_DIR)/std
 IEEE93_DIR:=$(LIB93_DIR)/ieee
 SYN93_DIR:=$(LIB93_DIR)/synopsys
 MENTOR93_DIR:=$(LIB93_DIR)/mentor
 
-STD87_DIR:=$(LIB87_DIR)/std
-IEEE87_DIR:=$(LIB87_DIR)/ieee
-SYN87_DIR:=$(LIB87_DIR)/synopsys
+STD08_DIR:=$(LIB08_DIR)/std
 
-ANALYZE93:=$(ANALYZE) --std=93
 ANALYZE87:=$(ANALYZE) --std=87
+ANALYZE93:=$(ANALYZE) --std=93
+ANALYZE08:=$(ANALYZE) --std=08
 
 STD87_SRCS=$(addprefix $(LIBSRC_DIR)/,$(STD87_BSRCS))
 STD93_SRCS=$(addprefix $(LIBSRC_DIR)/,$(STD93_BSRCS))
+STD08_SRCS=$(addprefix $(LIBSRC_DIR)/,$(STD08_BSRCS))
+
 IEEE93_SRCS=$(addprefix $(LIBSRC_DIR)/,$(IEEE93_BSRCS))
 IEEE87_SRCS=$(addprefix $(LIBSRC_DIR)/,$(IEEE87_BSRCS))
 SYNOPSYS_SRCS=$(addprefix $(LIBSRC_DIR)/,$(SYNOPSYS_BSRCS))
@@ -375,6 +383,16 @@
 	done; \
 	cd $$prev
 
+std.v08: $(LIB08_DIR) $(STD08_SRCS) force
+	$(RM) -rf $(STD08_DIR)
+	mkdir $(STD08_DIR)
+	prev=`pwd`; cd $(STD08_DIR); \
+	for i in $(STD08_SRCS); do \
+	  echo $$i; \
+	  $(ANALYZE08) --bootstrap --work=std $(REL_DIR)/$$i || exit 1; \
+	done; \
+	cd $$prev
+
 std87_standard.o: $(GHDL1)
 	$(GHDL1) --std=87 -quiet -o std_standard.s --compile-standard
 	../xgcc -c -o std_standard.o std_standard.s
@@ -432,7 +450,8 @@
 # manufacturer, and operating system and assign each of those to its own
 # variable.
 
-targ:=$(subst -, ,$(target))
+target1:=$(subst -gnu,,$(target))
+targ:=$(subst -, ,$(target1))
 arch:=$(word 1,$(targ))
 ifeq ($(words $(targ)),2)
   osys:=$(word 2,$(targ))
@@ -512,10 +531,15 @@
 	$(GRT_RANLIB) $@
 
 run-bind.adb: grt-force
-	gnatmake -c $(GNATFLAGS) -aI$(GRTSRCDIR) $(GRT_PRAGMA_FLAG) ghdl_main \
-	  $(GRT_ADAFLAGS) -cargs $(GRT_FLAGS)
+	gnatmake -c $(GNATFLAGS) -aI$(GRTSRCDIR) $(GRT_PRAGMA_FLAG) \
+	  ghdl_main $(GRT_ADAFLAGS) -cargs $(GRT_FLAGS)
 	gnatbind -Lgrt_ -o run-bind.adb -n ghdl_main.ali
 
+#system.ads:
+#	sed -e "/Configurable_Run_Time/s/False/True/" \
+#	 -e "/Suppress_Standard_Library/s/False/True/" \
+#	  < `$(ADAC) -print-file-name=adainclude/system.ads` > $@
+
 run-bind.o: run-bind.adb
 	$(GRT_ADACOMPILE)
 
diff -urN ghdl-0.27/vhdl/Make-lang.in ghdl-0.28dev/vhdl/Make-lang.in
--- ghdl-0.27/vhdl/Make-lang.in	2008-07-01 01:59:58.000000000 +0200
+++ ghdl-0.28dev/vhdl/Make-lang.in	2009-09-20 09:07:53.000000000 +0200
@@ -98,24 +98,16 @@
  -I$(AGCC_GCCSRC_DIR)/libcpp/include
 AGCC_CFLAGS=-g -Wall -DIN_GCC $(AGCC_INC_FLAGS)
 
-AGCC_LOCAL_OBJS=ortho-lang.o gcc-version.o
+AGCC_LOCAL_OBJS=ortho-lang.o
 
 AGCC_DEPS := $(AGCC_LOCAL_OBJS)
 AGCC_OBJS := $(AGCC_LOCAL_OBJS) \
 	$(AGCC_GCCOBJ_DIR)gcc/toplev.o \
+	$(AGCC_GCCOBJ_DIR)gcc/attribs.o \
 	$(AGCC_GCCOBJ_DIR)gcc/libbackend.a \
 	$(AGCC_GCCOBJ_DIR)libcpp/libcpp.a \
 	$(AGCC_GCCOBJ_DIR)libiberty/libiberty.a
 
-gcc-version.c: $(AGCC_GCCSRC_DIR)/gcc/BASE-VER
-	-$(RM) -f $@
-	echo '#include "version.h"' > $@
-	echo "const char version_string[] = \""`cat $<` "(ghdl)\";" >> $@
-	echo 'const char bug_report_url[] = "<URL:http://gna.org/projects/ghdl>";' >> $@
-
-gcc-version.o: gcc-version.c
-	$(CC) -c -o $@ $< $(AGCC_CFLAGS)
-
 ortho-lang.o: $(agcc_srcdir)/ortho-lang.c \
  $(AGCC_GCCOBJ_DIR)gcc/gtype-vhdl.h \
  $(AGCC_GCCOBJ_DIR)gcc/gt-vhdl-ortho-lang.h
@@ -140,7 +132,7 @@
 	 -cargs $(CFLAGS) $(GHDL_ADAFLAGS)
 	$(GNATMAKE) -o $@ -aI$(srcdir)/vhdl -aOvhdl ortho_gcc-main \
 	 -bargs -E -cargs $(CFLAGS) $(GHDL_ADAFLAGS) \
-	 -largs $(AGCC_OBJS) $(LIBS)
+	 -largs $(AGCC_OBJS) $(LIBS) $(GMPLIBS)
 
 # The driver for ghdl.
 ghdl$(exeext): force
diff -urN ghdl-0.27/vhdl/name_table.adb ghdl-0.28dev/vhdl/name_table.adb
--- ghdl-0.27/vhdl/name_table.adb	2005-09-22 23:30:00.000000000 +0200
+++ ghdl-0.28dev/vhdl/name_table.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Ada.Text_IO; use Ada.Text_IO;
@@ -89,9 +89,10 @@
       if Names_Table.Allocate /= Null_Identifier then
          raise Program_Error;
       end if;
+      Strings_Table.Set_Last (1);
       Names_Table.Table (Null_Identifier) := (Length => 0,
                                               Hash => 0,
-                                              Name => 0,
+                                              Name => 1,
                                               Next => Null_Identifier,
                                               Info => 0);
       -- Store characters.
diff -urN ghdl-0.27/vhdl/name_table.ads ghdl-0.28dev/vhdl/name_table.ads
--- ghdl-0.27/vhdl/name_table.ads	2005-09-22 23:13:46.000000000 +0200
+++ ghdl-0.28dev/vhdl/name_table.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with System;
diff -urN ghdl-0.27/vhdl/nodes.adb ghdl-0.28dev/vhdl/nodes.adb
--- ghdl-0.27/vhdl/nodes.adb	2006-08-19 23:27:50.000000000 +0200
+++ ghdl-0.28dev/vhdl/nodes.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with GNAT.Table;
@@ -45,10 +45,13 @@
 
    Free_Chain : Node_Type := Null_Node;
 
+   --  Just to have the default value.
+   pragma Warnings (Off);
    Init_Short  : Node_Record (Format_Short);
    Init_Medium : Node_Record (Format_Medium);
    Init_Fp     : Node_Record (Format_Fp);
    Init_Int    : Node_Record (Format_Int);
+   pragma Warnings (On);
 
    function Create_Node (Format : Format_Type) return Node_Type
    is
diff -urN ghdl-0.27/vhdl/nodes.ads ghdl-0.28dev/vhdl/nodes.ads
--- ghdl-0.27/vhdl/nodes.ads	2006-08-19 23:36:44.000000000 +0200
+++ ghdl-0.28dev/vhdl/nodes.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
@@ -83,7 +83,7 @@
 
    -- Fields of Format_Medium:
    --   Odigit1 : Bit3_Type
-   --   Odigit2 : Bit3_Type
+   --   Odigit2 : Bit3_Type (odigit1)
    --   State3 : Bit2_Type
    --   State4 : Bit2_Type
    --   Field4 : Iir
diff -urN ghdl-0.27/vhdl/options.adb ghdl-0.28dev/vhdl/options.adb
--- ghdl-0.27/vhdl/options.adb	1970-01-01 01:00:00.000000000 +0100
+++ ghdl-0.28dev/vhdl/options.adb	2009-09-20 09:06:46.000000000 +0200
@@ -0,0 +1,221 @@
+--  Command line options.
+--  Copyright (C) 2008 Tristan Gingold
+--
+--  GHDL is free software; you can redistribute it and/or modify it under
+--  the terms of the GNU General Public License as published by the Free
+--  Software Foundation; either version 2, or (at your option) any later
+--  version.
+--
+--  GHDL is distributed in the hope that it will be useful, but WITHOUT ANY
+--  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+--  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+--  for more details.
+--
+--  You should have received a copy of the GNU General Public License
+--  along with GHDL; see the file COPYING.  If not, write to the Free
+--  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+--  02111-1307, USA.
+with Ada.Text_IO; use Ada.Text_IO;
+with Name_Table;
+with Libraries;
+with Scan;
+with Back_End; use Back_End;
+with Flags; use Flags;
+
+package body Options is
+   function Option_Warning (Opt: String; Val : Boolean) return Boolean is
+   begin
+--      if Opt = "undriven" then
+--         Warn_Undriven := True;
+      if Opt = "library" then
+         Warn_Library := Val;
+      elsif Opt = "default-binding" then
+         Warn_Default_Binding := Val;
+      elsif Opt = "binding" then
+         Warn_Binding := Val;
+      elsif Opt = "reserved" then
+         Warn_Reserved_Word := Val;
+      elsif Opt = "vital-generic" then
+         Warn_Vital_Generic := Val;
+      elsif Opt = "delayed-checks" then
+         Warn_Delayed_Checks := Val;
+      elsif Opt = "body" then
+         Warn_Body := Val;
+      elsif Opt = "specs" then
+         Warn_Specs := Val;
+      elsif Opt = "unused" then
+         Warn_Unused := Val;
+      elsif Opt = "error" then
+         Warn_Error := Val;
+      else
+         return False;
+      end if;
+      return True;
+   end Option_Warning;
+
+   function Parse_Option (Opt: String) return Boolean
+   is
+      Beg: constant Integer := Opt'First;
+   begin
+      if Opt'Length > 5 and then Opt (Beg .. Beg + 5) = "--std=" then
+         if Opt'Length = 8 then
+            if Opt (Beg + 6 .. Beg + 7) = "87" then
+               Vhdl_Std := Vhdl_87;
+            elsif Opt (Beg + 6 .. Beg + 7) = "93" then
+               Vhdl_Std := Vhdl_93;
+            elsif Opt (Beg + 6 .. Beg + 7) = "00" then
+               Vhdl_Std := Vhdl_00;
+            elsif Opt (Beg + 6 .. Beg + 7) = "02" then
+               Vhdl_Std := Vhdl_02;
+            elsif Opt (Beg + 6 .. Beg + 7) = "08" then
+               Vhdl_Std := Vhdl_08;
+            else
+               return False;
+            end if;
+         elsif Opt'Length = 9 and then Opt (Beg + 6 .. Beg + 8) = "93c" then
+            Vhdl_Std := Vhdl_93c;
+         else
+            return False;
+         end if;
+      elsif Opt'Length > 2 and then Opt (Beg .. Beg + 1) = "-P" then
+         Libraries.Add_Library_Path (Opt (Beg + 2 .. Opt'Last));
+      elsif Opt'Length > 10 and then Opt (Beg .. Beg + 9) = "--workdir=" then
+         Libraries.Set_Work_Library_Path (Opt (Beg + 10 .. Opt'Last));
+      elsif Opt'Length > 10 and then Opt (Beg .. Beg + 9) = "--warn-no-" then
+         return Option_Warning (Opt (Beg + 10 .. Opt'Last), False);
+      elsif Opt'Length > 7 and then Opt (Beg .. Beg + 6) = "--warn-" then
+         return Option_Warning (Opt (Beg + 7 .. Opt'Last), True);
+      elsif Opt'Length > 7 and then Opt (Beg .. Beg + 6) = "--work=" then
+         declare
+            use Name_Table;
+         begin
+            Name_Length := Opt'Last - (Beg + 7) + 1;
+            Name_Buffer (1 .. Name_Length) := Opt (Beg + 7 .. Opt'Last);
+            Scan.Convert_Identifier;
+            Libraries.Work_Library_Name := Get_Identifier;
+         end;
+      elsif Opt = "-C" or else Opt = "--mb-comments" then
+         Mb_Comment := True;
+      elsif Opt = "--bootstrap" then
+         Bootstrap := True;
+      elsif Opt = "-fexplicit" then
+         Flag_Explicit := True;
+      elsif Opt = "--syn-binding" then
+         Flag_Syn_Binding := True;
+      elsif Opt = "--no-vital-checks" then
+         Flag_Vital_Checks := False;
+      elsif Opt = "--vital-checks" then
+         Flag_Vital_Checks := True;
+      elsif Opt = "-dp" then
+         Dump_Parse := True;
+      elsif Opt = "-ds" then
+         Dump_Sem := True;
+      elsif Opt = "-dc" then
+         Dump_Canon := True;
+      elsif Opt = "-da" then
+         Dump_Annotate := True;
+      elsif Opt = "--dall" then
+         Dump_All := True;
+      elsif Opt = "-dstats" then
+         Dump_Stats := True;
+      elsif Opt = "--lall" then
+         List_All := True;
+      elsif Opt = "-lv" then
+         List_Verbose := True;
+      elsif Opt = "-ls" then
+         List_Sem := True;
+      elsif Opt = "-lc" then
+         List_Canon := True;
+      elsif Opt = "-la" then
+         List_Annotate := True;
+      elsif Opt = "-v" then
+         Verbose := True;
+      elsif Opt = "--finteger64" then
+         Flag_Integer_64 := True;
+      elsif Opt = "--ftime32" then
+         Flag_Time_64 := False;
+--       elsif Opt'Length > 17
+--         and then Opt (Beg .. Beg + 17) = "--time-resolution="
+--       then
+--          Beg := Beg + 18;
+--          if Opt (Beg .. Beg + 1) = "fs" then
+--             Time_Resolution := 'f';
+--          elsif Opt (Beg .. Beg + 1) = "ps" then
+--             Time_Resolution := 'p';
+--          elsif Opt (Beg .. Beg + 1) = "ns" then
+--             Time_Resolution := 'n';
+--          elsif Opt (Beg .. Beg + 1) = "us" then
+--             Time_Resolution := 'u';
+--          elsif Opt (Beg .. Beg + 1) = "ms" then
+--             Time_Resolution := 'm';
+--          elsif Opt (Beg .. Beg + 2) = "sec" then
+--             Time_Resolution := 's';
+--          elsif Opt (Beg .. Beg + 2) = "min" then
+--             Time_Resolution := 'M';
+--          elsif Opt (Beg .. Beg + 1) = "hr" then
+--             Time_Resolution := 'h';
+--          else
+--             return False;
+--          end if;
+      elsif Back_End.Parse_Option /= null
+        and then Back_End.Parse_Option.all (Opt)
+      then
+         null;
+      else
+         return False;
+      end if;
+      return True;
+   end Parse_Option;
+
+   -- Disp help about these options.
+   procedure Disp_Options_Help
+   is
+      procedure P (S : String) renames Put_Line;
+   begin
+      P ("Main options:");
+      P ("  --work=LIB         use LIB as work library");
+      P ("  --workdir=DIR      use DIR for the file library");
+      P ("  -PPATH             add PATH in the library path list");
+      P ("  --std=87/93/00/02/08  select vhdl 87/93/00/02/08 standard");
+      P ("  --std=93c          select vhdl 93 standard and allow 87 syntax");
+      P ("  --[no-]vital-checks  do [not] check VITAL restrictions");
+      P ("Warnings:");
+--    P ("  --warn-undriven    disp undriven signals");
+      P ("  --warn-binding     warns for component not bound");
+      P ("  --warn-reserved    warns use of 93 reserved words in vhdl87");
+      P ("  --warn-library     warns for redefinition of a design unit");
+      P ("  --warn-vital-generic  warns of non-vital generic names");
+      P ("  --warn-delayed-checks warns for checks performed at elaboration");
+      P ("  --warn-body        warns for not necessary package body");
+      P ("  --warn-specs       warns if a all/others spec does not apply");
+      P ("  --warn-unused      warns if a subprogram is never used");
+      P ("  --warn-error       turns warnings into errors");
+--    P ("Simulation option:");
+--    P ("  --time-resolution=UNIT   set the resolution of type time");
+--    P ("            UNIT can be fs, ps, ns, us, ms, sec, min or hr");
+--    P ("  --assert-level=LEVEL     set the level which stop the");
+--    P ("           simulation.  LEVEL is note, warning, error,");
+--    P ("           failure or none");
+      P ("Illegal extensions:");
+      P ("  -fexplicit         give priority to explicitly declared operator");
+      P ("  -C  --mb-comments  allow multi-bytes chars in a comment");
+      P ("  --bootstrap        allow --work=std");
+      P ("  --syn-binding      use synthesis default binding rule");
+      P ("Compilation list:");
+      P ("  -ls                after semantics");
+      P ("  -lc                after canon");
+      P ("  -la                after annotation");
+      P ("  --lall             -lX options apply to all files");
+      P ("  -lv                verbose list");
+      P ("  -v                 disp compilation stages");
+      P ("Compilation dump:");
+      P ("  -dp                dump tree after parsing");
+      P ("  -ds                dump tree after semantics");
+      P ("  -da                dump tree after annotate");
+      P ("  --dall             -dX options apply to all files");
+      if Back_End.Disp_Option /= null then
+         Back_End.Disp_Option.all;
+      end if;
+   end Disp_Options_Help;
+
+end Options;
diff -urN ghdl-0.27/vhdl/options.ads ghdl-0.28dev/vhdl/options.ads
--- ghdl-0.27/vhdl/options.ads	1970-01-01 01:00:00.000000000 +0100
+++ ghdl-0.28dev/vhdl/options.ads	2009-09-20 09:06:46.000000000 +0200
@@ -0,0 +1,27 @@
+--  Command line options.
+--  Copyright (C) 2008 Tristan Gingold
+--
+--  GHDL is free software; you can redistribute it and/or modify it under
+--  the terms of the GNU General Public License as published by the Free
+--  Software Foundation; either version 2, or (at your option) any later
+--  version.
+--
+--  GHDL is distributed in the hope that it will be useful, but WITHOUT ANY
+--  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+--  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+--  for more details.
+--
+--  You should have received a copy of the GNU General Public License
+--  along with GHDL; see the file COPYING.  If not, write to the Free
+--  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+--  02111-1307, USA.
+
+package Options is
+   -- Return true if opt is recognize by flags.
+   --  Note: std_names.std_names_initialize and files_map.init_pathes must have
+   --  been called before this subprogram.
+   function Parse_Option (Opt: String) return Boolean;
+
+   -- Disp help about these options.
+   procedure Disp_Options_Help;
+end Options;
diff -urN ghdl-0.27/vhdl/ortho_front.adb ghdl-0.28dev/vhdl/ortho_front.adb
--- ghdl-0.27/vhdl/ortho_front.adb	2006-08-16 08:23:58.000000000 +0200
+++ ghdl-0.28dev/vhdl/ortho_front.adb	2009-09-20 09:06:43.000000000 +0200
@@ -31,6 +31,7 @@
 with Disp_Vhdl;
 with Bug;
 with Trans_Be;
+with Options;
 
 package body Ortho_Front is
    --  The action to be performed by the compiler.
@@ -197,18 +198,18 @@
          end if;
          return 2;
       elsif Opt.all = "--help" then
-         Flags.Disp_Options_Help;
+         Options.Disp_Options_Help;
          return 1;
       elsif Opt.all = "--expect-failure" then
          Flag_Expect_Failure := True;
          return 1;
       elsif Opt'Length > 7 and then Opt (1 .. 7) = "--ghdl-" then
-         if Flags.Parse_Option (Opt (7 .. Opt'Last)) then
+         if Options.Parse_Option (Opt (7 .. Opt'Last)) then
             return 1;
          else
             return 0;
          end if;
-      elsif Flags.Parse_Option (Opt.all) then
+      elsif Options.Parse_Option (Opt.all) then
          return 1;
       else
          return 0;
diff -urN ghdl-0.27/vhdl/ortho_ident.adb ghdl-0.28dev/vhdl/ortho_ident.adb
--- ghdl-0.27/vhdl/ortho_ident.adb	2005-09-13 15:01:58.000000000 +0200
+++ ghdl-0.28dev/vhdl/ortho_ident.adb	2009-09-20 09:06:45.000000000 +0200
@@ -7,6 +7,7 @@
      (Id : O_Ident; Str : Address; Size : Integer)
      return Boolean;
    pragma Import (C, Compare_Identifier_String);
+   pragma Warnings (Off, Compare_Identifier_String);
 
    function Get_Identifier (Str : String) return O_Ident is
    begin
diff -urN ghdl-0.27/vhdl/ortho-lang.c ghdl-0.28dev/vhdl/ortho-lang.c
--- ghdl-0.27/vhdl/ortho-lang.c	2008-06-11 03:37:49.000000000 +0200
+++ ghdl-0.28dev/vhdl/ortho-lang.c	2009-09-20 09:06:45.000000000 +0200
@@ -247,7 +247,7 @@
 {
   tree n;
 
-  input_location.line = 0;
+  input_location = BUILTINS_LOCATION;
 
   /* Create a global binding.  */
   push_binding ();
@@ -372,13 +372,6 @@
     }
 }
 
-#if 0
-void
-linemap_init (void *s)
-{
-}
-#endif
-
 extern int lang_parse_file (const char *filename);
 
 static void
@@ -391,6 +384,9 @@
   else
     filename = in_fnames[0];
 
+  linemap_add (line_table, LC_ENTER, 0, filename ? filename :"*no-file*", 1);
+  input_location = linemap_line_start (line_table, 0, 252);
+
   if (!lang_parse_file (filename))
     errorcount++;
   else
@@ -398,19 +394,7 @@
       cgraph_finalize_compilation_unit ();
       cgraph_optimize ();
     }
-}
-
-static void
-ortho_expand_function (tree fndecl)
-{
-  if (DECL_CONTEXT (fndecl) != NULL_TREE)
-    {
-      push_function_context ();
-      tree_rest_of_compilation (fndecl);
-      pop_function_context ();
-    }
-  else
-      tree_rest_of_compilation (fndecl);
+  linemap_add (line_table, LC_LEAVE, 0, NULL, 1);
 }
 
 /*  Called by the back-end or by the front-end when the address of EXP
@@ -610,6 +594,7 @@
   make_decl_rtl (decl);
   DECL_BUILT_IN_CLASS (decl) = class;
   DECL_FUNCTION_CODE (decl) = function_code;
+  DECL_SOURCE_LOCATION (decl) = input_location;
   return decl;
 }
 
@@ -653,32 +638,6 @@
   return type_for_size (GET_MODE_BITSIZE (mode), unsignedp);
 }
 
-/*  Return the unsigned version of a TYPE_NODE, a scalar type.  */
-static tree
-unsigned_type (tree type)
-{
-  return type_for_size (TYPE_PRECISION (type), 1);
-}
-
-/*  Return the signed version of a TYPE_NODE, a scalar type.  */
-static tree
-signed_type (tree type)
-{
-  return type_for_size (TYPE_PRECISION (type), 0);
-}
-
-/*  Return a type the same as TYPE except unsigned or signed according to
-    UNSIGNEDP.  */
-static tree
-signed_or_unsigned_type (int unsignedp, tree type)
-{
-  if (!INTEGRAL_TYPE_P (type)
-      || TYPE_UNSIGNED (type) == unsignedp)
-    return type;
-  else
-    return type_for_size (TYPE_PRECISION (type), unsignedp);
-}
-
 #undef LANG_HOOKS_NAME
 #define LANG_HOOKS_NAME "vhdl"
 #undef LANG_HOOKS_IDENTIFIER_SIZE
@@ -752,23 +711,24 @@
 
 union lang_tree_node 
   GTY((desc ("0"),
-       chain_next ("(union lang_tree_node *)TREE_CHAIN (&%h.generic)")))
+       chain_next ("(union lang_tree_node *) GENERIC_NEXT (&%h.generic)")))
 {
-  union tree_node GTY ((tag ("0"), 
-			desc ("tree_node_structure (&%h)"))) 
-    generic;
+  union tree_node GTY ((tag ("0"))) generic;
 };
 
 struct lang_decl GTY(())
 {
+  char dummy;
 };
 
 struct lang_type GTY (())
 {
+  char dummy;
 };
 
 struct language_function GTY (())
 {
+  char dummy;
 };
 
 struct chain_constr_type
@@ -1004,8 +964,7 @@
     cur_binding_level->save_stack = 1;
 
   args = tree_cons (NULL_TREE, fold_convert (size_type_node, size), NULL_TREE);
-  res = build3 (CALL_EXPR, ptr_type_node, stack_alloc_function_ptr,
-		 args, NULL_TREE);
+  res = build_call_list (ptr_type_node, stack_alloc_function_ptr, args);
   return fold_convert (rtype, res);
 }
 
@@ -1074,9 +1033,9 @@
   else
     hi = s >> (8 * sizeof (HOST_WIDE_INT));
 
-  res = build_int_cst_wide (ltype, lo, hi);
+  res = build_int_cst_wide (long_integer_type_node, lo, hi);
   REAL_VALUE_FROM_INT (r_sign, lo, hi, DFmode);
-  real_2expN (&r_exp, ex - 60);
+  real_2expN (&r_exp, ex - 60, DFmode);
   real_arithmetic (&r, MULT_EXPR, &r_sign, &r_exp);
   res = build_real (ltype, r);
   return res;
@@ -1496,14 +1455,14 @@
 
 	  ortho_mark_addressable (base);
 
-	  offset = fold_build2 (MULT_EXPR, TREE_TYPE (idx), idx,
+	  idx = fold_convert (sizetype, idx);
+	  offset = fold_build2 (MULT_EXPR, sizetype, idx,
 				array_ref_element_size (lvalue)); 
 
 	  base = array_to_pointer_conversion (base);
 	  base_type = TREE_TYPE (base);
 
-	  res = build2 (PLUS_EXPR, base_type,
-			base, convert (base_type, offset));
+	  res = build2 (POINTER_PLUS_EXPR, base_type, base, offset);
 	}
       else
 	{
@@ -1606,7 +1565,7 @@
 void
 new_debug_line_decl (int line)
 {
-  input_location.line = line;
+  input_location = linemap_line_start (line_table, line, 252);
 }
 
 void
@@ -1806,6 +1765,8 @@
   decl = build_decl (FUNCTION_DECL, interfaces->ident,
 		     build_function_type (interfaces->rtype,
 					  interfaces->param_list.first));
+  DECL_SOURCE_LOCATION (decl) = input_location;
+
   is_global = current_function_decl == NULL_TREE
     || interfaces->storage == o_storage_external;
   if (is_global)
@@ -1876,7 +1837,7 @@
   DECL_SAVED_TREE (func) = bind;
 
   /* Initialize the RTL code for the function.  */
-  allocate_struct_function (func);
+  allocate_struct_function (func, false);
 
   /* Store the end of the function.  */
   cfun->function_end_locus = input_location;
@@ -1898,14 +1859,14 @@
     cgraph_finalize_function (func, false);
 
   current_function_decl = parent;
-  cfun = NULL;
+  set_cfun (NULL);
 }
 
 
 void
 new_debug_line_stmt (int line)
 {
-  input_location.line = line;
+  input_location = linemap_line_start (line_table, line, 252);
 }
 
 void
@@ -1948,10 +1909,9 @@
 tree
 new_function_call (struct o_assoc_list *assocs)
 {
-  return build3 (CALL_EXPR,
-		 TREE_TYPE (TREE_TYPE (assocs->subprg)),
-		 build_function_ptr (assocs->subprg),
-		 assocs->list.first, NULL_TREE);
+  return build_call_list (TREE_TYPE (TREE_TYPE (assocs->subprg)),
+			  build_function_ptr (assocs->subprg),
+			  assocs->list.first);
 }
 
 void
@@ -1959,10 +1919,9 @@
 {
   tree res;
 
-  res = build3 (CALL_EXPR,
-		TREE_TYPE (TREE_TYPE (assocs->subprg)),
-		build_function_ptr (assocs->subprg),
-		assocs->list.first, NULL_TREE);
+  res = build_call_list (TREE_TYPE (TREE_TYPE (assocs->subprg)),
+			 build_function_ptr (assocs->subprg),
+			 assocs->list.first);
   TREE_SIDE_EFFECTS (res) = 1;
   append_stmt (res);
 }
@@ -1987,7 +1946,8 @@
   res = DECL_RESULT (current_function_decl);
   assign = build2 (MODIFY_EXPR, TREE_TYPE (value), res, value);
   TREE_SIDE_EFFECTS (assign) = 1;
-  stmt = build1 (RETURN_EXPR, TREE_TYPE (value), assign);
+  stmt = build1 (RETURN_EXPR, void_type_node, assign);
+  TREE_SIDE_EFFECTS (stmt) = 1;
   append_stmt (stmt);
 }
 
diff -urN ghdl-0.27/vhdl/parse.adb ghdl-0.28dev/vhdl/parse.adb
--- ghdl-0.27/vhdl/parse.adb	2007-05-05 06:59:33.000000000 +0200
+++ ghdl-0.28dev/vhdl/parse.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,9 +12,10 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
+with Iir_Chains; use Iir_Chains;
 with Ada.Text_IO; use Ada.Text_IO;
 with Types; use Types;
 with Tokens; use Tokens;
@@ -22,10 +23,9 @@
 with Iirs_Utils; use Iirs_Utils;
 with Errorout; use Errorout;
 with Std_Names; use Std_Names;
-with Flags;
+with Flags; use Flags;
 with Name_Table;
 with Str_Table;
-with Iir_Chains; use Iir_Chains;
 with Xrefs;
 
 --  Recursive descendant parser.
@@ -97,7 +97,6 @@
    --  Otherwise, accept the current_token (ie set it to tok_invalid, unless
    --  TOKEN is Tok_Identifier).
    procedure Expect (Token: Token_Type; Msg: String := "") is
-      use Errorout;
    begin
       if Current_Token /= Token then
          if Msg'Length > 0 then
@@ -510,6 +509,13 @@
                   if C2 /= '*' then
                      Bad_Operator_Symbol;
                   end if;
+               when '?' =>
+                  if Vhdl_Std < Vhdl_08 then
+                     Bad_Operator_Symbol;
+                  elsif C2 /= '?' then
+                     Bad_Operator_Symbol;
+                  end if;
+                  Id := Name_Op_Condition;
                when others =>
                   Bad_Operator_Symbol;
                   Id := Name_Op_Equality;
@@ -857,6 +863,7 @@
    is
       Res : Iir;
       Old : Iir;
+      pragma Unreferenced (Old);
    begin
       Res := Parse_Name (Allow_Indexes => False);
       if Check_Paren and then Current_Token = Tok_Left_Paren then
@@ -1291,7 +1298,7 @@
    --  precond : ARRAY
    --  postcond: ??
    --
-   --  [ 3.2.1 ]
+   --  [ LRM93 3.2.1 ]
    --  array_type_definition ::= unconstrained_array_definition
    --                          | constrained_array_definition
    --
@@ -1307,6 +1314,14 @@
    --   index_constraint ::= ( discrete_range { , discrete_range } )
    --
    --   discrete_range ::= discrete_subtype_indication | range
+   --
+   --  [ LRM08 5.3.2.1 ]
+   --  array_type_definition ::= unbounded_array_definition
+   --                          | constrained_array_definition
+   --
+   --   unbounded_array_definition ::=
+   --      ARRAY ( index_subtype_definition { , index_subtype_definition } )
+   --      OF element_subtype_indication
    function Parse_Array_Definition return Iir
    is
       Index_Constrained : Boolean;
@@ -1472,9 +1487,8 @@
    --  element_subtype_definition ::= subtype_indication
    function Parse_Record_Definition return Iir_Record_Type_Definition
    is
-      use Iir_Chains.Element_Declaration_Chain_Handling;
       Res: Iir_Record_Type_Definition;
-      Last : Iir_Element_Declaration;
+      El_List : Iir_List;
       El: Iir_Element_Declaration;
       First : Iir;
       Pos: Iir_Index32;
@@ -1482,9 +1496,10 @@
    begin
       Res := Create_Iir (Iir_Kind_Record_Type_Definition);
       Set_Location (Res);
+      El_List := Create_Iir_List;
+      Set_Elements_Declaration_List (Res, El_List);
       Scan.Scan;
       Pos := 0;
-      Build_Init (Last);
       First := Null_Iir;
       loop
          pragma Assert (First = Null_Iir);
@@ -1492,9 +1507,12 @@
          loop
             El := Create_Iir (Iir_Kind_Element_Declaration);
             Set_Location (El);
+            if First = Null_Iir then
+               First := El;
+            end if;
             Expect (Tok_Identifier);
             Set_Identifier (El, Current_Identifier);
-            Append (Last, Res, El);
+            Append_Element (El_List, El);
             Set_Element_Position (El, Pos);
             Pos := Pos + 1;
             if First = Null_Iir then
@@ -1507,15 +1525,12 @@
          Expect (Tok_Colon);
          Scan.Scan;
          Subtype_Indication := Parse_Subtype_Indication;
-         while First /= Null_Iir loop
-            Set_Type (First, Subtype_Indication);
-            First := Get_Chain (First);
-         end loop;
+         Set_Type (First, Subtype_Indication);
+         First := Null_Iir;
          Expect (Tok_Semi_Colon);
          Scan.Scan;
          exit when Current_Token = Tok_End;
       end loop;
-      Set_Number_Element_Declaration (Res, Pos);
       Scan_Expect (Tok_Record);
       Scan.Scan;
       return Res;
@@ -1792,32 +1807,174 @@
       return Decl;
    end Parse_Type_Declaration;
 
-   --  precond : identifier
+   --  precond: '(' or identifier
    --  postcond: next token
    --
-   --  [ 4.2 ]
+   --  [ LRM08 6.3 ]
+   --
+   --  resolution_indication ::=
+   --      resolution_function_name | ( element_resolution )
+   --
+   --  element_resolution ::=
+   --      array_element_resolution | record_resolution
+   --
+   --  array_element_resolution ::= resolution_indication
+   --
+   --  record_resolution ::=
+   --      record_element_resolution { , record_element_resolution }
+   --
+   --  record_element_resolution ::=
+   --      record_element_simple_name resolution_indication
+   function Parse_Resolution_Indication return Iir
+   is
+      Res : Iir;
+      Def : Iir;
+      Loc : Location_Type;
+      El_List : Iir_List;
+      El : Iir;
+      Id : Name_Id;
+   begin
+      if Current_Token = Tok_Identifier then
+         --  Resolution function name.
+         return Parse_Name (Allow_Indexes => False);
+      elsif Current_Token = Tok_Left_Paren then
+         --  Element resolution.
+         Loc := Get_Token_Location;
+
+         Scan.Scan; -- Eat '('
+         Res := Parse_Resolution_Indication;
+         if Current_Token = Tok_Identifier
+           or else Current_Token = Tok_Left_Paren
+         then
+            --  This was in fact a record_resolution.
+            if Get_Kind (Res) /= Iir_Kind_Simple_Name then
+               Error_Msg_Parse ("element name expected", Res);
+               return Null_Iir;
+            end if;
+            Id := Get_Identifier (Res);
+            Free_Iir (Res);
+            Def := Create_Iir (Iir_Kind_Record_Subtype_Definition);
+            Set_Location (Def, Loc);
+            El_List := Create_Iir_List;
+            Set_Elements_Declaration_List (Def, El_List);
+            loop
+               El := Create_Iir (Iir_Kind_Record_Element_Constraint);
+               Set_Location (El, Loc);
+               Set_Identifier (El, Id);
+               Set_Element_Declaration (El, Parse_Resolution_Indication);
+               Append_Element (El_List, El);
+               exit when Current_Token = Tok_Right_Paren;
+               Expect (Tok_Comma);
+               Scan.Scan;
+               if Current_Token /= Tok_Identifier then
+                  Error_Msg_Parse ("record element identifier expected");
+                  exit;
+               end if;
+               Id := Current_Identifier;
+               Loc := Get_Token_Location;
+               Scan.Scan;
+            end loop;
+         else
+            Def := Create_Iir (Iir_Kind_Array_Subtype_Definition);
+            Set_Location (Def, Loc);
+            Set_Element_Subtype (Def, Res);
+         end if;
+         Expect (Tok_Right_Paren);
+         Scan.Scan;
+         return Def;
+      else
+         Error_Msg_Parse ("resolution indication expected");
+         raise Parse_Error;
+      end if;
+   end Parse_Resolution_Indication;
+
+   --  precond : '('
+   --  postcond: next token
+   --
+   --  [ LRM08 6.3 Subtype declarations ]
+   --  element_constraint ::=
+   --      array_constraint | record_constraint
+   --
+   --  [ LRM08 5.3.2.1 Array types ]
+   --  array_constraint ::=
+   --      index_constraint [ array_element_constraint ]
+   --      | ( open ) [ array_element_constraint ]
+   --
+   --  array_element_constraint ::= element_constraint
+   --
+   --  RES is the resolution_indication of the subtype indication.
+   function Parse_Element_Constraint return Iir
+   is
+      Def : Iir;
+      El : Iir;
+   begin
+      --  Index_constraint.
+      Def := Create_Iir (Iir_Kind_Array_Subtype_Definition);
+      Set_Location (Def);
+
+      --  Eat '('.
+      Scan.Scan;
+
+      if Current_Token = Tok_Open then
+         --  Eat 'open'.
+         Scan.Scan;
+      else
+         Set_Index_Subtype_List (Def, Create_Iir_List);
+         -- index_constraint ::= (discrete_range {, discrete_range} )
+         loop
+            -- accept parenthesis or comma.
+            El := Parse_Discrete_Range;
+            Append_Element (Get_Index_Subtype_List (Def), El);
+            exit when Current_Token = Tok_Right_Paren;
+            Expect (Tok_Comma);
+            Scan.Scan;
+         end loop;
+      end if;
+      Expect (Tok_Right_Paren);
+      Scan.Scan;
+
+      if Current_Token = Tok_Left_Paren then
+         Set_Element_Subtype (Def, Parse_Element_Constraint);
+      end if;
+      return Def;
+   end Parse_Element_Constraint;
+
+   --  precond : identifier or '('
+   --  postcond: next token
+   --
+   --  [ LRM93 4.2 ]
    --  subtype_indication ::=
    --      [ RESOLUTION_FUNCTION_name ] type_mark [ constraint ]
    --
-   --  [ 4.2 ]
    --  constraint ::= range_constraint | index_constraint
    --
-   --  [ 3.2.1]
-   --  index_constraint ::= ( discrete_range { , discrete_range } )
+   --  [ LRM08 6.3 ]
+   --  subtype_indication ::=
+   --      [ resolution_indication ] type_mark [ constraint ]
+   --
+   --  constraint ::=
+   --      range_constraint | array_constraint | record_constraint
    function Parse_Subtype_Indication (Name : Iir := Null_Iir)
      return Iir
    is
       Type_Mark : Iir;
       Def: Iir;
-      El: Iir;
       Resolution_Function: Iir;
    begin
       -- FIXME: location.
       Resolution_Function := Null_Iir;
+      Def := Null_Iir;
 
       if Name /= Null_Iir then
          Type_Mark := Name;
       else
+         if Current_Token = Tok_Left_Paren then
+            if Vhdl_Std < Vhdl_08 then
+               Error_Msg_Parse
+                 ("resolution_indication not allowed before vhdl08");
+            end if;
+            Resolution_Function := Parse_Resolution_Indication;
+         end if;
          if Current_Token /= Tok_Identifier then
             Error_Msg_Parse ("type mark expected in a subtype indication");
             raise Parse_Error;
@@ -1826,28 +1983,19 @@
       end if;
 
       if Current_Token = Tok_Identifier then
+         if Resolution_Function /= Null_Iir then
+            Error_Msg_Parse ("resolution function already indicated");
+         end if;
          Resolution_Function := Type_Mark;
          Type_Mark := Parse_Type_Mark (Check_Paren => False);
       end if;
 
       case Current_Token is
          when Tok_Left_Paren =>
-            --  Index_constraint.
-            Def := Create_Iir (Iir_Kind_Array_Subtype_Definition);
-            Set_Location (Def);
+            --  element_constraint.
+            Def := Parse_Element_Constraint;
             Set_Type_Mark (Def, Type_Mark);
             Set_Resolution_Function (Def, Resolution_Function);
-            Set_Index_Subtype_List (Def, Create_Iir_List);
-            -- index_constraint ::= (discrete_range {, discrete_range} )
-            loop
-               -- accept parenthesis or comma.
-               Scan.Scan;
-               El := Parse_Discrete_Range;
-               Append_Element (Get_Index_Subtype_List (Def), El);
-               exit when Current_Token = Tok_Right_Paren;
-               Expect (Tok_Comma);
-            end loop;
-            Scan.Scan;
 
          when Tok_Range =>
             --  range_constraint.
@@ -1858,13 +2006,13 @@
             Set_Resolution_Function (Def, Resolution_Function);
 
          when others =>
-            if Resolution_Function = Null_Iir then
-               Def := Type_Mark;
-            else
+            if Resolution_Function /= Null_Iir then
                Def := Create_Iir (Iir_Kind_Subtype_Definition);
                Location_Copy (Def, Type_Mark);
                Set_Type_Mark (Def, Type_Mark);
                Set_Resolution_Function (Def, Resolution_Function);
+            else
+               Def := Type_Mark;
             end if;
       end case;
       return Def;
@@ -3459,7 +3607,7 @@
    --
    --  [ 9.5 ]
    --  options ::= [ GUARDED ] [ delay_mechanism ]
-   procedure Parse_Options (Stmt : in out Iir) is
+   procedure Parse_Options (Stmt : Iir) is
    begin
       if Current_Token = Tok_Guarded then
          Set_Guard (Stmt, Stmt);
@@ -4191,6 +4339,7 @@
       Subprg: Iir;
       Subprg_Body : Iir;
       Old : Iir;
+      pragma Unreferenced (Old);
    begin
       -- Create the node.
       case Current_Token is
@@ -4341,16 +4490,16 @@
    --  precond:  PROCESS
    --  postcond: null
    --
-   --  [ 9.2 ]
+   --  [ LRM87 9.2 / LRM08 11.3 ]
    --  process_statement ::=
    --    [ PROCESS_label : ]
-   --       [ POSTPONED ] PROCESS [ ( sensitivity_list ) ] [ IS ]
+   --       [ POSTPONED ] PROCESS [ ( process_sensitivity_list ) ] [ IS ]
    --           process_declarative_part
    --       BEGIN
    --           process_statement_part
    --       END [ POSTPONED ] PROCESS [ PROCESS_label ] ;
    --
-   --  FIXME: POSTPONED
+   --  process_sensitivity_list ::= ALL | sensitivity_list
    function Parse_Process_Statement
      (Label: Name_Id; Loc : Location_Type; Is_Postponed : Boolean)
      return Iir
@@ -4364,9 +4513,18 @@
       if Current_Token = Tok_Left_Paren then
          Res := Create_Iir (Iir_Kind_Sensitized_Process_Statement);
          Scan.Scan;
-         Sensitivity_List := Create_Iir_List;
+         if Current_Token = Tok_All then
+            if Vhdl_Std < Vhdl_08 then
+               Error_Msg_Parse
+                 ("all sensitized process allowed only in vhdl 08");
+            end if;
+            Sensitivity_List := Iir_List_All;
+            Scan.Scan;
+         else
+            Sensitivity_List := Create_Iir_List;
+            Parse_Sensitivity_List (Sensitivity_List);
+         end if;
          Set_Sensitivity_List (Res, Sensitivity_List);
-         Parse_Sensitivity_List (Sensitivity_List);
          Expect (Tok_Right_Paren);
          Scan.Scan;
       else
@@ -4474,7 +4632,13 @@
             case Current_Token is
                when Tok_To
                  | Tok_Downto =>
-                  Actual := Parse_Range_Expression (Actual);
+                  if Actual = Null_Iir then
+                     --  Left expression is missing ie: (downto x).
+                     Scan.Scan;
+                     Actual := Parse_Expression;
+                  else
+                     Actual := Parse_Range_Expression (Actual);
+                  end if;
                   if Nbr_Assocs /= 1 then
                      Error_Msg_Parse ("multi-dimensional slice is forbidden");
                   end if;
diff -urN ghdl-0.27/vhdl/parse.ads ghdl-0.28dev/vhdl/parse.ads
--- ghdl-0.27/vhdl/parse.ads	2005-09-22 23:14:25.000000000 +0200
+++ ghdl-0.28dev/vhdl/parse.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
diff -urN ghdl-0.27/vhdl/post_sems.adb ghdl-0.28dev/vhdl/post_sems.adb
--- ghdl-0.27/vhdl/post_sems.adb	2005-09-22 23:30:26.000000000 +0200
+++ ghdl-0.28dev/vhdl/post_sems.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
diff -urN ghdl-0.27/vhdl/post_sems.ads ghdl-0.28dev/vhdl/post_sems.ads
--- ghdl-0.27/vhdl/post_sems.ads	2005-09-22 23:14:56.000000000 +0200
+++ ghdl-0.28dev/vhdl/post_sems.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
diff -urN ghdl-0.27/vhdl/scan.adb ghdl-0.28dev/vhdl/scan.adb
--- ghdl-0.27/vhdl/scan.adb	2005-09-22 23:31:03.000000000 +0200
+++ ghdl-0.28dev/vhdl/scan.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,12 +12,11 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Ada.Characters.Latin_1; use Ada.Characters.Latin_1;
 with Ada.Characters.Handling;
-with Tokens; use Tokens;
 with Errorout; use Errorout;
 with Name_Table;
 with Files_Map; use Files_Map;
@@ -79,8 +78,9 @@
       '0' .. '9' => Digit,
 
       -- 3. special characters
-      Quotation | '#' | '&' | ''' | '(' | ')' | '+' | ',' | '-' | '.' | '/' |
-      ':' | ';' | '<' | '=' | '>' | '_' | '|' | '*' => Special_Character,
+      Quotation | '#' | '&' | ''' | '(' | ')' | '+' | ',' | '-' | '.' | '/'
+        | ':' | ';' | '<' | '=' | '>' | '[' | ']'
+        | '_' | '|' | '*' => Special_Character,
 
       -- 4. the space characters
       ' ' | No_Break_Space => Space_Character,
@@ -90,9 +90,43 @@
       LC_O_Oblique_Stroke .. LC_Y_Diaeresis => Lower_Case_Letter,
 
       -- 6. other special characters
-      '!' | '$' | '%' | '@' | '?' | '[' | '\' | ']' | '^' | '{' | '}' | '~' |
-      '`' | Inverted_Exclamation .. Inverted_Question | Multiplication_Sign |
-      Division_Sign => Other_Special_Character,
+      '!' | '$' | '%' | '@' | '?' | '\' | '^' | '`' | '{' | '}' | '~'
+        | Inverted_Exclamation .. Inverted_Question | Multiplication_Sign |
+        Division_Sign => Other_Special_Character,
+
+      --  ''    -- INVERTED EXCLAMATION MARK
+      --  ''    -- CENT SIGN
+      --  ''    -- POUND SIGN
+      --  ''    -- CURRENCY SIGN
+      --  ''    -- YEN SIGN
+      --  ''    -- BROKEN BAR
+      --  ''    -- SECTION SIGN
+      --  ''    -- DIAERESIS
+      --  ''    -- COPYRIGHT SIGN
+      --  ''    -- FEMININE ORDINAL INDICATOR
+      --  ''    -- LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
+      --  ''    -- NOT SIGN
+      --  ''    -- SOFT HYPHEN
+      --  ''    -- REGISTERED SIGN
+      --  ''    -- MACRON
+      --  ''    -- DEGREE SIGN
+      --  ''    -- PLUS-MINUS SIGN
+      --  ''    -- SUPERSCRIPT TWO
+      --  ''    -- SUPERSCRIPT THREE
+      --  ''    -- ACUTE ACCENT
+      --  ''    -- MICRO SIGN
+      --  ''    -- PILCROW SIGN
+      --  ''    -- MIDDLE DOT
+      --  ''    -- CEDILLA
+      --  ''    -- SUPERSCRIPT ONE
+      --  ''    -- MASCULINE ORDINAL INDICATOR
+      --  ''    -- RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
+      --  ''    -- VULGAR FRACTION ONE QUARTER
+      --  ''    -- VULGAR FRACTION ONE HALF
+      --  ''    -- VULGAR FRACTION THREE QUARTERS
+      --  ''    -- INVERTED QUESTION MARK
+      --  ''    -- MULTIPLICATION SIGN
+      --  ''    -- DIVISION SIGN
 
       DEL .. APC => Invalid);
 
diff -urN ghdl-0.27/vhdl/scan.ads ghdl-0.28dev/vhdl/scan.ads
--- ghdl-0.27/vhdl/scan.ads	2005-09-22 23:15:11.000000000 +0200
+++ ghdl-0.28dev/vhdl/scan.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
diff -urN ghdl-0.27/vhdl/scan-scan_literal.adb ghdl-0.28dev/vhdl/scan-scan_literal.adb
--- ghdl-0.27/vhdl/scan-scan_literal.adb	2006-07-10 00:57:35.000000000 +0200
+++ ghdl-0.28dev/vhdl/scan-scan_literal.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Ada.Unchecked_Conversion;
@@ -80,22 +80,31 @@
 
    procedure Bmul (Res : out E_Num; E : E_Num; V : Uint16; B : Uint16)
    is
-      T : Uint32;
+      --  The carry.
+      C : Uint32;
    begin
-      T := Uint32 (V);
+      --  Only consider V if E is not scaled (otherwise V is not significant).
+      if E.E = 0 then
+         C := Uint32 (V);
+      else
+         C := 0;
+      end if;
+
+      --  Multiply and propagate the carry.
       for I in Digit_Range loop
-         T := Uint32 (E.S (I)) * Uint32 (B) + T;
-         Res.S (I) := Uint16 (T mod Uint16'Modulus);
-         T := T / Uint16'Modulus;
+         C := Uint32 (E.S (I)) * Uint32 (B) + C;
+         Res.S (I) := Uint16 (C mod Uint16'Modulus);
+         C := C / Uint16'Modulus;
       end loop;
 
       --  There is a carry, shift.
-      if T /= 0 then
+      if C /= 0 then
          --  ERR: Possible overflow.
          Res.E := E.E + 1;
          for I in 0 .. Nbr_Digits - 2 loop
             Res.S (I) := Res.S (I + 1);
          end loop;
+         Res.S (Nbr_Digits - 1) := Uint16 (C);
       else
          Res.E := E.E;
       end if;
@@ -197,11 +206,11 @@
          end if;
       end loop;
       if Max > Nbr_Digits - 1 then
-         --  Lost of precision.
+         --  Loss of precision.
          --  Round.
          if T (Max - Nbr_Digits) >= Uint16 (Uint16'Modulus / 2) then
             V := 1;
-            for I in reverse Max - (Nbr_Digits - 1) .. Max loop
+            for I in Max - (Nbr_Digits - 1) .. Max loop
                V := V + Uint32 (T (I));
                T (I) := Uint16 (V mod Uint16'Modulus);
                V := V / Uint16'Modulus;
diff -urN ghdl-0.27/vhdl/sem.adb ghdl-0.28dev/vhdl/sem.adb
--- ghdl-0.27/vhdl/sem.adb	2007-03-28 01:31:05.000000000 +0200
+++ ghdl-0.28dev/vhdl/sem.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,11 +12,10 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Ada.Unchecked_Conversion;
-with Types; use Types;
 with Errorout; use Errorout;
 with Std_Package; use Std_Package;
 with Libraries;
@@ -28,7 +27,7 @@
 with Sem_Decls; use Sem_Decls;
 with Sem_Assocs; use Sem_Assocs;
 with Iirs_Utils; use Iirs_Utils;
-with Flags;
+with Flags; use Flags;
 with Name_Table;
 with Str_Table;
 with Sem_Stmts; use Sem_Stmts;
@@ -198,11 +197,11 @@
       --  considered to occur immediatly within the declarative region
       --  associated with the entity declaration corresponding to the given
       --  architecture body.
-      if Flags.Vhdl_Std >= Vhdl_02 then
+      if Vhdl_Std >= Vhdl_02 then
          Open_Declarative_Region;
       end if;
       Sem_Block (Arch, True);
-      if Flags.Vhdl_Std >= Vhdl_02 then
+      if Vhdl_Std >= Vhdl_02 then
          Close_Declarative_Region;
       end if;
 
@@ -479,6 +478,7 @@
                   then
                      declare
                         P : Boolean;
+                        pragma Unreferenced (P);
                      begin
                         P := Check_Port_Association_Restriction
                           (Get_Base_Name (Formal), Prefix, El);
@@ -827,7 +827,6 @@
       begin
          El := Get_Declaration_Chain (Block_Conf);
          while El /= Null_Iir loop
-            exit when El = Null_Iir;
             case Get_Kind (El) is
                when Iir_Kind_Use_Clause =>
                   Sem_Use_Clause (El);
@@ -1107,7 +1106,7 @@
             end if;
             El_Left := Get_Default_Value (Left);
             El_Right := Get_Default_Value (Right);
-            if ((El_Left = Null_Iir) xor (El_Right = Null_Iir)) = True then
+            if (El_Left = Null_Iir) xor (El_Right = Null_Iir)  then
                return False;
             end if;
             if El_Left /= Null_Iir
@@ -1351,9 +1350,9 @@
       Num : Iir_Int32;
    begin
       Inter := Get_Interpretation (Get_Identifier (Decl));
-      if Valid_Interpretation (Inter)
+      while Valid_Interpretation (Inter)
         and then Is_In_Current_Declarative_Region (Inter)
-      then
+      loop
          --  There is a previous declaration with the same name in the
          --  current declarative region.
          Prev := Get_Declaration (Inter);
@@ -1373,15 +1372,21 @@
                   Set_Overload_Number (Prev, 1);
                   Num := 2;
                end if;
+               Set_Overload_Number (Decl, Num);
+               return;
+            when Iir_Kind_Implicit_Function_Declaration
+              | Iir_Kind_Implicit_Procedure_Declaration =>
+               --  Implicit declarations aren't taken into account (as they
+               --  are mangled differently).
+               Inter := Get_Next_Interpretation (Inter);
             when others =>
                --  Can be an enumeration literal or an error.
-               Num := 0;
+               Set_Overload_Number (Decl, 0);
+               return;
          end case;
-      else
-         --  No previous declaration in the current declarative region.
-         Num := 0;
-      end if;
-      Set_Overload_Number (Decl, Num);
+      end loop;
+      --  No previous declaration in the current declarative region.
+      Set_Overload_Number (Decl, 0);
    end Set_Subprogram_Overload_Number;
 
    --  Check requirements on number of interfaces for subprogram specification
@@ -1422,9 +1427,7 @@
             end if;
             Error_Msg_Sem ("unary operator must have a single parameter",
                            Subprg);
-         when Name_Logical_Operators
-           | Name_Xnor
-           | Name_Mod
+         when Name_Mod
            | Name_Rem
            | Name_Op_Mul
            | Name_Op_Div
@@ -1443,7 +1446,28 @@
             if Nbr_Interfaces = 2 then
                return;
             end if;
-            Error_Msg_Sem ("binary operator must have two parameters", Subprg);
+            Error_Msg_Sem
+              ("binary operators must have two parameters", Subprg);
+         when Name_Logical_Operators
+           | Name_Xnor =>
+            --  LRM08 4.5.2 Operator overloading
+            --  For each of the "+", "-", "and", "or", "xor", "nand", "nor"
+            --  and "xnor", overloading is allowed both as a unary operator
+            --  and as a binary operator.
+            if Nbr_Interfaces = 2 then
+               return;
+            end if;
+            if Nbr_Interfaces = 1 then
+               if Vhdl_Std >= Vhdl_08 then
+                  return;
+               end if;
+               Error_Msg_Sem
+                 ("logical operators must have two parameters before vhdl08",
+                  Subprg);
+            else
+               Error_Msg_Sem
+                 ("logical operators must have two parameters", Subprg);
+            end if;
          when Name_Op_Plus
            | Name_Op_Minus =>
             --  LRM93 2.3.1
@@ -1513,7 +1537,7 @@
    begin
       --  Set depth.
       declare
-         Parent : Iir := Get_Parent (Subprg);
+         Parent : constant Iir := Get_Parent (Subprg);
       begin
          case Get_Kind (Parent) is
             when Iir_Kind_Function_Declaration
@@ -1542,12 +1566,14 @@
             Sem_Interface_Chain (Interface_Chain, Interface_Function);
             Set_Return_Type
               (Subprg, Sem_Subtype_Indication (Get_Return_Type (Subprg)));
+            Set_All_Sensitized_State (Subprg, Unknown);
          when Iir_Kind_Procedure_Declaration =>
             Sem_Interface_Chain (Interface_Chain, Interface_Procedure);
             --  Unless the body is analyzed, the procedure purity is unknown.
             Set_Purity_State (Subprg, Unknown);
             --  Check if the procedure is passive.
             Set_Passive_Flag (Subprg, True);
+            Set_All_Sensitized_State (Subprg, Unknown);
             declare
                Inter : Iir;
             begin
@@ -1605,7 +1631,7 @@
 
    procedure Add_Analysis_Checks_List (El : Iir)
    is
-      Design : Iir := Get_Current_Design_Unit;
+      Design : constant Iir := Get_Current_Design_Unit;
       List : Iir_List;
    begin
       List := Get_Analysis_Checks_List (Design);
@@ -1625,7 +1651,7 @@
       Set_Impure_Depth (Subprg, Iir_Depth_Pure);
 
       --  LRM 10.1  Declarative regions
-      --  3.  A subprogram declaration, together with thr corresponding
+      --  3.  A subprogram declaration, together with the corresponding
       --     subprogram body.
       Open_Declarative_Region;
       Set_Is_Within_Flag (Spec, True);
@@ -1647,7 +1673,7 @@
 
       case Get_Kind (Spec) is
          when Iir_Kind_Procedure_Declaration =>
-            --  Update purity state of procedure.
+            --  Update purity state of procedure if there are no callees.
             case Get_Purity_State (Spec) is
                when Pure
                  | Maybe_Impure =>
@@ -1666,7 +1692,8 @@
                      end if;
                   end if;
             end case;
-            --  Update wait state if necessary.
+
+            --  Update wait state if the state of all callees is known.
             if Get_Wait_State (Spec) = Unknown then
                declare
                   Callees : Iir_List;
@@ -1706,6 +1733,17 @@
                   end if;
                end;
             end if;
+
+            --  Set All_Sensitized_State in trivial cases.
+            if Get_All_Sensitized_State (Spec) = Unknown
+              and then Get_Callees_List (Spec) = Null_Iir_List
+            then
+               Set_All_Sensitized_State (Spec, No_Signal);
+            end if;
+
+            --  Do not add to Analysis_Check_List as procedures can't
+            --  generate purity/wait/all-sensitized errors by themselves.
+
          when Iir_Kind_Function_Declaration =>
             if Get_Callees_List (Spec) /= Null_Iir_List then
                --  Purity calls to be checked later.
@@ -1720,11 +1758,11 @@
    --  Status of Update_And_Check_Pure_Wait.
    type Update_Pure_Status is
      (
-      --  The purity is computed and known.
+      --  The purity/wait/all-sensitized are computed and known.
       Update_Pure_Done,
-      --  A missing body prevents from computing the purity.
+      --  A missing body prevents from computing the purity/wait/all-sensitized
       Update_Pure_Missing,
-      --  Purity is unknown (recursion).
+      --  Purity/wait/all-sensitized is unknown (recursion).
       Update_Pure_Unknown
      );
    function Update_And_Check_Pure_Wait (Subprg : Iir)
@@ -1752,7 +1790,6 @@
       --  Current purity depth of SUBPRG.
       Depth : Iir_Int32;
       Depth_Callee : Iir_Int32;
-      Has_Pure_Errors : Boolean := False;
       Has_Wait_Errors : Boolean := False;
       Npos : Natural;
       Res, Res1 : Update_Pure_Status;
@@ -1767,24 +1804,32 @@
             else
                Depth := Iir_Depth_Impure;
             end if;
+
          when Iir_Kind_Procedure_Declaration =>
             Kind := K_Procedure;
             if Get_Purity_State (Subprg) = Impure
               and then Get_Wait_State (Subprg) /= Unknown
+              and then Get_All_Sensitized_State (Subprg) /= Unknown
             then
                --  No need to go further.
-               Destroy_Iir_List (Callees_List);
-               Set_Callees_List (Subprg, Null_Iir_List);
+               if Get_All_Sensitized_State (Subprg) = No_Signal
+                 or else Vhdl_Std < Vhdl_08
+               then
+                  Destroy_Iir_List (Callees_List);
+                  Set_Callees_List (Subprg, Null_Iir_List);
+               end if;
                return Update_Pure_Done;
             end if;
             Subprg_Bod := Get_Subprogram_Body (Subprg);
             Subprg_Depth := Get_Subprogram_Depth (Subprg);
             Depth := Get_Impure_Depth (Subprg_Bod);
+
          when Iir_Kind_Sensitized_Process_Statement =>
             Kind := K_Process;
             Subprg_Bod := Null_Iir;
             Subprg_Depth := Iir_Depth_Top;
             Depth := Iir_Depth_Impure;
+
          when others =>
             Error_Kind ("update_and_check_pure_wait(1)", Subprg);
       end case;
@@ -1815,12 +1860,9 @@
             Callee := Get_Nth_Element (Callees_List, I);
             exit when Callee = Null_Iir;
 
-            --  Only procedures should appear in the list:
+            --  Note:
             --  Pure functions should not be in the list.
             --  Impure functions must have directly set Purity_State.
-            if Get_Kind (Callee) /= Iir_Kind_Procedure_Declaration then
-               Error_Kind ("update_and_check_pure_wait(3)", Callee);
-            end if;
 
             --  Check pure.
             Callee_Bod := Get_Subprogram_Body (Callee);
@@ -1831,8 +1873,11 @@
                Res := Update_Pure_Missing;
             else
                --  Second loop: recurse if a state is not known.
-               if J = 1 and then (Get_Purity_State (Callee) = Unknown
-                                  or else Get_Wait_State (Callee) = Unknown)
+               if J = 1
+                 and then
+                 (Get_Purity_State (Callee) = Unknown
+                    or else Get_Wait_State (Callee) = Unknown
+                    or else Get_All_Sensitized_State (Callee) = Unknown)
                then
                   Res1 := Update_And_Check_Pure_Wait (Callee);
                   if Res1 = Update_Pure_Missing then
@@ -1852,7 +1897,6 @@
                      Depth_Callee := Iir_Depth_Impure;
                      if Kind = K_Function then
                         Error_Pure (Subprg, Callee, Null_Iir);
-                        Has_Pure_Errors := True;
                      end if;
                   end if;
 
@@ -1882,19 +1926,55 @@
                end if;
             end if;
 
+            if Get_All_Sensitized_State (Callee) = Invalid_Signal then
+               case Kind is
+                  when K_Function | K_Procedure =>
+                     Set_All_Sensitized_State (Subprg, Invalid_Signal);
+                  when K_Process =>
+                     --  LRM08 11.3
+                     --
+                     --  It is an error if a process statement with the
+                     --  reserved word ALL as its process sensitivity list
+                     --  is the parent of a subprogram declared in a design
+                     --  unit other than that containing the process statement
+                     --  and the subprogram reads an explicitly declared
+                     --  signal that is not a formal signal parameter or
+                     --  member of a formal signal parameter of the
+                     --  subprogram or of any of its parents.  Similarly,
+                     --  it is an error if such subprogram reads an implicit
+                     --  signal whose explicit ancestor is not a formal signal
+                     --  parameter or member of a formal parameter of
+                     --  the subprogram or of any of its parents.
+                     Error_Msg_Sem
+                       ("all-sensitized " & Disp_Node (Subprg)
+                          & " can't call " & Disp_Node (Callee), Subprg);
+                     Error_Msg_Sem
+                       (" (as this subprogram reads (indirectly) a signal)",
+                        Subprg);
+               end case;
+            end if;
+
             --  Keep in list.
             if Callee_Bod = Null_Iir
-              or else (Get_Purity_State (Callee) = Unknown
-                       and then Depth /= Iir_Depth_Impure)
-              or else (Get_Wait_State (Callee) = Unknown
-                       and then (Kind /= K_Procedure
-                                 or else Get_Wait_State (Subprg) = Unknown))
+              or else
+              (Get_Purity_State (Callee) = Unknown
+                 and then Depth /= Iir_Depth_Impure)
+              or else
+              (Get_Wait_State (Callee) = Unknown
+                 and then (Kind /= K_Procedure
+                             or else Get_Wait_State (Subprg) = Unknown))
+              or else
+              (Vhdl_Std >= Vhdl_08
+                 and then
+                 (Get_All_Sensitized_State (Callee) = Unknown
+                    or else Get_All_Sensitized_State (Callee) = Read_Signal))
             then
                Replace_Nth_Element (Callees_List, Npos, Callee);
                Npos := Npos + 1;
             end if;
          end loop;
 
+         --  End of callee loop.
          if Npos = 0 then
             Destroy_Iir_List (Callees_List);
             Callees_List := Null_Iir_List;
@@ -1906,6 +1986,11 @@
                   Set_Wait_State (Subprg, False);
                end if;
             end if;
+            if Kind = K_Procedure or Kind = K_Function then
+               if Get_All_Sensitized_State (Subprg) = Unknown then
+                  Set_All_Sensitized_State (Subprg, No_Signal);
+               end if;
+            end if;
             Res := Update_Pure_Done;
             exit;
          else
@@ -1918,6 +2003,9 @@
       return Res;
    end Update_And_Check_Pure_Wait;
 
+   --  Check pure/wait/all-sensitized issues for SUBPRG (subprogram or
+   --  process).  Return False if the analysis is incomplete (and must
+   --  be deferred).
    function Root_Update_And_Check_Pure_Wait (Subprg : Iir) return Boolean
    is
       Res : Update_Pure_Status;
@@ -1939,6 +2027,11 @@
                   Set_Wait_State (Subprg, False);
                end if;
             end if;
+            if Get_Kind (Subprg) in Iir_Kinds_Subprogram_Declaration then
+               if Get_All_Sensitized_State (Subprg) = Unknown then
+                  Set_All_Sensitized_State (Subprg, No_Signal);
+               end if;
+            end if;
             return True;
       end case;
    end Root_Update_And_Check_Pure_Wait;
diff -urN ghdl-0.27/vhdl/sem.ads ghdl-0.28dev/vhdl/sem.ads
--- ghdl-0.27/vhdl/sem.ads	2005-09-22 23:15:29.000000000 +0200
+++ ghdl-0.28dev/vhdl/sem.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
diff -urN ghdl-0.27/vhdl/sem_assocs.adb ghdl-0.28dev/vhdl/sem_assocs.adb
--- ghdl-0.27/vhdl/sem_assocs.adb	2007-03-14 00:22:40.000000000 +0100
+++ ghdl-0.28dev/vhdl/sem_assocs.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,12 +12,12 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Evaluation; use Evaluation;
 with Errorout; use Errorout;
-with Flags;
+with Flags; use Flags;
 with Types; use Types;
 with Iirs_Utils; use Iirs_Utils;
 with Sem_Names; use Sem_Names;
@@ -638,16 +638,14 @@
 
    procedure Finish_Individual_Assoc_Record (Assoc : Iir; Atype : Iir)
    is
-      Base_Type : Iir_Record_Type_Definition;
-      Matches : Iir_Array_Acc;
+      Base_Type : constant Iir_Record_Type_Definition := Get_Base_Type (Atype);
+      El_List : constant Iir_List := Get_Elements_Declaration_List (Base_Type);
+      Matches : Iir_Array (0 .. Get_Nbr_Elements (El_List) - 1);
       Ch : Iir;
       Pos : Natural;
       Rec_El : Iir;
    begin
-      Base_Type := Get_Base_Type (Atype);
-      Matches := new Iir_Array
-        (0 .. Natural (Get_Number_Element_Declaration (Base_Type)) - 1);
-      Matches.all := (others => Null_Iir);
+      Matches := (others => Null_Iir);
       Ch := Get_Individual_Association_Chain (Assoc);
       while Ch /= Null_Iir loop
          Rec_El := Get_Name (Ch);
@@ -661,12 +659,11 @@
          end if;
          Ch := Get_Chain (Ch);
       end loop;
-      Rec_El := Get_Element_Declaration_Chain (Base_Type);
       for I in Matches'Range loop
+         Rec_El := Get_Nth_Element (El_List, I);
          if Matches (I) = Null_Iir then
             Error_Msg_Sem (Disp_Node (Rec_El) & " not associated", Assoc);
          end if;
-         Rec_El := Get_Chain (Rec_El);
       end loop;
       Set_Actual_Type (Assoc, Atype);
    end Finish_Individual_Assoc_Record;
@@ -689,10 +686,11 @@
       case Get_Kind (Atype) is
          when Iir_Kind_Array_Subtype_Definition =>
             Finish_Individual_Assoc_Array_Subtype (Assoc, Atype);
-         when Iir_Kind_Array_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition =>
-            Set_Actual_Type
-              (Assoc, Create_Array_Subtype (Atype, Get_Location (Assoc)));
+         when Iir_Kind_Array_Type_Definition =>
+            Atype := Create_Array_Subtype (Atype, Get_Location (Assoc));
+            Set_Index_Constraint_Flag (Atype, True);
+            Set_Constraint_State (Atype, Fully_Constrained);
+            Set_Actual_Type (Assoc, Atype);
             Finish_Individual_Assoc_Array (Assoc, Assoc, 1);
          when Iir_Kind_Record_Type_Definition
            | Iir_Kind_Record_Subtype_Definition =>
@@ -756,36 +754,6 @@
       Finish_Individual_Association (Iassoc);
    end Sem_Individual_Association;
 
-
-   --  EXPR is a formal or actual expression.
-   --  Extract conversion function CONV from EXPR, if:
-   --  * argument of the function is of type ARG_TYPE.
-   --  * return type of the function is RES_TYPE if RES_TYPE /= Null_Iir
-   --    or any type if RES_TYPE = Null_Iir.
---    procedure Sem_Conversion (Expr : in out Iir; Conv : out Iir)
---    is
---       Assoc : Iir;
---    begin
---       Conv := Null_Iir;
---       case Get_Kind (Expr) is
---          when Iir_Kind_Parenthesis_Name =>
---             raise Internal_Error;
---          when Iir_Kind_Function_Call =>
---             Conv := Get_Implementation (Expr);
---             Assoc := Get_Parameter_Association_Chain (Expr);
---             Expr := Get_Actual (Assoc);
---             Free_Iir (Assoc);
---             Set_Use_Flag (Conv, True);
---          when Iir_Kind_Type_Conversion =>
---             Assoc := Get_Expression (Expr);
---             Conv := Expr;
---             Expr := Assoc;
---             --Set_Expression (Conv, Null_Iir);
---          when others =>
---             return;
---       end case;
---    end Sem_Conversion;
-
    function Is_Conversion_Function (Assoc_Chain : Iir) return Boolean
    is
    begin
@@ -955,8 +923,8 @@
                Name_Type := Null_Iir;
                return;
             end if;
-            Rec_El := Find_Name_In_Chain
-              (Get_Element_Declaration_Chain (Base_Type),
+            Rec_El := Find_Name_In_List
+              (Get_Elements_Declaration_List (Base_Type),
                Get_Suffix_Identifier (Name));
             if Rec_El = Null_Iir then
                Name_Type := Null_Iir;
@@ -1394,14 +1362,48 @@
          end if;
       end if;
 
+      --  LRM08 6.5.7 Association lists
+      --  The formal part of a named association element may be in the form of
+      --  a function call [...] if and only if the formal is an interface
+      --  object, the mode of the formal is OUT, INOUT, BUFFER or LINKAGE [...]
       Set_Out_Conversion (Assoc, Out_Conv);
+      if Out_Conv /= Null_Iir
+        and then Get_Mode (Inter) = Iir_In_Mode
+      then
+         Error_Msg_Sem
+           ("can't use an out conversion for an in interface", Assoc);
+      end if;
+
+      --  LRM08 6.5.7 Association lists
+      --  The actual part of an association element may be in the form of a
+      --  function call [...] if and only if the mode of the format is IN,
+      --  INOUT or LINKAGE [...]
       Set_In_Conversion (Assoc, In_Conv);
+      if In_Conv /= Null_Iir
+        and then Get_Mode (Inter) in Iir_Buffer_Mode .. Iir_Out_Mode
+      then
+         Error_Msg_Sem
+           ("can't use an in conversion for an out/buffer interface", Assoc);
+      end if;
+
+      --  FIXME: LRM refs
+      --  This is somewhat wrong.  A missing conversion is not an error but
+      --  may result in a type mismatch.
+      if Get_Mode (Inter) = Iir_Inout_Mode then
+         if In_Conv = Null_Iir and then Out_Conv /= Null_Iir then
+            Error_Msg_Sem
+              ("out conversion without corresponding in conversion", Assoc);
+         elsif In_Conv /= Null_Iir and then Out_Conv = Null_Iir then
+            Error_Msg_Sem
+              ("in conversion without corresponding out conversion", Assoc);
+         end if;
+      end if;
       Set_Actual (Assoc, Actual);
 
       --  Semantize actual.
       Expr := Sem_Expression (Actual, Res_Type);
       if Expr /= Null_Iir then
-         Expr := Eval_Expr_If_Static (Expr);
+         Expr := Eval_Expr_Check_If_Static (Expr, Res_Type);
          Set_Actual (Assoc, Expr);
          if In_Conv = Null_Iir and then Out_Conv = Null_Iir then
             if not Check_Implicit_Conversion (Formal_Type, Expr) then
@@ -1667,7 +1669,7 @@
                         if not Finish then
                            raise Internal_Error;
                         end if;
-                        if Is_Unconstrained_Type_Definition (Get_Type (Inter))
+                        if not Is_Fully_Constrained_Type (Get_Type (Inter))
                         then
                            Error_Msg_Sem
                              ("unconstrained " & Disp_Node (Inter)
diff -urN ghdl-0.27/vhdl/sem_assocs.ads ghdl-0.28dev/vhdl/sem_assocs.ads
--- ghdl-0.27/vhdl/sem_assocs.ads	2005-09-22 23:15:42.000000000 +0200
+++ ghdl-0.28dev/vhdl/sem_assocs.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
diff -urN ghdl-0.27/vhdl/sem_decls.adb ghdl-0.28dev/vhdl/sem_decls.adb
--- ghdl-0.27/vhdl/sem_decls.adb	2008-05-31 10:49:44.000000000 +0200
+++ ghdl-0.28dev/vhdl/sem_decls.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,14 +12,14 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Errorout; use Errorout;
 with Types; use Types;
 with Std_Names;
 with Tokens;
-with Flags;
+with Flags; use Flags;
 with Std_Package; use Std_Package;
 with Iir_Chains;
 with Evaluation; use Evaluation;
@@ -31,8 +31,8 @@
 with Sem_Names; use Sem_Names;
 with Sem_Specs; use Sem_Specs;
 with Sem_Types; use Sem_Types;
-with Iir_Chains; use Iir_Chains;
 with Xrefs; use Xrefs;
+use Iir_Chains;
 
 package body Sem_Decls is
    --  Emit an error if the type of DECL is a file type, access type,
@@ -88,6 +88,8 @@
             if Default_Value /= Null_Iir and then A_Type /= Null_Iir then
                Deferred_Constant_Allowed := True;
                Default_Value := Sem_Expression (Default_Value, A_Type);
+               Default_Value :=
+                 Eval_Expr_Check_If_Static (Default_Value, A_Type);
                Deferred_Constant_Allowed := False;
                Check_Read (Default_Value);
             end if;
@@ -307,6 +309,12 @@
       end loop;
    end Sem_Interface_Chain;
 
+   function Is_One_Dimensional (Array_Def : Iir) return Boolean
+   is
+   begin
+      return Get_Nbr_Elements (Get_Index_Subtype_List (Array_Def)) = 1;
+   end Is_One_Dimensional;
+
    --  LRM93 7.2.2
    --  A discrete array is a one-dimensional array whose elements are of a
    --  discrete type.
@@ -321,7 +329,7 @@
             raise Internal_Error;
             -- return False;
       end case;
-      if Get_Nbr_Elements (Get_Index_Subtype_List (Def)) /= 1 then
+      if not Is_One_Dimensional (Def) then
          return False;
       end if;
       if Get_Kind (Get_Element_Subtype (Def))
@@ -454,20 +462,20 @@
       Set_Mode (Inter, Iir_Out_Mode);
       Set_Base_Name (Inter, Inter);
       Append (Last_Interface, Proc, Inter);
-      case Get_Kind (Type_Mark) is
-         when Iir_Kind_Array_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition =>
-            Inter := Create_Iir (Iir_Kind_Variable_Interface_Declaration);
-            Set_Identifier (Inter, Std_Names.Name_Length);
-            Set_Location (Inter, Loc);
-            Set_Type (Inter, Std_Package.Natural_Subtype_Definition);
-            Set_Mode (Inter, Iir_Out_Mode);
-            Set_Base_Name (Inter, Inter);
-            Append (Last_Interface, Proc, Inter);
-            Set_Implicit_Definition (Proc, Iir_Predefined_Read_Length);
-         when others =>
-            Set_Implicit_Definition (Proc, Iir_Predefined_Read);
-      end case;
+      if Get_Kind (Type_Mark) in Iir_Kinds_Array_Type_Definition
+        and then Get_Constraint_State (Type_Mark) /= Fully_Constrained
+      then
+         Inter := Create_Iir (Iir_Kind_Variable_Interface_Declaration);
+         Set_Identifier (Inter, Std_Names.Name_Length);
+         Set_Location (Inter, Loc);
+         Set_Type (Inter, Std_Package.Natural_Subtype_Definition);
+         Set_Mode (Inter, Iir_Out_Mode);
+         Set_Base_Name (Inter, Inter);
+         Append (Last_Interface, Proc, Inter);
+         Set_Implicit_Definition (Proc, Iir_Predefined_Read_Length);
+      else
+         Set_Implicit_Definition (Proc, Iir_Predefined_Read);
+      end if;
       Compute_Subprogram_Hash (Proc);
       -- Add it to the list.
       Insert_Incr (Last, Proc);
@@ -656,33 +664,54 @@
 
                Element_Type := Get_Element_Subtype (Type_Definition);
 
-               Add_Operation (Name_Op_Concatenation,
-                              Iir_Predefined_Array_Array_Concat,
-                              Binary_Chain,
-                              Type_Definition);
-
-               Inter_Chain := Create_Anonymous_Interface (Element_Type);
-               Set_Chain (Inter_Chain, Unary_Chain);
-               Add_Operation (Name_Op_Concatenation,
-                              Iir_Predefined_Element_Array_Concat,
+               if Is_One_Dimensional (Type_Definition) then
+                  Add_Operation (Name_Op_Concatenation,
+                                 Iir_Predefined_Array_Array_Concat,
+                                 Binary_Chain,
+                                 Type_Definition);
+
+                  Inter_Chain := Create_Anonymous_Interface (Element_Type);
+                  Set_Chain (Inter_Chain, Unary_Chain);
+                  Add_Operation (Name_Op_Concatenation,
+                                 Iir_Predefined_Element_Array_Concat,
                               Inter_Chain,
                               Type_Definition);
 
-               Inter_Chain := Create_Anonymous_Interface (Type_Definition);
-               Set_Chain (Inter_Chain,
-                          Create_Anonymous_Interface (Element_Type));
-               Add_Operation (Name_Op_Concatenation,
-                              Iir_Predefined_Array_Element_Concat,
-                              Inter_Chain,
-                              Type_Definition);
-
-               Inter_Chain := Create_Anonymous_Interface (Element_Type);
-               Set_Chain (Inter_Chain,
-                          Create_Anonymous_Interface (Element_Type));
-               Add_Operation (Name_Op_Concatenation,
-                              Iir_Predefined_Element_Element_Concat,
-                              Inter_Chain,
-                              Type_Definition);
+                  Inter_Chain := Create_Anonymous_Interface (Type_Definition);
+                  Set_Chain (Inter_Chain,
+                             Create_Anonymous_Interface (Element_Type));
+                  Add_Operation (Name_Op_Concatenation,
+                                 Iir_Predefined_Array_Element_Concat,
+                                 Inter_Chain,
+                                 Type_Definition);
+
+                  Inter_Chain := Create_Anonymous_Interface (Element_Type);
+                  Set_Chain (Inter_Chain,
+                             Create_Anonymous_Interface (Element_Type));
+                  Add_Operation (Name_Op_Concatenation,
+                                 Iir_Predefined_Element_Element_Concat,
+                                 Inter_Chain,
+                                 Type_Definition);
+
+                  --  LRM08 5.3.2.4  Predefined operations on array type
+                  --
+                  --  Given a type declaration that declares a one-dimensional
+                  --  array type T whose element type is a character type that
+                  --  contains only character literals, the following operation
+                  --  is implicitely declared immediately following the type
+                  --  declaration
+                  if Vhdl_Std >= Vhdl_08
+                    and then String_Type_Definition /= Null_Iir
+                    and then Get_Kind (Get_Base_Type (Element_Type))
+                    = Iir_Kind_Enumeration_Type_Definition
+                    and then Get_Only_Characters_Flag (Element_Type)
+                  then
+                     Add_Operation (Name_To_String,
+                                    Iir_Predefined_Array_To_String,
+                                    Unary_Chain,
+                                    String_Type_Definition);
+                  end if;
+               end if;
 
                if Is_Discrete_Array (Type_Definition) then
                   if Element_Type = Std_Package.Boolean_Type_Definition then
@@ -1104,7 +1133,6 @@
    procedure Sem_Subtype_Declaration (Decl: Iir; Is_Global : Boolean)
    is
       Def: Iir;
-      Res: Iir;
    begin
       --  Real hack to skip subtype declarations of anonymous type decls.
       if Get_Visible_Flag (Decl) then
@@ -1121,63 +1149,12 @@
       end if;
 
       if not Is_Anonymous_Type_Definition (Def) then
-         case Get_Kind (Def) is
-            when Iir_Kind_Integer_Subtype_Definition
-              | Iir_Kind_Floating_Subtype_Definition
-              | Iir_Kind_Enumeration_Subtype_Definition
-              | Iir_Kind_Physical_Subtype_Definition =>
-               -- no limits, makes an alias.
-               Res := Create_Iir (Get_Kind (Def));
-               Set_Range_Constraint (Res, Get_Range_Constraint (Def));
-               Set_Resolution_Function (Res, Get_Resolution_Function (Def));
-            when Iir_Kind_Enumeration_Type_Definition =>
-               --  makes an alias.
-               Res := Create_Iir (Iir_Kind_Enumeration_Subtype_Definition);
-               Set_Type_Mark (Res, Def);
-               Set_Range_Constraint (Res, Get_Range_Constraint (Def));
-            when Iir_Kind_Access_Subtype_Definition
-              | Iir_Kind_Access_Type_Definition =>
-               --  Make an alias.
-               Res := Create_Iir (Iir_Kind_Access_Subtype_Definition);
-            when Iir_Kind_Array_Type_Definition
-              | Iir_Kind_Unconstrained_Array_Subtype_Definition =>
-               Res :=
-                 Create_Iir (Iir_Kind_Unconstrained_Array_Subtype_Definition);
-               Set_Type_Staticness (Res, Get_Type_Staticness (Def));
-               if Get_Kind (Def) /= Iir_Kind_Array_Type_Definition then
-                  Set_Resolution_Function
-                    (Res, Get_Resolution_Function (Def));
-               end if;
-               Set_Resolved_Flag (Res, Get_Resolved_Flag (Def));
-               Set_Type_Mark (Res, Def);
-               Set_Index_Subtype_List (Res, Get_Index_Subtype_List (Def));
-               Set_Element_Subtype (Res, Get_Element_Subtype (Def));
-            when Iir_Kind_Array_Subtype_Definition =>
-               Res := Create_Iir (Iir_Kind_Array_Subtype_Definition);
-               Set_Resolution_Function (Res, Get_Resolution_Function (Def));
-               Set_Resolved_Flag (Res, Get_Resolved_Flag (Def));
-               Set_Type_Mark (Res, Def);
-               Set_Index_Subtype_List (Res, Get_Index_Subtype_List (Def));
-               Set_Element_Subtype (Res, Get_Element_Subtype (Def));
-            when Iir_Kind_Record_Type_Definition
-              | Iir_Kind_Record_Subtype_Definition =>
-               Res := Create_Iir (Iir_Kind_Record_Subtype_Definition);
-               Set_Type_Staticness (Res, Get_Type_Staticness (Def));
-               if Get_Kind (Def) /= Iir_Kind_Record_Type_Definition then
-                  Set_Resolution_Function
-                    (Res, Get_Resolution_Function (Def));
-               end if;
-               Set_Resolved_Flag (Res, Get_Resolved_Flag (Def));
-            when others =>
-               --  FIXME: todo
-               Error_Kind ("sem_subtype_declaration", Def);
-         end case;
-         Location_Copy (Res, Decl);
-         Set_Base_Type (Res, Get_Base_Type (Def));
-         Set_Type_Staticness (Res, Get_Type_Staticness (Def));
-         Set_Signal_Type_Flag (Res, Get_Signal_Type_Flag (Def));
-         Def := Res;
+         -- There is no added constraints and therefore the subtype
+         -- declaration is in fact an alias of the type.
+         Def := Copy_Subtype_Indication (Def);
+         Location_Copy (Def, Decl);
       end if;
+
       Set_Type (Decl, Def);
       Set_Type_Declarator (Def, Decl);
       Name_Visible (Decl);
@@ -1267,7 +1244,7 @@
          end if;
       end if;
       Set_Type (Decl, Atype);
-      Default_Value := Eval_Expr_If_Static (Default_Value);
+      Default_Value := Eval_Expr_Check_If_Static (Default_Value, Atype);
       Set_Default_Value (Decl, Default_Value);
       Set_Base_Name (Decl, Decl);
       Set_Name_Staticness (Decl, Locally);
@@ -1360,11 +1337,6 @@
                   end if;
                end if;
                Set_Expr_Staticness (Decl, Staticness);
-
-               if Staticness = Locally then
-                  Set_Default_Value
-                    (Decl, Eval_Expr_Check (Default_Value, Atype));
-               end if;
             end if;
 
          when Iir_Kind_Signal_Declaration =>
@@ -1489,7 +1461,7 @@
             --  For a variable or signal declared by an object declaration, the
             --  subtype indication of the corressponding object declaration
             --  must define a constrained array subtype.
-            if not Sem_Is_Constrained (Atype) then
+            if not Is_Fully_Constrained_Type (Atype) then
                Error_Msg_Sem
                  ("declaration of " & Disp_Node (Decl)
                   & " with unconstrained " & Disp_Node (Atype)
diff -urN ghdl-0.27/vhdl/sem_decls.ads ghdl-0.28dev/vhdl/sem_decls.ads
--- ghdl-0.27/vhdl/sem_decls.ads	2005-10-27 21:36:44.000000000 +0200
+++ ghdl-0.28dev/vhdl/sem_decls.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
diff -urN ghdl-0.27/vhdl/sem_expr.adb ghdl-0.28dev/vhdl/sem_expr.adb
--- ghdl-0.27/vhdl/sem_expr.adb	2008-04-25 06:10:31.000000000 +0200
+++ ghdl-0.28dev/vhdl/sem_expr.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,13 +12,12 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
-with Types; use Types;
 with Std_Package; use Std_Package;
 with Errorout; use Errorout;
-with Flags;
+with Flags; use Flags;
 with Sem_Scopes; use Sem_Scopes;
 with Sem_Names; use Sem_Names;
 with Sem;
@@ -169,6 +168,7 @@
            | Iir_Kind_Component_Declaration
            | Iir_Kinds_Procedure_Declaration
            | Iir_Kind_Range_Array_Attribute
+           | Iir_Kind_Reverse_Range_Array_Attribute
            | Iir_Kind_Element_Declaration =>
             Error_Msg_Sem (Disp_Node (Expr)
                            & " not allowed in an expression", Loc);
@@ -229,12 +229,15 @@
       if Targ_Type = Null_Iir or else Expr = Null_Iir then
          return True;
       end if;
-      if Get_Kind (Targ_Type) /= Iir_Kind_Array_Subtype_Definition then
+      if Get_Kind (Targ_Type) /= Iir_Kind_Array_Subtype_Definition
+        or else Get_Constraint_State (Targ_Type) /= Fully_Constrained
+      then
          return True;
       end if;
       Expr_Type := Get_Type (Expr);
       if Expr_Type = Null_Iir
         or else Get_Kind (Expr_Type) /= Iir_Kind_Array_Subtype_Definition
+        or else Get_Constraint_State (Expr_Type) /= Fully_Constrained
       then
          return True;
       end if;
@@ -646,10 +649,18 @@
          --  FIXME: catch phys/phys.
          Set_Type (Expr, Integer_Type_Definition);
       elsif Range_Type = Universal_Integer_Type_Definition then
-         --  GHDL: this is not allowed, however often used:
-         --  eg: for i in 0 to v'length + 1 loop
-         --  eg: for i in -1 to 1 loop
-         if Flags.Vhdl_Std = Vhdl_93c then
+         if Vhdl_Std >= Vhdl_08 then
+            --  LRM08 5.3.2.2
+            --  For a discrete range used in a constrained array definition
+            --  and defined by a range, an implicit conversion to the
+            --  predefined type INTEGER is assumed if the type of both bounds
+            --  (prior the implicit conversion) is the type universal_integer.
+            null;
+         elsif Vhdl_Std = Vhdl_93c then
+            --  GHDL: this is not allowed, however often used:
+            --  eg: for i in 0 to v'length + 1 loop
+            --  eg: for i in -1 to 1 loop
+
             --  Be tolerant.
             Warning_Msg_Sem ("universal integer bound must be numeric literal "
                              & "or attribute", Expr);
@@ -731,8 +742,8 @@
       Set_Expr_Staticness (Expr, Staticness);
    end Set_Function_Call_Staticness;
 
-   --  Add CALLEE in the calle list of SUBPRG (which must be a subprg decl).
-   procedure Add_In_Callee_List (Subprg : Iir; Callee : Iir)
+   --  Add CALLEE in the callees list of SUBPRG (which must be a subprg decl).
+   procedure Add_In_Callees_List (Subprg : Iir; Callee : Iir)
    is
       List : Iir_List;
    begin
@@ -744,7 +755,7 @@
       --  FIXME: May use a flag in IMP to speed up the
       --  add operation.
       Add_Element (List, Callee);
-   end Add_In_Callee_List;
+   end Add_In_Callees_List;
 
    --  Check purity rules when SUBPRG calls CALLEE.
    --  Both SUBPRG and CALLEE are subprogram declarations.
@@ -809,7 +820,7 @@
                      Depth := Get_Impure_Depth (Callee_Body);
                   when Unknown =>
                      --  Add in list.
-                     Add_In_Callee_List (Subprg, Callee);
+                     Add_In_Callees_List (Subprg, Callee);
 
                      if Callee_Body /= Null_Iir then
                         Depth := Get_Impure_Depth (Callee_Body);
@@ -868,7 +879,7 @@
          when True =>
             null;
          when Unknown =>
-            Add_In_Callee_List (Subprg, Callee);
+            Add_In_Callees_List (Subprg, Callee);
             return;
       end case;
 
@@ -898,13 +909,88 @@
       end case;
    end Sem_Call_Wait_Check;
 
+   procedure Sem_Call_All_Sensitized_Check
+     (Subprg : Iir; Callee : Iir; Loc : Iir)
+   is
+   begin
+      --  No need to deal with 'process (all)' if standard predates it.
+      if Vhdl_Std < Vhdl_08 then
+         return;
+      end if;
+
+      --  If subprogram called is pure, then there is no signals reference.
+      case Get_Kind (Callee) is
+         when Iir_Kind_Function_Declaration =>
+            if Get_Pure_Flag (Callee) then
+               return;
+            end if;
+         when Iir_Kind_Procedure_Declaration =>
+            if Get_Purity_State (Callee) = Pure then
+               return;
+            end if;
+         when others =>
+            Error_Kind ("sem_call_all_sensitized_check", Callee);
+      end case;
+
+      case Get_All_Sensitized_State (Callee) is
+         when Invalid_Signal =>
+            case Get_Kind (Subprg) is
+               when Iir_Kind_Sensitized_Process_Statement =>
+                  if Get_Sensitivity_List (Subprg) = Iir_List_All then
+                     --  LRM08 11.3
+                     --
+                     --  It is an error if a process statement with the
+                     --  reserved word ALL as its process sensitivity list
+                     --  is the parent of a subprogram declared in a design
+                     --  unit other than that containing the process statement
+                     --  and the subprogram reads an explicitly declared
+                     --  signal that is not a formal signal parameter or
+                     --  member of a formal signal parameter of the
+                     --  subprogram or of any of its parents.  Similarly,
+                     --  it is an error if such subprogram reads an implicit
+                     --  signal whose explicit ancestor is not a formal signal
+                     --  parameter or member of a formal parameter of
+                     --  the subprogram or of any of its parents.
+                     Error_Msg_Sem
+                       ("all-sensitized " & Disp_Node (Subprg)
+                          & " can't call " & Disp_Node (Callee), Loc);
+                     Error_Msg_Sem
+                       (" (as this subprogram reads (indirectly) a signal)",
+                        Loc);
+                  end if;
+               when Iir_Kind_Process_Statement =>
+                  return;
+               when Iir_Kind_Function_Declaration
+                 | Iir_Kind_Procedure_Declaration =>
+                  Set_All_Sensitized_State (Subprg, Invalid_Signal);
+               when others =>
+                  Error_Kind ("sem_call_all_sensitized_check", Subprg);
+            end case;
+         when Read_Signal =>
+            --  Put this subprogram in callees list as it may read a signal.
+            --  Used by canon to build the sensitivity list.
+            Add_In_Callees_List (Subprg, Callee);
+            if Get_Kind (Subprg) in Iir_Kinds_Subprogram_Declaration then
+               if Get_All_Sensitized_State (Subprg) < Read_Signal then
+                  Set_All_Sensitized_State (Subprg, Read_Signal);
+               end if;
+            end if;
+         when Unknown =>
+            --  Put this subprogram in callees list as it may read a signal.
+            --  Used by canon to build the sensitivity list.
+            Add_In_Callees_List (Subprg, Callee);
+         when No_Signal =>
+            null;
+      end case;
+   end Sem_Call_All_Sensitized_Check;
+
    --  Set IMP as the implementation to being called by EXPR.
    --  If the context is a subprogram or a process (ie, if current_subprogram
    --  is not NULL), then mark IMP as callee of current_subprogram, and
    --  update states.
    procedure Sem_Subprogram_Call_Finish (Expr : Iir; Imp : Iir)
    is
-      Subprg : Iir := Get_Current_Subprogram;
+      Subprg : constant Iir := Get_Current_Subprogram;
    begin
       Set_Implementation (Expr, Imp);
       Set_Function_Call_Staticness (Expr, Imp);
@@ -930,9 +1016,11 @@
             end if;
          when Iir_Kind_Function_Declaration =>
             Sem_Call_Purity_Check (Subprg, Imp, Expr);
+            Sem_Call_All_Sensitized_Check (Subprg, Imp, Expr);
          when Iir_Kind_Procedure_Declaration =>
             Sem_Call_Purity_Check (Subprg, Imp, Expr);
             Sem_Call_Wait_Check (Subprg, Imp, Expr);
+            Sem_Call_All_Sensitized_Check (Subprg, Imp, Expr);
             --  Check passive.
             if Get_Passive_Flag (Imp) = False then
                case Get_Kind (Subprg) is
@@ -1225,8 +1313,6 @@
 
    procedure Sem_Procedure_Call (Call : Iir_Procedure_Call; Stmt : Iir)
    is
-      use Iirs_Utils;
-
       Imp: Iir;
       Name : Iir;
       Parameters_Chain : Iir;
@@ -1645,7 +1731,7 @@
    function Check_Type_For_String_Literal (A_Type : Iir; Expr : Iir)
                                           return Boolean
    is
-      Base_Type : Iir := Get_Base_Type (A_Type);
+      Base_Type : constant Iir := Get_Base_Type (A_Type);
       El_Bt : Iir;
    begin
       --  LRM 7.3.1
@@ -1711,6 +1797,7 @@
 
       Ptr : String_Fat_Acc;
       El : Iir;
+      pragma Unreferenced (El);
       Len : Natural;
    begin
       Len := Get_String_Length (Lit);
@@ -1751,48 +1838,231 @@
       El_Type := Get_Base_Type (Get_Element_Subtype (Lit_Base_Type));
       Len := Sem_String_Literal (Lit, El_Type);
 
-      case Get_Kind (Lit_Type) is
-         when Iir_Kind_Array_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition =>
-            -- Set type of the string literal,
-            -- according to LRM93 7.3.2.2.
-            N_Type := Create_Unidim_Array_By_Length
-              (Lit_Base_Type, Iir_Int64 (Len), Lit);
-            Set_Type (Lit, N_Type);
-         when Iir_Kind_Array_Subtype_Definition =>
-            Index_Type := Get_First_Element
-              (Get_Index_Subtype_List (Lit_Type));
-            if Get_Type_Staticness (Index_Type) = Locally then
-               if Eval_Discrete_Type_Length (Index_Type) /= Iir_Int64 (Len)
-               then
-                  Error_Msg_Sem ("string length does not match that of "
-                                 & Disp_Node (Index_Type), Lit);
-               end if;
-            else
-               --  FIXME: It this right ?
-               --  We really need a locally static type.
-               N_Type := Create_Unidim_Array_By_Length
-                 (Lit_Base_Type, Iir_Int64 (Len), Lit);
-               Set_Type (Lit, N_Type);
+      if Get_Constraint_State (Lit_Type) = Fully_Constrained then
+         Index_Type := Get_First_Element
+           (Get_Index_Subtype_List (Lit_Type));
+         if Get_Type_Staticness (Index_Type) = Locally then
+            if Eval_Discrete_Type_Length (Index_Type) /= Iir_Int64 (Len)
+            then
+               Error_Msg_Sem ("string length does not match that of "
+                                & Disp_Node (Index_Type), Lit);
             end if;
-         when others =>
-            Error_Kind ("sem_string_literal_type", Lit_Type);
-      end case;
+            return;
+         end if;
+      end if;
+
+      -- Set type of the string literal,
+      -- according to LRM93 7.3.2.2.
+      N_Type := Create_Unidim_Array_By_Length
+        (Lit_Base_Type, Iir_Int64 (Len), Lit);
+      Set_Type (Lit, N_Type);
    end Sem_String_Literal;
 
+   generic
+      --  Compare two elements, return true iff OP1 < OP2.
+      with function Lt (Op1, Op2 : Natural) return Boolean;
+
+      --  Swap two elements.
+      with procedure Swap (From : Natural; To : Natural);
+   package Heap_Sort is
+      --  Heap sort the N elements.
+      procedure Sort (N : Natural);
+   end Heap_Sort;
+
+   package body Heap_Sort is
+      --  An heap is an almost complete binary tree whose each edge is less
+      --  than or equal as its decendent.
+
+      --  Bubble down element I of a partially ordered heap of length N in
+      --  array ARR.
+      procedure Bubble_Down (I, N : Natural)
+      is
+         Child : Natural;
+         Parent : Natural := I;
+      begin
+         loop
+            Child := 2 * Parent;
+            if Child < N and then Lt (Child, Child + 1) then
+               Child := Child + 1;
+            end if;
+            exit when Child > N;
+            exit when not Lt (Parent, Child);
+            Swap (Parent, Child);
+            Parent := Child;
+         end loop;
+      end Bubble_Down;
+
+      --  Heap sort of ARR.
+      procedure Sort (N : Natural)
+      is
+      begin
+         --  Heapify
+         for I in reverse 1 .. N / 2 loop
+            Bubble_Down (I, N);
+         end loop;
+
+         --  Sort
+         for I in reverse 2 .. N loop
+            Swap (1, I);
+            Bubble_Down (1, I - 1);
+         end loop;
+      end Sort;
+   end Heap_Sort;
+
    procedure Sem_String_Choices_Range (Choice_Chain : Iir; Sel : Iir)
    is
       --  True if others choice is present.
       Has_Others : Boolean;
 
+      --  Number of simple choices.
+      Nbr_Choices : Natural;
+
       --  Type of SEL.
       Sel_Type : Iir;
 
+      --  Type of the element of SEL.
+      Sel_El_Type : Iir;
+      --  Number of literals in the element type.
+      Sel_El_Length : Iir_Int64;
+      --  List of literals.
+      Sel_El_Literal_List : Iir_List;
+
       --  Length of SEL (number of characters in SEL).
       Sel_Length : Iir_Int64;
 
+      --  Array of choices.
+      Arr : Iir_Array_Acc;
+      Index : Natural;
+
+      --  True if length of a choice mismatches
+      Has_Length_Error : Boolean := False;
+
       El : Iir;
 
+      type Str_Info is record
+         El : Iir;
+         Ptr : String_Fat_Acc;
+         Len : Natural;
+         Lit_0 : Iir;
+         Lit_1 : Iir;
+         List : Iir_List;
+      end record;
+
+      --  Fill Res from EL.  This is used to speed up Lt and Eq operations.
+      procedure Get_Info (El : Iir; Res : out Str_Info)
+      is
+         Expr : constant Iir := Get_Expression (El);
+      begin
+         case Get_Kind (Expr) is
+            when Iir_Kind_Simple_Aggregate =>
+               Res := Str_Info'(El => Expr,
+                                Ptr => null,
+                                Len => 0,
+                                Lit_0 | Lit_1 => Null_Iir,
+                                List => Get_Simple_Aggregate_List (Expr));
+               Res.Len := Get_Nbr_Elements (Res.List);
+            when Iir_Kind_Bit_String_Literal =>
+               Res := Str_Info'(El => Expr,
+                                Ptr => Get_String_Fat_Acc (Expr),
+                                Len => Get_String_Length (Expr),
+                                Lit_0 => Get_Bit_String_0 (Expr),
+                                Lit_1 => Get_Bit_String_1 (Expr),
+                                List => Null_Iir_List);
+            when Iir_Kind_String_Literal =>
+               Res := Str_Info'(El => Expr,
+                                Ptr => Get_String_Fat_Acc (Expr),
+                                Len => Get_String_Length (Expr),
+                                Lit_0 | Lit_1 => Null_Iir,
+                                List => Null_Iir_List);
+            when others =>
+               Error_Kind ("sem_string_choice_range.get_info", Expr);
+         end case;
+      end Get_Info;
+
+      --  Return the position of element IDX of STR.
+      function Get_Pos (Str : Str_Info; Idx : Natural) return Iir_Int32
+      is
+         S : Iir;
+         C : Character;
+      begin
+         case Get_Kind (Str.El) is
+            when Iir_Kind_Simple_Aggregate =>
+               S := Get_Nth_Element (Str.List, Idx);
+            when Iir_Kind_String_Literal =>
+               C := Str.Ptr (Idx + 1);
+               --  FIXME: build a table from character to position.
+               --  This linear search is O(n)!
+               S := Find_Name_In_List (Sel_El_Literal_List,
+                                       Name_Table.Get_Identifier (C));
+            when Iir_Kind_Bit_String_Literal =>
+               C := Str.Ptr (Idx + 1);
+               case C is
+                  when '0' =>
+                     S := Str.Lit_0;
+                  when '1' =>
+                     S := Str.Lit_1;
+                  when others =>
+                     raise Internal_Error;
+               end case;
+            when others =>
+               Error_Kind ("sem_string_choice_range.get_pos", Str.El);
+         end case;
+         return Get_Enum_Pos (S);
+      end Get_Pos;
+
+      --  Compare two elements of ARR.
+      --  Return true iff OP1 < OP2.
+      function Lt (Op1, Op2 : Natural) return Boolean
+      is
+         Str1, Str2 : Str_Info;
+         P1, P2 : Iir_Int32;
+      begin
+         Get_Info (Arr (Op1), Str1);
+         Get_Info (Arr (Op2), Str2);
+         if Str1.Len /= Str2.Len then
+            raise Internal_Error;
+         end if;
+
+         for I in 0 .. Natural (Sel_Length - 1) loop
+            P1 := Get_Pos (Str1, I);
+            P2 := Get_Pos (Str2, I);
+            if P1 /= P2 then
+               if P1 < P2 then
+                  return True;
+               else
+                  return False;
+               end if;
+            end if;
+         end loop;
+         return False;
+      end Lt;
+
+      function Eq (Op1, Op2 : Natural) return Boolean
+      is
+         Str1, Str2 : Str_Info;
+      begin
+         Get_Info (Arr (Op1), Str1);
+         Get_Info (Arr (Op2), Str2);
+
+         for I in 0 .. Natural (Sel_Length - 1) loop
+            if Get_Pos (Str1, I) /= Get_Pos (Str2, I) then
+               return False;
+            end if;
+         end loop;
+         return True;
+      end Eq;
+
+      procedure Swap (From : Natural; To : Natural)
+      is
+         Tmp : Iir;
+      begin
+         Tmp := Arr (To);
+         Arr (To) := Arr (From);
+         Arr (From) := Tmp;
+      end Swap;
+
+      package Str_Heap_Sort is new Heap_Sort (Lt => Lt, Swap => Swap);
+
       procedure Sem_Simple_Choice (Choice : Iir)
       is
          Expr : Iir;
@@ -1803,11 +2073,13 @@
          --  the same length as that of the case expression.
          Expr := Sem_Expression (Get_Expression (Choice), Sel_Type);
          if Expr = Null_Iir then
+            Has_Length_Error := True;
             return;
          end if;
          Set_Expression (Choice, Expr);
          if Get_Expr_Staticness (Expr) < Locally then
             Error_Msg_Sem ("choice must be locally static expression", Expr);
+            Has_Length_Error := True;
             return;
          end if;
          Expr := Eval_Expr (Expr);
@@ -1815,6 +2087,7 @@
          if Eval_Discrete_Type_Length
            (Get_String_Type_Bound_Type (Get_Type (Expr))) /= Sel_Length
          then
+            Has_Length_Error := True;
             Error_Msg_Sem
               ("value not of the same length of the case expression", Expr);
             return;
@@ -1837,8 +2110,13 @@
       end if;
       Sel_Length := Eval_Discrete_Type_Length
         (Get_String_Type_Bound_Type (Sel_Type));
+      Sel_El_Type := Get_Element_Subtype (Sel_Type);
+      Sel_El_Length := Eval_Discrete_Type_Length (Sel_El_Type);
+      Sel_El_Literal_List := Get_Enumeration_Literal_List
+        (Get_Base_Type (Sel_El_Type));
 
       Has_Others := False;
+      Nbr_Choices := 0;
       El := Choice_Chain;
       while El /= Null_Iir loop
          case Get_Kind (El) is
@@ -1848,6 +2126,7 @@
                Error_Msg_Sem
                  ("range choice are not allowed for non-discrete type", El);
             when Iir_Kind_Choice_By_Expression =>
+               Nbr_Choices := Nbr_Choices + 1;
                Sem_Simple_Choice (El);
             when Iir_Kind_Choice_By_Others =>
                if Has_Others then
@@ -1863,10 +2142,65 @@
          El := Get_Chain (El);
       end loop;
 
-      -- FIXME:
-      -- * check for duplicate choices.
-      -- * check for leaking choices.
-      -- (should eval strings and bit-strings).
+      --  Null choices.
+      if Sel_Length = 0 then
+         return;
+      end if;
+      if Has_Length_Error then
+         return;
+      end if;
+
+      --  LRM 8.8
+      --
+      --  If the expression is the name of an object whose subtype is locally
+      --  static, wether a scalar type or an array type, then each value of the
+      --  subtype must be represented once and only once in the set of choices
+      --  of the case statement and no other value is allowed; [...]
+
+      -- 1. Allocate Arr and fill it
+      Arr := new Iir_Array (1 .. Nbr_Choices);
+      Index := 0;
+      El := Choice_Chain;
+      while El /= Null_Iir loop
+         if Get_Kind (El) = Iir_Kind_Choice_By_Expression then
+            Index := Index + 1;
+            Arr (Index) := El;
+         end if;
+         El := Get_Chain (El);
+      end loop;
+
+      -- 2. Sort Arr
+      Str_Heap_Sort.Sort (Nbr_Choices);
+
+      -- 3. Check for duplicate choices
+      for I in 1 .. Nbr_Choices - 1 loop
+         if Eq (I, I + 1) then
+            Error_Msg_Sem ("duplicate choice with choice at " &
+                             Disp_Location (Arr (I + 1)),
+                           Arr (I));
+            exit;
+         end if;
+      end loop;
+
+      -- 4. Free Arr
+      Free (Arr);
+
+      --  Check for missing choice.
+      --  Do not try to compute the expected number of choices as this can
+      --  easily overflow.
+      if not Has_Others then
+         declare
+            Nbr : Iir_Int64 := Iir_Int64 (Nbr_Choices);
+         begin
+            for I in 1 .. Sel_Length loop
+               Nbr := Nbr / Sel_El_Length;
+               if Nbr = 0 then
+                  Error_Msg_Sem ("missing choice(s)", Choice_Chain);
+                  exit;
+               end if;
+            end loop;
+         end;
+      end if;
    end Sem_String_Choices_Range;
 
    function Is_Name (Name : Iir) return Boolean
@@ -2040,37 +2374,7 @@
          Arr (From) := Tmp;
       end Swap;
 
-      --  Bubble down element I of a partially ordered heap of length N in
-      --  array ARR.
-      procedure Bubble_Down (I, N : Natural)
-      is
-         Child : Natural;
-      begin
-         Child := 2 * I;
-         if Child < N and then Lt (Child, Child + 1) then
-            Child := Child + 1;
-         end if;
-         if Child <= N and then Lt (I, Child) then
-            Swap (I, Child);
-            Bubble_Down (Child, N);
-         end if;
-      end Bubble_Down;
-
-      --  Heap sort of ARR.
-      procedure Heap_Sort (N : Natural)
-      is
-      begin
-         --  Heapify
-         for I in reverse 1 .. N / 2 loop
-            Bubble_Down (I, N);
-         end loop;
-
-         --  Sort
-         for I in reverse 2 .. N loop
-            Swap (1, I);
-            Bubble_Down (1, I - 1);
-         end loop;
-      end Heap_Sort;
+      package Disc_Heap_Sort is new Heap_Sort (Lt => Lt, Swap => Swap);
    begin
       Low := Null_Iir;
       High := Null_Iir;
@@ -2234,7 +2538,7 @@
 
       --  Third:
       --  Sort the list
-      Heap_Sort (Index);
+      Disc_Heap_Sort.Sort (Index);
 
       --  Set low and high bounds.
       if Index > 0 then
@@ -2406,12 +2710,13 @@
    function Sem_Record_Aggregate (Aggr: Iir_Aggregate; A_Type: Iir)
      return boolean
    is
-      Base_Type : Iir;
+      Base_Type : constant Iir := Get_Base_Type (A_Type);
+      El_List : constant Iir_List := Get_Elements_Declaration_List (Base_Type);
 
       --  Type of the element.
       El_Type : Iir;
 
-      Matches: Iir_Array_Acc;
+      Matches: Iir_Array (0 .. Get_Nbr_Elements (El_List) - 1);
       Ok : Boolean;
 
       --  Add a choice for element REC_EL.
@@ -2420,7 +2725,7 @@
       procedure Add_Match (El : Iir; Rec_El : Iir_Element_Declaration)
       is
          Ass_Type : Iir;
-         Pos : Natural := Natural (Get_Element_Position (Rec_El));
+         Pos : constant Natural := Natural (Get_Element_Position (Rec_El));
       begin
          if Matches (Pos) /= Null_Iir then
             Error_Msg_Sem
@@ -2457,8 +2762,8 @@
             Ok := False;
             return Ass;
          end if;
-         Aggr_El := Find_Name_In_Chain
-           (Get_Element_Declaration_Chain (Base_Type), Get_Identifier (Expr));
+         Aggr_El := Find_Name_In_List
+           (Get_Elements_Declaration_List (Base_Type), Get_Identifier (Expr));
          if Aggr_El = Null_Iir then
             Error_Msg_Sem
               ("record has no such element " & Disp_Node (Ass), Ass);
@@ -2481,20 +2786,17 @@
       El, Prev_El : Iir;
       Expr: Iir;
       Has_Named : Boolean;
-      Rec_El : Iir_Element_Declaration;
+      Rec_El_Index : Natural;
       Value_Staticness : Iir_Staticness;
    begin
       Ok := True;
       Assoc_Chain := Get_Association_Choices_Chain (Aggr);
-      Base_Type := Get_Base_Type (A_Type);
-      Matches := new Iir_Array
-        (0 .. Natural (Get_Number_Element_Declaration (Base_Type)) - 1);
-      Matches.all := (others => Null_Iir);
+      Matches := (others => Null_Iir);
       Value_Staticness := Locally;
 
       El_Type := Null_Iir;
       Has_Named := False;
-      Rec_El := Get_Element_Declaration_Chain (Base_Type);
+      Rec_El_Index := 0;
       Prev_El := Null_Iir;
       El := Assoc_Chain;
       while El /= Null_Iir loop
@@ -2511,12 +2813,12 @@
                if Has_Named then
                   Error_Msg_Sem ("positional association after named one", El);
                   Ok := False;
-               elsif Rec_El = Null_Iir then
+               elsif Rec_El_Index > Matches'Last then
                   Error_Msg_Sem ("too many elements", El);
                   exit;
                else
-                  Add_Match (El, Rec_El);
-                  Rec_El := Get_Chain (Rec_El);
+                  Add_Match (El, Get_Nth_Element (El_List, Rec_El_Index));
+                  Rec_El_Index := Rec_El_Index + 1;
                end if;
             when Iir_Kind_Choice_By_Expression =>
                Has_Named := True;
@@ -2536,17 +2838,13 @@
                end if;
                declare
                   Found : Boolean := False;
-                  Rec_El : Iir_Element_Declaration;
                begin
-                  Rec_El := Get_Element_Declaration_Chain (Base_Type);
-                  for I in Matches.all'Range loop
+                  for I in Matches'Range loop
                      if Matches (I) = Null_Iir then
-                        Add_Match (El, Rec_El);
+                        Add_Match (El, Get_Nth_Element (El_List, I));
                         Found := True;
                      end if;
-                     Rec_El := Get_Chain (Rec_El);
                   end loop;
-                  pragma Assert (Rec_El = Null_Iir);
                   if not Found then
                      Error_Msg_Sem ("no element for choice others", El);
                      Ok := False;
@@ -2580,15 +2878,14 @@
       end loop;
 
       --  Check for missing associations.
-      El := Get_Element_Declaration_Chain (Base_Type);
-      for I in Matches.all'Range loop
+      for I in Matches'Range loop
          if Matches (I) = Null_Iir then
-            Error_Msg_Sem ("no value for " & Disp_Node (El), Aggr);
+            Error_Msg_Sem
+              ("no value for " & Disp_Node (Get_Nth_Element (El_List, I)),
+               Aggr);
             Ok := False;
          end if;
-         El := Get_Chain (El);
       end loop;
-      Free (Matches);
       Set_Value_Staticness (Aggr, Value_Staticness);
       Set_Expr_Staticness (Aggr, Min (Globally, Value_Staticness));
       return Ok;
@@ -2634,7 +2931,6 @@
                                          Constrained : Boolean;
                                          Dim: Natural)
    is
-      Res: Boolean;
       Assoc_Chain : Iir;
       Choice: Iir;
       Is_Positional: Tri_State_Type;
@@ -2655,7 +2951,6 @@
 
       Info : Array_Aggr_Info renames Infos (Dim);
    begin
-      Res := True;
       Index_List := Get_Index_Subtype_List (A_Type);
       Index_Type := Get_Nth_Element (Index_List, Dim - 1);
 
@@ -2813,13 +3108,15 @@
             Set_Base_Type (Info.Index_Subtype, Get_Base_Type (Index_Type));
             Index_Constraint := Get_Range_Constraint (Index_Type);
 
+            --  LRM93 7.3.2.2
+            --  If the aggregate appears in one of the above contexts, then the
+            --  direction of the index subtype of the aggregate is that of the
+            --  corresponding constrained array subtype; [...]
             Index_Subtype_Constraint := Create_Iir (Iir_Kind_Range_Expression);
             Location_Copy (Index_Subtype_Constraint, Aggr);
             Set_Range_Constraint
               (Info.Index_Subtype, Index_Subtype_Constraint);
             Set_Type_Staticness (Info.Index_Subtype, Choice_Staticness);
-            Set_Direction (Index_Subtype_Constraint,
-                           Get_Direction (Index_Constraint));
 
             --  LRM93 7.3.2.2
             --  For an aggregate that has named associations, the leftmost and
@@ -2833,6 +3130,8 @@
                                         Get_Range_Constraint (Index_Type));
                   Free_Iir (Index_Subtype_Constraint);
                else
+                  Set_Direction (Index_Subtype_Constraint,
+                                 Get_Direction (Index_Constraint));
                   case Get_Direction (Index_Constraint) is
                      when Iir_To =>
                         Set_Left_Limit (Index_Subtype_Constraint, Low);
@@ -2852,6 +3151,8 @@
                   Expr := Get_Expression (Choice);
                   case Get_Kind (Choice) is
                      when Iir_Kind_Choice_By_Expression =>
+                        Set_Direction (Index_Subtype_Constraint,
+                                       Get_Direction (Index_Constraint));
                         Set_Left_Limit (Index_Subtype_Constraint, Expr);
                         Set_Right_Limit (Index_Subtype_Constraint, Expr);
                      when Iir_Kind_Choice_By_Range =>
@@ -2995,8 +3296,8 @@
    is
       A_Subtype: Iir;
       Base_Type : Iir;
-      Index_List : Iir_List := Get_Index_Subtype_List (Aggr_Type);
-      Nbr_Dim : Natural := Get_Nbr_Elements (Index_List);
+      Index_List : constant Iir_List := Get_Index_Subtype_List (Aggr_Type);
+      Nbr_Dim : constant Natural := Get_Nbr_Elements (Index_List);
       Infos : Array_Aggr_Info_Arr (1 .. Nbr_Dim);
       Aggr_Constrained : Boolean;
       Info, Prev_Info : Iir_Aggregate_Info;
@@ -3025,6 +3326,8 @@
                Iirs.Min (Get_Type_Staticness (A_Subtype),
                          Get_Type_Staticness (Infos (I).Index_Subtype)));
          end loop;
+         Set_Index_Constraint_Flag (A_Subtype, True);
+         Set_Constraint_State (A_Subtype, Fully_Constrained);
          Set_Type (Aggr, A_Subtype);
       else
          Set_Type (Aggr, Base_Type);
@@ -3068,7 +3371,8 @@
       Set_Type (Expr, A_Type); -- FIXME: should free old type
       case Get_Kind (A_Type) is
          when Iir_Kind_Array_Subtype_Definition =>
-            return Sem_Array_Aggregate_Type (Expr, A_Type, True);
+            return Sem_Array_Aggregate_Type
+              (Expr, A_Type, Get_Index_Constraint_Flag (A_Type));
          when Iir_Kind_Array_Type_Definition =>
             return Sem_Array_Aggregate_Type (Expr, A_Type, False);
          when Iir_Kind_Record_Type_Definition
@@ -3156,7 +3460,7 @@
             --  type of the object created is an array type, then the
             --  subtype indication must either denote a constrained
             --  subtype or include an explicit index constraint.
-            if not Sem_Types.Sem_Is_Constrained (Arg) then
+            if not Is_Fully_Constrained_Type (Arg) then
                Error_Msg_Sem ("allocator of unconstrained " &
                               Disp_Node (Arg) & " is not allowed", Expr);
             end if;
@@ -3835,4 +4139,54 @@
       end if;
       return Sem_Expression_Ov (Expr1, Res);
    end Sem_Expression_Universal;
+
+   function Sem_Case_Expression (Expr : Iir) return Iir
+   is
+      Expr1 : Iir;
+      Expr_Type : Iir;
+      El : Iir;
+      Res : Iir;
+      List : Iir_List;
+   begin
+      Expr1 := Sem_Expression_Ov (Expr, Null_Iir);
+      if Expr1 = Null_Iir then
+         return Null_Iir;
+      end if;
+      Expr_Type := Get_Type (Expr1);
+      if not Is_Overload_List (Expr_Type) then
+         return Expr1;
+      end if;
+
+      --  In case of overload, try to find one match.
+      --  FIXME: match only character types.
+
+      --  LRM93 8.8  Case statement
+      --  This type must be determinable independently of the context in which
+      --  the expression occurs, but using the fact that the expression must be
+      --  of a discrete type or a one-dimensional character array type.
+      List := Get_Overload_List (Expr_Type);
+      Res := Null_Iir;
+      for I in Natural loop
+         El := Get_Nth_Element (List, I);
+         exit when El = Null_Iir;
+         if Get_Kind (El) in Iir_Kinds_Discrete_Type_Definition
+           or else Is_Unidim_Array_Type (El)
+         then
+            if Res = Null_Iir then
+               Res := El;
+            else
+               Error_Overload (Expr1);
+               Disp_Overload_List (List, Expr1);
+               return Null_Iir;
+            end if;
+         end if;
+      end loop;
+      if Res = Null_Iir then
+         Error_Overload (Expr1);
+         Disp_Overload_List (List, Expr1);
+         return Null_Iir;
+      end if;
+      return Sem_Expression_Ov (Expr1, Res);
+   end Sem_Case_Expression;
+
 end Sem_Expr;
diff -urN ghdl-0.27/vhdl/sem_expr.ads ghdl-0.28dev/vhdl/sem_expr.ads
--- ghdl-0.27/vhdl/sem_expr.ads	2007-03-24 08:22:14.000000000 +0100
+++ ghdl-0.28dev/vhdl/sem_expr.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
@@ -59,6 +59,10 @@
    --  if overloaded.
    function Sem_Expression_Universal (Expr : Iir) return Iir;
 
+   --  Same as Sem_Expression but specialized for a case expression.
+   --  (Handle specific overloading rules).
+   function Sem_Case_Expression (Expr : Iir) return Iir;
+
    --  Check EXPR can be read.
    procedure Check_Read (Expr : Iir);
 
diff -urN ghdl-0.27/vhdl/sem_names.adb ghdl-0.28dev/vhdl/sem_names.adb
--- ghdl-0.27/vhdl/sem_names.adb	2007-08-03 02:46:48.000000000 +0200
+++ ghdl-0.28dev/vhdl/sem_names.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,14 +12,14 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Evaluation; use Evaluation;
 with Iirs_Utils; use Iirs_Utils;
 with Libraries;
 with Errorout; use Errorout;
-with Flags;
+with Flags; use Flags;
 with Name_Table;
 with Std_Package; use Std_Package;
 with Types; use Types;
@@ -168,10 +168,10 @@
 
    --  Move elements of result list LIST to result list RES.
    --  Destroy LIST if necessary.
-   procedure Add_Result_List (Res : in out Iir; List : in out Iir);
+   procedure Add_Result_List (Res : in out Iir; List : Iir);
    pragma Unreferenced (Add_Result_List);
 
-   procedure Add_Result_List (Res : in out Iir; List : in out Iir)
+   procedure Add_Result_List (Res : in out Iir; List : Iir)
    is
       El : Iir;
       List_List : Iir_List;
@@ -201,9 +201,9 @@
    end Add_Result_List;
 
    --  Free interpretations of LIST except KEEP.
-   procedure Sem_Name_Free_Result (List : in out Iir; Keep : Iir)
+   procedure Sem_Name_Free_Result (List : Iir; Keep : Iir)
    is
-      procedure Sem_Name_Free (El : in out Iir) is
+      procedure Sem_Name_Free (El : Iir) is
       begin
          case Get_Kind (El) is
             when Iir_Kind_Function_Call
@@ -413,7 +413,9 @@
          then
             if Get_Kind (Get_Type (Obj)) /= Iir_Kind_Protected_Type_Declaration
             then
-               raise Internal_Error;
+               Error_Msg_Sem ("type of the prefix should be a protected type",
+                              Prefix);
+               return;
             end if;
             Set_Method_Object (Call, Obj);
          end if;
@@ -560,7 +562,6 @@
       Prefix_Bt : Iir;
       Index_List: Iir_List;
       Index_Type: Iir;
-      Index_Range : Iir;
       Suffix: Iir;
       Slice_Type : Iir;
       Expr_Type : Iir;
@@ -591,7 +592,6 @@
       end if;
 
       Index_Type := Get_First_Element (Index_List);
-      Index_Range := Get_Range_Constraint (Index_Type);
       Prefix_Rng := Eval_Range (Index_Type);
 
       --  LRM93 6.5
@@ -620,6 +620,7 @@
       -- Check this only if the type is a constrained type.
       Suffix_Rng := Eval_Range (Suffix);
       if Get_Kind (Prefix_Type) = Iir_Kind_Array_Subtype_Definition
+        and then Get_Index_Constraint_Flag (Prefix_Type)
         and then Prefix_Rng /= Null_Iir
         and then Suffix_Rng /= Null_Iir
         and then Get_Direction (Suffix_Rng) /= Get_Direction (Prefix_Rng)
@@ -679,6 +680,8 @@
         (Expr_Type, Min (Get_Type_Staticness (Prefix_Type),
                          Get_Type_Staticness (Slice_Type)));
       Set_Type (Name, Expr_Type);
+      Set_Index_Constraint_Flag (Expr_Type, True);
+      Set_Constraint_State (Expr_Type, Fully_Constrained);
       if Is_Signal_Object (Prefix) then
          Sem_Types.Set_Type_Has_Signal (Expr_Type);
       end if;
@@ -1085,7 +1088,7 @@
             & Disp_Node (Subprg), Loc);
       end Error_Pure;
 
-      Subprg : Iir := Sem_Stmts.Get_Current_Subprogram;
+      Subprg : constant Iir := Sem_Stmts.Get_Current_Subprogram;
       Subprg_Body : Iir;
       Parent : Iir;
    begin
@@ -1181,6 +1184,32 @@
       end case;
    end Sem_Check_Pure;
 
+   --  Set All_Sensitized_State to False iff OBJ is a signal declaration
+   --  and the current subprogram is in a package body.
+   procedure Sem_Check_All_Sensitized (Obj : Iir)
+   is
+      Subprg : Iir;
+   begin
+      --  We cares only of signals.
+      if Get_Kind (Obj) /= Iir_Kind_Signal_Declaration then
+         return;
+      end if;
+      --  We cares only of subprograms.  Give up if we are in a process.
+      Subprg := Sem_Stmts.Get_Current_Subprogram;
+      if Subprg = Null_Iir
+        or else Get_Kind (Subprg) not in Iir_Kinds_Subprogram_Declaration
+      then
+         return;
+      end if;
+      if Get_Kind (Get_Library_Unit (Sem.Get_Current_Design_Unit))
+        = Iir_Kind_Package_Body
+      then
+         Set_All_Sensitized_State (Subprg, Invalid_Signal);
+      else
+         Set_All_Sensitized_State (Subprg, Read_Signal);
+      end if;
+   end Sem_Check_All_Sensitized;
+
    procedure Finish_Sem_Name (Name : Iir; Res : Iir)
    is
       Pfx : Iir;
@@ -1336,7 +1365,7 @@
       is
          Sub_Res : Iir;
       begin
-         if Get_Is_Within_Flag (Sub_Name) = True then
+         if Get_Is_Within_Flag (Sub_Name) then
             Sub_Res := Find_Declarations_In_List (Sub_Name, Name, Keep_Alias);
             if Sub_Res /= Null_Iir then
                Add_Result (Res, Sub_Res);
@@ -1372,8 +1401,8 @@
             return;
          end if;
 
-         Rec_El := Find_Name_In_Chain
-           (Get_Element_Declaration_Chain (Base_Type), Suffix);
+         Rec_El := Find_Name_In_List
+           (Get_Elements_Declaration_List (Base_Type), Suffix);
          if Rec_El = Null_Iir then
             return;
          end if;
@@ -2373,9 +2402,7 @@
            | Iir_Kind_Type_Declaration
            | Iir_Kind_Base_Attribute =>
             Prefix_Type := Get_Type (Prefix);
-            if Get_Kind (Prefix_Type)
-              in Iir_Kinds_Unconstrained_Array_Type_Definition
-            then
+            if not Is_Fully_Constrained_Type (Prefix_Type) then
                Error_Msg_Sem ("prefix type is not constrained", Attr);
                --  We continue using the unconstrained array type.
                --  At least, this type is valid; and even if the array was
@@ -2465,7 +2492,13 @@
 --             Set_Parameter (Res, Param);
 --          end if;
 --       end if;
+
       if Get_Kind (Prefix) = Iir_Kind_Signal_Interface_Declaration then
+         --  LRM93 2.1.1.2 / LRM08 4.2.2.3
+         --
+         --  It is an error if signal-valued attributes 'STABLE , 'QUIET,
+         --  'TRANSACTION, and 'DELAYED of formal signal paramaters of any
+         --  mode are read within a subprogram.
          case Get_Kind (Get_Parent (Prefix)) is
             when Iir_Kind_Function_Declaration
               | Iir_Kind_Procedure_Declaration =>
@@ -2917,6 +2950,7 @@
          when Iir_Kinds_Object_Declaration =>
             Set_Base_Name (Name, Expr);
             Sem_Check_Pure (Name, Expr);
+            Sem_Check_All_Sensitized (Expr);
          when Iir_Kind_Indexed_Name
            | Iir_Kind_Slice_Name
            | Iir_Kind_Selected_Element
@@ -2935,6 +2969,7 @@
                   end if;
                end loop;
                Sem_Check_Pure (Name, E);
+               Sem_Check_All_Sensitized (E);
             end;
          when Iir_Kind_Enumeration_Literal
            | Iir_Kind_Unit_Declaration =>
diff -urN ghdl-0.27/vhdl/sem_names.ads ghdl-0.28dev/vhdl/sem_names.ads
--- ghdl-0.27/vhdl/sem_names.ads	2006-08-25 04:43:19.000000000 +0200
+++ ghdl-0.28dev/vhdl/sem_names.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
diff -urN ghdl-0.27/vhdl/sem_scopes.adb ghdl-0.28dev/vhdl/sem_scopes.adb
--- ghdl-0.27/vhdl/sem_scopes.adb	2005-09-22 23:32:11.000000000 +0200
+++ ghdl-0.28dev/vhdl/sem_scopes.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,12 +12,11 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Ada.Text_IO;
 with GNAT.Table;
-with Types; use Types;
 with Name_Table; -- use Name_Table;
 with Errorout; use Errorout;
 with Iirs_Utils;
diff -urN ghdl-0.27/vhdl/sem_scopes.ads ghdl-0.28dev/vhdl/sem_scopes.ads
--- ghdl-0.27/vhdl/sem_scopes.ads	2005-09-22 23:16:35.000000000 +0200
+++ ghdl-0.28dev/vhdl/sem_scopes.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
diff -urN ghdl-0.27/vhdl/sem_specs.adb ghdl-0.28dev/vhdl/sem_specs.adb
--- ghdl-0.27/vhdl/sem_specs.adb	2006-07-14 22:48:59.000000000 +0200
+++ ghdl-0.28dev/vhdl/sem_specs.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
@@ -21,7 +21,6 @@
 with Sem_Names; use Sem_Names;
 with Evaluation; use Evaluation;
 with Std_Package; use Std_Package;
-with Tokens;
 with Errorout; use Errorout;
 with Sem; use Sem;
 with Sem_Scopes; use Sem_Scopes;
@@ -29,7 +28,7 @@
 with Libraries;
 with Iir_Chains; use Iir_Chains;
 with Sem_Types;
-with Flags;
+with Flags; use Flags;
 with Name_Table;
 with Std_Names;
 with Sem_Decls;
diff -urN ghdl-0.27/vhdl/sem_specs.ads ghdl-0.28dev/vhdl/sem_specs.ads
--- ghdl-0.27/vhdl/sem_specs.ads	2005-09-22 23:21:38.000000000 +0200
+++ ghdl-0.28dev/vhdl/sem_specs.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
diff -urN ghdl-0.27/vhdl/sem_stmts.adb ghdl-0.28dev/vhdl/sem_stmts.adb
--- ghdl-0.27/vhdl/sem_stmts.adb	2007-03-14 00:03:10.000000000 +0100
+++ ghdl-0.28dev/vhdl/sem_stmts.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,12 +12,12 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Errorout; use Errorout;
 with Types; use Types;
-with Flags;
+with Flags; use Flags;
 with Sem_Specs; use Sem_Specs;
 with Std_Package; use Std_Package;
 with Sem; use Sem;
@@ -791,7 +791,7 @@
       --  Return FALSE in case of violation.
       function Check_Odcat_Expression (Expr : Iir) return Boolean
       is
-         Expr_Type : Iir := Get_Type (Expr);
+         Expr_Type : constant Iir := Get_Type (Expr);
       begin
          --  LRM 8.8 Case Statement
          --  If the expression is of a one-dimensional character array type,
@@ -819,7 +819,7 @@
                if not Check_Odcat_Expression (Get_Prefix (Expr)) then
                   return False;
                end if;
-               --  GHDL: I don't understand why the indexsing expressions
+               --  GHDL: I don't understand why the indexing expressions
                --  must be locally static.  So I don't check this in 93c.
                if Flags.Vhdl_Std /= Vhdl_93c
                  and then
@@ -897,8 +897,7 @@
          when Iir_Kinds_Discrete_Type_Definition =>
             Sem_Choices_Range (Chain, Choice_Type, False, Loc, Low, High);
          when Iir_Kind_Array_Subtype_Definition
-           | Iir_Kind_Array_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition =>
+           | Iir_Kind_Array_Type_Definition =>
             if not Is_Unidim_Array_Type (Choice_Type) then
                Error_Msg_Sem
                  ("expression must be of a one-dimensional array type",
@@ -927,12 +926,10 @@
       Expr: Iir;
       Chain : Iir;
       El: Iir;
-      Loc : Location_Type;
    begin
       Expr := Get_Expression (Stmt);
-      Loc := Get_Location (Expr);
       -- FIXME: overload.
-      Expr := Sem_Expression (Expr, Null_Iir);
+      Expr := Sem_Case_Expression (Expr);
       if Expr = Null_Iir then
          return;
       end if;
@@ -956,6 +953,10 @@
       Res: Iir;
       Prefix : Iir;
    begin
+      if List = Iir_List_All then
+         return;
+      end if;
+
       for I in Natural loop
          -- El is an iir_identifier.
          El := Get_Nth_Element (List, I);
@@ -994,7 +995,7 @@
             --  signal name, and each name must denote a signal for which
             --  reading is permitted.
             if Get_Name_Staticness (Res) < Globally then
-               Error_Msg_Sem ("sensitivity element " & Disp_Node (El)
+               Error_Msg_Sem ("sensitivity element " & Disp_Node (Res)
                               & " must be a static name", El);
             end if;
 
@@ -1513,6 +1514,9 @@
       if Get_Kind (Proc) = Iir_Kind_Sensitized_Process_Statement
         and then Get_Callees_List (Proc) /= Null_Iir_List
       then
+         --  Check there is no wait statement in subprograms called.
+         --  Also in the case of all-sensitized process, check that package
+         --  subprograms don't read signals.
          Sem.Add_Analysis_Checks_List (Proc);
       end if;
    end Sem_Process_Statement;
@@ -1684,7 +1688,7 @@
       end if;
 
       --  The choices.
-      Expr := Sem_Expression (Get_Expression (Stmt), Null_Iir);
+      Expr := Sem_Case_Expression (Get_Expression (Stmt));
       if Expr = Null_Iir then
          return;
       end if;
diff -urN ghdl-0.27/vhdl/sem_stmts.ads ghdl-0.28dev/vhdl/sem_stmts.ads
--- ghdl-0.27/vhdl/sem_stmts.ads	2005-09-22 23:21:51.000000000 +0200
+++ ghdl-0.28dev/vhdl/sem_stmts.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
diff -urN ghdl-0.27/vhdl/sem_types.adb ghdl-0.28dev/vhdl/sem_types.adb
--- ghdl-0.27/vhdl/sem_types.adb	2007-03-24 08:27:55.000000000 +0100
+++ ghdl-0.28dev/vhdl/sem_types.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,11 +12,11 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Libraries;
-with Flags;
+with Flags; use Flags;
 with Types; use Types;
 with Errorout; use Errorout;
 with Evaluation; use Evaluation;
@@ -25,6 +25,7 @@
 with Sem_Scopes; use Sem_Scopes;
 with Sem_Names; use Sem_Names;
 with Sem_Decls;
+with Name_Table;
 with Std_Names;
 with Iirs_Utils; use Iirs_Utils;
 with Std_Package; use Std_Package;
@@ -78,12 +79,14 @@
             Set_Type_Has_Signal (Get_Element_Subtype (Atype));
          when Iir_Kind_Record_Type_Definition =>
             declare
+               El_List : constant Iir_List :=
+                 Get_Elements_Declaration_List (Atype);
                El : Iir;
             begin
-               El := Get_Element_Declaration_Chain (Atype);
-               while El /= Null_Iir loop
+               for I in Natural loop
+                  El := Get_Nth_Element (El_List, I);
+                  exit when El = Null_Iir;
                   Set_Type_Has_Signal (Get_Type (El));
-                  El := Get_Chain (El);
                end loop;
             end;
          when Iir_Kind_Error =>
@@ -452,7 +455,9 @@
       --  array subtype] [...] for the element subtype indication
       --  of an array type definition, if the type of the array
       --  element is itself an array type.
-      if not Sem_Is_Constrained (El_Type) then
+      if Vhdl_Std < Vhdl_08
+        and then not Is_Fully_Constrained_Type (El_Type)
+      then
          Error_Msg_Sem ("array element of unconstrained "
                         & Disp_Node (El_Type) & " is not allowed", Def);
       end if;
@@ -655,6 +660,62 @@
       Close_Declarative_Region;
    end Sem_Protected_Type_Body;
 
+
+   --  Return the constraint state from CONST (the initial state) and ATYPE,
+   --  as if ATYPE was a new element of a record.
+   function Update_Record_Constraint (Const : Iir_Constraint; Atype : Iir)
+                                     return Iir_Constraint is
+   begin
+      if Get_Kind (Atype) not in Iir_Kinds_Composite_Type_Definition then
+         return Const;
+      end if;
+
+      case Const is
+         when Fully_Constrained
+           | Unconstrained =>
+            if Get_Constraint_State (Atype) = Const then
+               return Const;
+            else
+               return Partially_Constrained;
+            end if;
+         when Partially_Constrained =>
+            return Partially_Constrained;
+      end case;
+   end Update_Record_Constraint;
+
+   function Get_Array_Constraint (Def : Iir) return Iir_Constraint
+   is
+      El_Type : constant Iir := Get_Element_Subtype (Def);
+      Index : constant Boolean :=
+        Get_Kind (Def) = Iir_Kind_Array_Subtype_Definition
+        and then Get_Index_Constraint_Flag (Def);
+   begin
+      if Get_Kind (El_Type) in Iir_Kinds_Composite_Type_Definition then
+         case Get_Constraint_State (El_Type) is
+            when Fully_Constrained =>
+               if Index then
+                  return Fully_Constrained;
+               else
+                  return Partially_Constrained;
+               end if;
+            when Partially_Constrained =>
+               return Partially_Constrained;
+            when Unconstrained =>
+               if not Index then
+                  return Unconstrained;
+               else
+                  return Partially_Constrained;
+               end if;
+         end case;
+      else
+         if Index then
+            return Fully_Constrained;
+         else
+            return Unconstrained;
+         end if;
+      end if;
+   end Get_Array_Constraint;
+
    function Sem_Type_Definition (Def: Iir; Decl: Iir) return Iir
    is
    begin
@@ -670,6 +731,7 @@
             declare
                El: Iir;
                Literal_List: Iir_List;
+               Only_Characters : Boolean := True;
             begin
                Literal_List := Get_Enumeration_Literal_List (Def);
                for I in Natural loop
@@ -684,7 +746,13 @@
                   Sem_Scopes.Add_Name (El);
                   Name_Visible (El);
                   Xref_Decl (El);
+                  if Only_Characters
+                    and then not Name_Table.Is_Character (Get_Identifier (El))
+                  then
+                     Only_Characters := False;
+                  end if;
                end loop;
+               Set_Only_Characters_Flag (Def, Only_Characters);
             end;
             Set_Resolved_Flag (Def, False);
             return Def;
@@ -716,6 +784,25 @@
             end;
 
          when Iir_Kind_Array_Subtype_Definition =>
+            --  LRM08 5.3.2.1  Array types
+            --  A constrained array definition similarly defines both an array
+            --  type and a subtype of this type.
+            --  - The array type is an implicitely declared anonymous type,
+            --    this type is defined by an (implicit) unbounded array
+            --    definition in which the element subtype indication either
+            --    denotes the base type of the subtype denoted by the element
+            --    subtype indication of the constrained array definition, if
+            --    that subtype is a composite type, or otherwise is the
+            --    element subtype indication of the constrained array
+            --    definition, and in which the type mark of each index subtype
+            --    definition denotes the subtype defined by the corresponding
+            --    discrete range.
+            --  - The array subtype is the subtype obtained by imposition of
+            --    the index constraint on the array type and if the element
+            --    subtype indication of the constrained array definition
+            --    denotes a fully or partially constrained composite subtype,
+            --    imposition of the constraint of that subtype as an array
+            --    element constraint on the array type.
             declare
                Index_Type : Iir;
                Index_List : Iir_List;
@@ -773,7 +860,10 @@
                Set_Type_Staticness (Base_Type, None);
                Set_Type_Declarator (Base_Type, Decl);
                Set_Resolved_Flag (Base_Type, Get_Resolved_Flag (Def));
-
+               Set_Index_Constraint_Flag (Def, True);
+               Set_Constraint_State (Def, Get_Array_Constraint (Def));
+               Set_Constraint_State
+                 (Base_Type, Get_Array_Constraint (Base_Type));
                Set_Base_Type (Def, Base_Type);
                Set_Type_Mark (Def, Base_Type);
                return Def;
@@ -811,38 +901,39 @@
                --  According to LRM93 7.4.1, an unconstrained array type
                --  is not static.
                Set_Type_Staticness (Def, None);
-
                Sem_Array_Element (Def);
+               Set_Constraint_State (Def, Get_Array_Constraint (Def));
                return Def;
             end;
 
          when Iir_Kind_Record_Type_Definition =>
             declare
-               --  Non semantized type of previous element.
-               Last_El_Type : Iir;
                --  Semantized type of previous element
                Last_Type : Iir;
 
+               El_List : Iir_List;
                El: Iir;
                El_Type : Iir;
                Resolved_Flag : Boolean;
                Staticness : Iir_Staticness;
+               Constraint : Iir_Constraint;
             begin
                --  LRM 10.1
                --  5. A record type declaration,
                Open_Declarative_Region;
 
                Resolved_Flag := True;
-               Last_El_Type := Null_Iir;
                Last_Type := Null_Iir;
                Staticness := Locally;
+               Constraint := Fully_Constrained;
                Set_Signal_Type_Flag (Def, True);
-               El := Get_Element_Declaration_Chain (Def);
-               while El /= Null_Iir loop
+               El_List := Get_Elements_Declaration_List (Def);
+               for I in Natural loop
+                  El := Get_Nth_Element (El_List, I);
+                  exit when El = Null_Iir;
                   El_Type := Get_Type (El);
-                  if El_Type /= Last_El_Type then
+                  if El_Type /= Null_Iir then
                      --  Be careful for a declaration list (r,g,b: integer).
-                     Last_El_Type := El_Type;
                      El_Type := Sem_Subtype_Indication (El_Type);
                      Last_Type := El_Type;
                   else
@@ -860,7 +951,9 @@
                      --  subtype] exits for the subtype indication of an
                      --  element declaration, if the type of the record
                      --  element is an array type.
-                     if not Sem_Is_Constrained (El_Type) then
+                     if Vhdl_Std < Vhdl_08
+                       and then not Is_Fully_Constrained_Type (El_Type)
+                     then
                         Error_Msg_Sem
                           ("element declaration of unconstrained "
                            & Disp_Node (El_Type) & " is not allowed", El);
@@ -869,18 +962,20 @@
                        Resolved_Flag and Get_Resolved_Flag (El_Type);
                      Staticness := Min (Staticness,
                                         Get_Type_Staticness (El_Type));
+                     Constraint := Update_Record_Constraint
+                       (Constraint, El_Type);
                   else
                      Staticness := None;
                   end if;
                   Sem_Scopes.Add_Name (El);
                   Name_Visible (El);
                   Xref_Decl (El);
-                  El := Get_Chain (El);
                end loop;
                Close_Declarative_Region;
                Set_Base_Type (Def, Def);
                Set_Resolved_Flag (Def, Resolved_Flag);
                Set_Type_Staticness (Def, Staticness);
+               Set_Constraint_State (Def, Constraint);
                return Def;
             end;
 
@@ -1055,27 +1150,14 @@
    end Is_A_Resolution_Function;
 
    --  Note: this sets resolved_flag.
-   procedure Sem_Resolution_Function (Decl: Iir)
+   procedure Sem_Resolution_Function (Name : Iir; Atype : Iir)
    is
-      Func: Iir;
-      Name : Iir;
+      Func : Iir;
       Res: Iir;
       El : Iir;
       List : Iir_List;
+      Has_Error : Boolean;
    begin
-      Name := Get_Resolution_Function (Decl);
-      if Name = Null_Iir then
-         -- This is not a resolved type.
-         return;
-      end if;
-
-      -- FIXME: add this check (maybe based on resolved_flag ?)
-      --if Get_Kind (Name) in Iir_Kinds_Function_Declaration then
-      --   --  The resolution function was already semantized.
-      --   --  This can happen if comes from an unconstrained array subtype.
-      --   return;
-      --end if;
-
       Sem_Name (Name, False);
       Func := Get_Named_Entity (Name);
       if Func = Error_Mark then
@@ -1086,383 +1168,647 @@
 
       if Is_Overload_List (Func) then
          List := Get_Overload_List (Func);
+         Has_Error := False;
          for I in Natural loop
             El := Get_Nth_Element (List, I);
             exit when El = Null_Iir;
-            if Is_A_Resolution_Function (El, Decl) then
-               if Func /= Null_Iir then
-                  Error_Msg_Sem
-                    ("can't resolve overload for resolution function", Decl);
-                  return;
+            if Is_A_Resolution_Function (El, Atype) then
+               if Res /= Null_Iir then
+                  if not Has_Error then
+                     Has_Error := True;
+                     Error_Msg_Sem
+                       ("can't resolve overload for resolution function",
+                        Atype);
+                     Error_Msg_Sem ("candidate functions are:", Atype);
+                     Error_Msg_Sem (" " & Disp_Subprg (Func), Func);
+                  end if;
+                  Error_Msg_Sem (" " & Disp_Subprg (El), El);
                else
-                  Func := El;
+                  Res := El;
                end if;
             end if;
          end loop;
+         if Has_Error then
+            return;
+         end if;
       else
-         if Is_A_Resolution_Function (Func, Decl) then
+         if Is_A_Resolution_Function (Func, Atype) then
             Res := Func;
          end if;
       end if;
 
       if Res = Null_Iir then
          Error_Msg_Sem ("no matching resolution function for "
-                        & Disp_Node (Name), Decl);
+                        & Disp_Node (Name), Atype);
       else
          Set_Named_Entity (Name, Res);
          Set_Use_Flag (Res, True);
-         Set_Resolved_Flag (Decl, True);
+         Set_Resolved_Flag (Atype, True);
+         Set_Resolution_Function (Atype, Name);
          Xref_Name (Name);
       end if;
    end Sem_Resolution_Function;
 
-   --  Semantize array_subtype_definition DEF using TYPE_MARK as the base type
-   --  of DEF.
-   --  DEF must have an index list and may have a resolution function.
-   --  Return DEF.
-   function Sem_Array_Subtype_Indication (Type_Mark : Iir; Def : Iir)
-     return Iir
+   function Sem_Subtype_Constraint
+     (Def : Iir; Type_Mark : Iir; Resolution : Iir)
+     return Iir;
+
+   -- DEF is an incomplete subtype_indication or array_constraint,
+   -- BASE_TYPE is the base type of the subtype_indication.
+   function Sem_Array_Constraint (Def : Iir; Type_Mark : Iir; Resolution : Iir)
+                                 return Iir
    is
+      Res : Iir;
       Type_Index, Subtype_Index: Iir;
       Base_Type : Iir;
+      Mark_El_Type : Iir;
       El_Type : Iir;
       Staticness : Iir_Staticness;
       Error_Seen : Boolean;
       Type_Index_List : Iir_List;
       Subtype_Index_List : Iir_List;
+      Resolv_Func : Iir := Null_Iir;
+      Resolv_El : Iir := Null_Iir;
    begin
-      case Get_Kind (Type_Mark) is
-         when Iir_Kind_Array_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition =>
-            null;
-         when others =>
-            Error_Msg_Sem
-              (Disp_Node (Type_Mark) & " cannot be constrained", Def);
-            --  Continue as if BASE_TYPE is really a base type, it is safe.
-      end case;
+      if Resolution /= Null_Iir then
+         case Get_Kind (Resolution) is
+            when Iir_Kinds_Name =>
+               Resolv_Func := Resolution;
+            when Iir_Kind_Array_Subtype_Definition =>
+               Resolv_El := Get_Element_Subtype (Resolution);
+               Free_Iir (Resolution);
+            when Iir_Kind_Record_Subtype_Definition =>
+               Error_Msg_Sem
+                 ("record element resolution not allowed for array subtype",
+                  Resolution);
+            when others =>
+               Error_Kind ("sem_array_constraint(resolution)", Resolution);
+         end case;
+      end if;
 
-      Base_Type := Get_Base_Type (Type_Mark);
-      Set_Base_Type (Def, Base_Type);
-      El_Type := Get_Element_Subtype (Base_Type);
-      Staticness := Get_Type_Staticness (El_Type);
-      Error_Seen := False;
-      Type_Index_List := Get_Index_Subtype_List (Base_Type);
-      Subtype_Index_List := Get_Index_Subtype_List (Def);
-      for I in Natural loop
-         Type_Index := Get_Nth_Element (Type_Index_List, I);
-         Subtype_Index := Get_Nth_Element (Subtype_Index_List, I);
-         exit when Type_Index = Null_Iir and Subtype_Index = Null_Iir;
-
-         if Type_Index = Null_Iir then
-            Error_Msg_Sem ("subtype has more indexes than "
-                           & Disp_Node (Type_Mark)
-                           & " defined at " & Disp_Location (Type_Mark),
-                           Subtype_Index);
-            --  Forget extra indexes.
-            Set_Nbr_Elements (Subtype_Index_List, I);
-            exit;
-         end if;
-         if Subtype_Index = Null_Iir then
-            if not Error_Seen then
-               Error_Msg_Sem ("subtype has less indexes than "
-                              & Disp_Node (Type_Mark)
-                              & " defined at " & Disp_Location (Type_Mark),
-                              Def);
-               Error_Seen := True;
-            end if;
-            --  Use type_index as a fake subtype
-            --  FIXME: it is too fake.
-            Append_Element (Subtype_Index_List, Type_Index);
-            Staticness := None;
-         else
-            Subtype_Index := Sem_Discrete_Range_Expression
-              (Subtype_Index, Type_Index, True);
-            if Subtype_Index /= Null_Iir then
-               Subtype_Index := Range_To_Subtype_Definition (Subtype_Index);
-               Staticness := Min (Staticness,
-                                  Get_Type_Staticness (Subtype_Index));
-            end if;
-            if Subtype_Index = Null_Iir then
-               --  Create a fake subtype from type_index.
-               --  FIXME: It is too fake.
-               Subtype_Index := Type_Index;
-               Staticness := None;
-            end if;
-            Replace_Nth_Element (Subtype_Index_List, I, Subtype_Index);
+      Mark_El_Type := Get_Element_Subtype (Type_Mark);
+
+      if Def = Null_Iir then
+         Res := Copy_Subtype_Indication (Type_Mark);
+      else
+         case Get_Kind (Def) is
+            when Iir_Kind_Subtype_Definition =>
+               -- This is the case of "subtype new_array is [func] old_array".
+               -- def must be a constrained array.
+               if Get_Range_Constraint (Def) /= Null_Iir then
+                  Error_Msg_Sem
+                    ("cannot use a range constraint for array types", Def);
+                  return Type_Mark;
+               end if;
+
+               -- LRM08 6.3 Subtype declarations
+               --
+               -- If the subtype indication does not include a constraint, the
+               -- subtype is the same as that denoted by the type mark.
+               if Resolution = Null_Iir then
+                  Free_Name (Def);
+                  return Type_Mark;
+               end if;
+
+               Res := Copy_Subtype_Indication (Type_Mark);
+               Location_Copy (Res, Def);
+               Free_Name (Def);
+
+            when Iir_Kind_Array_Subtype_Definition =>
+               -- Case of a constraint for an array.
+               -- Check each index constraint against array type.
+
+               Base_Type := Get_Base_Type (Type_Mark);
+               Set_Base_Type (Def, Base_Type);
+
+               Staticness := Get_Type_Staticness (Mark_El_Type);
+               Error_Seen := False;
+               Type_Index_List := Get_Index_Subtype_List (Base_Type);
+               Subtype_Index_List := Get_Index_Subtype_List (Def);
+
+               --  LRM08 5.3.2.2
+               --  If an array constraint of the first form (including an index
+               --  constraint) applies to a type or subtype, then the type or
+               --  subtype shall be an unconstrained or partially constrained
+               --  array type with no index constraint applying to the index
+               --  subtypes, or an access type whose designated type is such
+               --  a type.
+               if Get_Kind (Type_Mark) = Iir_Kind_Array_Subtype_Definition
+                 and then Get_Index_Constraint_Flag (Type_Mark)
+               then
+                  Error_Msg_Sem ("constrained array cannot be re-constrained",
+                                 Def);
+               end if;
+               for I in Natural loop
+                  Type_Index := Get_Nth_Element (Type_Index_List, I);
+                  Subtype_Index := Get_Nth_Element (Subtype_Index_List, I);
+                  exit when Type_Index = Null_Iir and Subtype_Index = Null_Iir;
+
+                  if Type_Index = Null_Iir then
+                     Error_Msg_Sem
+                       ("subtype has more indexes than "
+                          & Disp_Node (Type_Mark)
+                          & " defined at " & Disp_Location (Type_Mark),
+                        Subtype_Index);
+                     --  Forget extra indexes.
+                     Set_Nbr_Elements (Subtype_Index_List, I);
+                     exit;
+                  end if;
+                  if Subtype_Index = Null_Iir then
+                     if not Error_Seen then
+                        Error_Msg_Sem
+                          ("subtype has less indexes than "
+                             & Disp_Node (Type_Mark)
+                             & " defined at "
+                             & Disp_Location (Type_Mark), Def);
+                        Error_Seen := True;
+                     end if;
+                     --  Use type_index as a fake subtype
+                     --  FIXME: it is too fake.
+                     Append_Element (Subtype_Index_List, Type_Index);
+                     Staticness := None;
+                  else
+                     Subtype_Index := Sem_Discrete_Range_Expression
+                       (Subtype_Index, Type_Index, True);
+                     if Subtype_Index /= Null_Iir then
+                        Subtype_Index :=
+                          Range_To_Subtype_Definition (Subtype_Index);
+                        Staticness := Min
+                          (Staticness, Get_Type_Staticness (Subtype_Index));
+                     end if;
+                     if Subtype_Index = Null_Iir then
+                        --  Create a fake subtype from type_index.
+                        --  FIXME: It is too fake.
+                        Subtype_Index := Type_Index;
+                        Staticness := None;
+                     end if;
+                     Replace_Nth_Element
+                       (Subtype_Index_List, I, Subtype_Index);
+                  end if;
+               end loop;
+               Set_Index_Constraint_Flag (Def, True);
+               Set_Type_Staticness (Def, Staticness);
+               Set_Type_Mark (Def, Type_Mark);
+               Set_Signal_Type_Flag (Def, Get_Signal_Type_Flag (Type_Mark));
+               Res := Def;
+
+            when others =>
+               --  LRM93 3.2.1.1 / LRM08 5.3.2.2
+               --  Index Constraints and Discrete Ranges
+               --
+               --  If an index constraint appears after a type mark [...]
+               --  The type mark must denote either an unconstrained array
+               --  type, or an access type whose designated type is such
+               --  an array type.
+               Error_Msg_Sem
+                 ("only unconstrained array type may be contrained "
+                    &"by index", Def);
+               Error_Msg_Sem
+                 (" (type mark is " & Disp_Node (Type_Mark) & ")",
+                  Type_Mark);
+               return Type_Mark;
+         end case;
+      end if;
+
+      --  Element subtype.
+      if Resolv_El /= Null_Iir then
+         El_Type := Sem_Subtype_Constraint (Null_Iir, Mark_El_Type, Resolv_El);
+         if El_Type = Null_Iir then
+            El_Type := Mark_El_Type;
          end if;
-      end loop;
-      Set_Type_Staticness (Def, Staticness);
-      Set_Element_Subtype (Def, El_Type);
-      Sem_Resolution_Function (Def);
-      if Get_Resolved_Flag (Def) or else Get_Resolved_Flag (El_Type) then
-         Set_Resolved_Flag (Def, True);
       else
-         Set_Resolved_Flag (Def, False);
+         El_Type := Mark_El_Type;
       end if;
-      Set_Type_Mark (Def, Type_Mark);
-      Set_Signal_Type_Flag (Def, Get_Signal_Type_Flag (Type_Mark));
-      return Def;
-   end Sem_Array_Subtype_Indication;
+      Set_Element_Subtype (Res, El_Type);
 
-   --  Semantize a subtype indication.
-   --  DEF can be either a name or an iir_subtype_definition.
-   --  Return a new (an anonymous) subtype definition (with the correct kind),
-   --  or an already defined type definition (if DEF is a name).
-   function Sem_Subtype_Indication (Def: Iir; Incomplete : Boolean := False)
-     return Iir
+      Set_Constraint_State (Res, Get_Array_Constraint (Res));
+
+      if Resolv_Func /= Null_Iir then
+         Sem_Resolution_Function (Resolv_Func, Res);
+      elsif Get_Kind (Type_Mark) = Iir_Kind_Array_Subtype_Definition then
+         Set_Resolution_Function (Res, Get_Resolution_Function (Type_Mark));
+      end if;
+      if Get_Resolved_Flag (Res)
+        or else Get_Resolved_Flag (Get_Element_Subtype (Type_Mark))
+      then
+         Set_Resolved_Flag (Res, True);
+      else
+         Set_Resolved_Flag (Res, False);
+      end if;
+
+      return Res;
+   end Sem_Array_Constraint;
+
+   function Reparse_As_Record_Element_Constraint (Name : Iir) return Iir
    is
-      Type_Mark: Iir;
-      Res: Iir;
-      Decl_Kind : Decl_Kind_Type;
+      Prefix : Iir;
+      Parent : Iir;
+      El : Iir;
    begin
-      if Incomplete then
-         Decl_Kind := Decl_Incomplete_Type;
+      if Get_Kind (Name) /= Iir_Kind_Parenthesis_Name then
+         Error_Msg_Sem ("record element constraint expected", Name);
+         return Null_Iir;
       else
-         Decl_Kind := Decl_Type;
+         Prefix := Get_Prefix (Name);
+         Parent := Name;
+         while Get_Kind (Prefix) = Iir_Kind_Parenthesis_Name loop
+            Parent := Prefix;
+            Prefix := Get_Prefix (Prefix);
+         end loop;
+         if Get_Kind (Prefix) /= Iir_Kind_Simple_Name then
+            Error_Msg_Sem ("record element name must be a simple name",
+                           Prefix);
+            return Null_Iir;
+         else
+            El := Create_Iir (Iir_Kind_Record_Element_Constraint);
+            Location_Copy (El, Prefix);
+            Set_Identifier (El, Get_Identifier (Prefix));
+            Set_Type (El, Name);
+            Set_Prefix (Parent, Null_Iir);
+            Free_Name (Prefix);
+            return El;
+         end if;
       end if;
+   end Reparse_As_Record_Element_Constraint;
 
-      -- Simple case that correspond to no indication except a subtype
-      -- identifier
-      if Get_Kind (Def) in Iir_Kinds_Name then
-         Type_Mark := Find_Declaration (Def, Decl_Kind);
-         if Type_Mark = Null_Iir then
-            return Create_Error_Type (Def);
+   function Reparse_As_Record_Constraint (Def : Iir) return Iir
+   is
+      Res : Iir;
+      Chain : Iir;
+      El_List : Iir_List;
+      El : Iir;
+   begin
+      if Get_Prefix (Def) /= Null_Iir then
+         raise Internal_Error;
+      end if;
+      Res := Create_Iir (Iir_Kind_Record_Subtype_Definition);
+      Location_Copy (Res, Def);
+      El_List := Create_Iir_List;
+      Set_Elements_Declaration_List (Res, El_List);
+      Chain := Get_Association_Chain (Def);
+      while Chain /= Null_Iir loop
+         if Get_Kind (Chain) /= Iir_Kind_Association_Element_By_Expression
+           or else Get_Formal (Chain) /= Null_Iir
+         then
+            Error_Msg_Sem ("badly formed record constraint", Chain);
          else
-            return Type_Mark;
+            El := Reparse_As_Record_Element_Constraint (Get_Actual (Chain));
+            if El /= Null_Iir then
+               Append_Element (El_List, El);
+            end if;
+         end if;
+         Chain := Get_Chain (Chain);
+      end loop;
+      return Res;
+   end Reparse_As_Record_Constraint;
+
+   function Reparse_As_Array_Constraint (Def : Iir; Def_Type : Iir) return Iir
+   is
+      Parent : Iir;
+      Name : Iir;
+      Prefix : Iir;
+      Res : Iir;
+      Chain : Iir;
+      El_List : Iir_List;
+      Def_El_Type : Iir;
+   begin
+      Name := Def;
+      Prefix := Get_Prefix (Name);
+      Parent := Null_Iir;
+      while Prefix /= Null_Iir
+        and then Get_Kind (Prefix) = Iir_Kind_Parenthesis_Name
+      loop
+         Parent := Name;
+         Name := Prefix;
+         Prefix := Get_Prefix (Name);
+      end loop;
+      --  Detach prefix.
+      if Parent /= Null_Iir then
+         Set_Prefix (Parent, Null_Iir);
+      end if;
+      Res := Create_Iir (Iir_Kind_Array_Subtype_Definition);
+      Location_Copy (Res, Name);
+      Chain := Get_Association_Chain (Name);
+      if Get_Kind (Chain) = Iir_Kind_Association_Element_Open then
+         if Get_Chain (Chain) /= Null_Iir then
+            Error_Msg_Sem ("'open' must be alone", Chain);
          end if;
+      else
+         El_List := Create_Iir_List;
+         Set_Index_Subtype_List (Res, El_List);
+         while Chain /= Null_Iir loop
+            if Get_Kind (Chain) /= Iir_Kind_Association_Element_By_Expression
+              or else Get_Formal (Chain) /= Null_Iir
+            then
+               Error_Msg_Sem ("bad form of array constraint", Chain);
+            else
+               Append_Element (El_List, Get_Actual (Chain));
+            end if;
+            Chain := Get_Chain (Chain);
+         end loop;
       end if;
 
-      --  Semantize the type mark.
-      Type_Mark := Find_Declaration (Get_Type_Mark (Def), Decl_Kind);
-      if Type_Mark = Null_Iir then
-         --  FIXME: handle inversion such as "subtype BASETYPE RESOLV", which
-         --  should emit "resolution function must precede type name".
-         return Create_Error_Type (Get_Type_Mark (Def));
+      Def_El_Type := Get_Element_Subtype (Def_Type);
+      if Parent /= Null_Iir then
+         case Get_Kind (Def_El_Type) is
+            when Iir_Kinds_Array_Type_Definition =>
+               Set_Element_Subtype
+                 (Res, Reparse_As_Array_Constraint (Def, Def_El_Type));
+            when others =>
+               Error_Kind ("reparse_as_array_constraint", Def_El_Type);
+         end case;
+      end if;
+      return Res;
+   end Reparse_As_Array_Constraint;
+
+   function Sem_Record_Constraint
+     (Def : Iir; Type_Mark : Iir; Resolution : Iir)
+     return Iir
+   is
+      Res : Iir;
+      El_List, Tm_El_List : Iir_List;
+      El : Iir;
+      Tm_El : Iir;
+      Tm_El_Type : Iir;
+      El_Type : Iir;
+      Res_List : Iir_List;
+
+      Index_List : Iir_List;
+      Index_El : Iir;
+   begin
+      Res := Create_Iir (Iir_Kind_Record_Subtype_Definition);
+      Location_Copy (Res, Def);
+      Set_Base_Type (Res, Type_Mark);
+      Set_Type_Staticness (Res, Get_Type_Staticness (Type_Mark));
+      Set_Type_Mark (Res, Type_Mark);
+      if Get_Kind (Type_Mark) = Iir_Kind_Record_Subtype_Definition then
+         Set_Resolution_Function (Res, Get_Resolution_Function (Type_Mark));
       end if;
-      Set_Type_Mark (Def, Type_Mark);
 
-      --  Check constraint.
       case Get_Kind (Def) is
-         when Iir_Kind_Array_Subtype_Definition =>
-            case Get_Kind (Type_Mark) is
-               when Iir_Kind_Unconstrained_Array_Subtype_Definition
-                 | Iir_Kind_Array_Type_Definition
-                 | Iir_Kind_Access_Type_Definition =>
-                  null;
-               when others =>
-                  --  LRM 3.2.1.1  Index Constraints and Discrete Ranges
-                  --  If an index constraint appears after a type mark [...]
-                  --  The type mark must denote either an unconstrained array
-                  --  type, or an access type whose designated type is such
-                  --  an array type.
-                  Error_Msg_Sem
-                    ("only unconstrained array type may be contrained "
-                     &"by index", Def);
-                  Error_Msg_Sem
-                    (" (type mark is " & Disp_Node (Type_Mark) & ")",
-                     Type_Mark);
-                  return Type_Mark;
-            end case;
          when Iir_Kind_Subtype_Definition =>
-            case Get_Kind (Type_Mark) is
-               when Iir_Kind_Integer_Subtype_Definition
-                 | Iir_Kind_Floating_Subtype_Definition
-                 | Iir_Kind_Enumeration_Subtype_Definition
-                 | Iir_Kind_Physical_Subtype_Definition =>
-                  null;
-               when Iir_Kind_Enumeration_Type_Definition =>
-                  null;
-               when others =>
-                  --  FIXME: find the correct sentence from LRM
-                  --  GHDL: subtype_definition may also be used just to add
-                  --    a resolution function.
-                  if Get_Range_Constraint (Def) /= Null_Iir then
-                     Error_Msg_Sem
-                       ("only scalar types may be constrained by range", Def);
-                     Error_Msg_Sem
-                       (" (type mark is " & Disp_Node (Type_Mark) & ")",
-                        Type_Mark);
-                     return Type_Mark;
-                  end if;
-            end case;
+            Free_Name (Def);
+            Set_Signal_Type_Flag (Res, Get_Signal_Type_Flag (Type_Mark));
+            Set_Constraint_State (Res, Get_Constraint_State (Type_Mark));
+            El_List := Null_Iir_List;
+
+         when Iir_Kind_Array_Subtype_Definition =>
+            --  Record constraints are parsed as array constraints.
+            if Get_Kind (Def) /= Iir_Kind_Array_Subtype_Definition then
+               raise Internal_Error;
+            end if;
+            Index_List := Get_Index_Subtype_List (Def);
+            El_List := Create_Iir_List;
+            Set_Elements_Declaration_List (Res, El_List);
+            for I in Natural loop
+               Index_El := Get_Nth_Element (Index_List, I);
+               exit when Index_El = Null_Iir;
+               El := Reparse_As_Record_Element_Constraint (Index_El);
+               if El /= Null_Iir then
+                  Append_Element (El_List, El);
+               end if;
+            end loop;
+
+         when Iir_Kind_Record_Subtype_Definition =>
+            El_List := Get_Elements_Declaration_List (Def);
+            Set_Elements_Declaration_List (Res, El_List);
+
          when others =>
-            Error_Kind ("sem_subtype_indication", Def);
+            Error_Kind ("sem_record_constraint", Def);
       end case;
 
-      case Get_Kind (Type_Mark) is
-         when Iir_Kind_Array_Subtype_Definition
-           | Iir_Kind_Array_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition =>
---             --  If the base type is an unconstrained array subtype, then get
---            --  the *real* base type, and copy the resolution function (since
---             --  a base type has no resolution function).
---             if Get_Kind (Type_Mark) =
---               Iir_Kind_Unconstrained_Array_Subtype_Definition
---               and then Get_Kind (Def) = Iir_Kind_Subtype_Definition
---             then
---                if Get_Resolution_Function (Def) = Null_Iir then
---                   if Get_Range_Constraint (Def) = Null_Iir then
---                      --  In this case, DEF must simply be a name.  There is
---                      --  a parser internal error.
---                      raise Internal_Error;
---                   end if;
---                   Set_Resolution_Function
---                     (Def, Get_Resolution_Function (Type_Mark));
---                end if;
---             end if;
+      Res_List := Null_Iir_List;
+      if Resolution /= Null_Iir then
+         case Get_Kind (Resolution) is
+            when Iir_Kinds_Name =>
+               null;
+            when Iir_Kind_Record_Subtype_Definition =>
+               Res_List := Get_Elements_Declaration_List (Resolution);
+            when Iir_Kind_Array_Subtype_Definition =>
+               Error_Msg_Sem
+                 ("resolution indication must be an array element resolution",
+                  Resolution);
+            when others =>
+               Error_Kind ("sem_record_constraint(resolution)", Resolution);
+         end case;
+      end if;
 
-            if Get_Kind (Def) = Iir_Kind_Subtype_Definition then
-               -- This is the case of "subtype new_array is [func] old_array".
-               -- def must be a constrained array.
-               if Get_Range_Constraint (Def) /= Null_Iir then
-                  Error_Msg_Sem
-                    ("cannot use a range constraint for an array", Def);
-                  return Type_Mark;
-               end if;
-               if Get_Resolution_Function (Def) = Null_Iir then
-                  --  In this case, DEF must simply be a name.  There is
-                  --  a parser internal error.
-                  raise Internal_Error;
-               end if;
-               case Get_Kind (Type_Mark) is
-                  when Iir_Kind_Array_Type_Definition =>
-                     Res := Create_Iir
-                       (Iir_Kind_Unconstrained_Array_Subtype_Definition);
-                  when Iir_Kind_Array_Subtype_Definition =>
-                     Res := Create_Iir (Iir_Kind_Array_Subtype_Definition);
-                     Set_Element_Subtype
-                       (Res, Get_Element_Subtype (Type_Mark));
-                     Set_Index_Subtype_List
-                       (Res, Get_Index_Subtype_List (Type_Mark));
-                  when others =>
-                     Error_Kind ("sem_subtype_indication(array)", Type_Mark);
-               end case;
-               Location_Copy (Res, Def);
-               Set_Base_Type (Res, Get_Base_Type (Type_Mark));
-               Set_Resolution_Function (Res, Get_Resolution_Function (Def));
-               Set_Type_Staticness (Res, Get_Type_Staticness (Type_Mark));
-               Sem_Resolution_Function (Res);
-               Set_Signal_Type_Flag (Res, Get_Signal_Type_Flag (Type_Mark));
-               if Get_Resolved_Flag (Res)
-                 or else Get_Resolved_Flag (Get_Element_Subtype (Type_Mark))
-               then
-                  Set_Resolved_Flag (Res, True);
-               else
-                  Set_Resolved_Flag (Res, False);
-               end if;
-               Set_Type_Mark (Res, Type_Mark);
-               Free_Name (Def);
-               return Res;
-            elsif Get_Kind (Def) = Iir_Kind_Array_Subtype_Definition then
-               -- Case of a constraint for an array.
-               -- Check each index constraint against array type.
-               return Sem_Array_Subtype_Indication (Type_Mark, Def);
-            else
-               Error_Kind ("sem_subtype_indication(1)", Def);
-               return Type_Mark;
+      Tm_El_List := Get_Elements_Declaration_List (Type_Mark);
+      if El_List /= Null_Iir_List or Res_List /= Null_Iir_List then
+         declare
+            Nbr_Els : constant Natural := Get_Nbr_Elements (Tm_El_List);
+            Els : Iir_Array (0 .. Nbr_Els - 1) := (others => Null_Iir);
+            Res_Els : Iir_Array (0 .. Nbr_Els - 1) := (others => Null_Iir);
+            Pos : Natural;
+            Constraint : Iir_Constraint;
+         begin
+            --  Fill ELS.
+            if El_List /= Null_Iir_List then
+               for I in Natural loop
+                  El := Get_Nth_Element (El_List, I);
+                  exit when El = Null_Iir;
+                  Tm_El := Find_Name_In_List (Tm_El_List, Get_Identifier (El));
+                  if Tm_El = Null_Iir then
+                     Error_Msg_Sem (Disp_Node (Type_Mark)
+                                      & "has no " & Disp_Node (El), El);
+                  else
+                     Set_Element_Declaration (El, Tm_El);
+                     Pos := Natural (Get_Element_Position (Tm_El));
+                     if Els (Pos) /= Null_Iir then
+                        Error_Msg_Sem
+                          (Disp_Node (El) & " was already constrained", El);
+                        Error_Msg_Sem
+                          (" (location of previous constrained)", Els (Pos));
+                     else
+                        Els (Pos) := El;
+                        Set_Parent (El, Res);
+                     end if;
+                     El_Type := Get_Type (El);
+                     Tm_El_Type := Get_Type (Tm_El);
+                     if Get_Kind (El_Type) = Iir_Kind_Parenthesis_Name then
+                        case Get_Kind (Tm_El_Type) is
+                           when Iir_Kinds_Array_Type_Definition =>
+                              El_Type := Reparse_As_Array_Constraint
+                                (El_Type, Tm_El_Type);
+                           when Iir_Kind_Record_Type_Definition
+                             | Iir_Kind_Record_Subtype_Definition =>
+                              El_Type := Reparse_As_Record_Constraint
+                                (El_Type);
+                           when others =>
+                              Error_Msg_Sem
+                                ("only composite types may be constrained",
+                                 El_Type);
+                        end case;
+                     end if;
+                     Set_Type (El, El_Type);
+                  end if;
+               end loop;
+               Destroy_Iir_List (El_List);
             end if;
 
-         when Iir_Kind_Integer_Subtype_Definition
-           | Iir_Kind_Floating_Subtype_Definition
-           | Iir_Kind_Enumeration_Subtype_Definition
-           | Iir_Kind_Physical_Subtype_Definition =>
-            if Get_Range_Constraint (Def) = Null_Iir
-              and then Get_Resolution_Function (Def) = Null_Iir
-            then
-               --  This defines an alias, and must have been handled just
-               --  before the case statment.
-               raise Internal_Error;
+            --  Fill Res_Els.
+            if Res_List /= Null_Iir_List then
+               for I in Natural loop
+                  El := Get_Nth_Element (Res_List, I);
+                  exit when El = Null_Iir;
+                  Tm_El := Find_Name_In_List (Tm_El_List, Get_Identifier (El));
+                  if Tm_El = Null_Iir then
+                     Error_Msg_Sem (Disp_Node (Type_Mark)
+                                      & "has no " & Disp_Node (El), El);
+                  else
+                     Pos := Natural (Get_Element_Position (Tm_El));
+                     if Res_Els (Pos) /= Null_Iir then
+                        Error_Msg_Sem
+                          (Disp_Node (El) & " was already resolved", El);
+                        Error_Msg_Sem
+                          (" (location of previous constrained)", Els (Pos));
+                     else
+                        Res_Els (Pos) := Get_Element_Declaration (El);
+                     end if;
+                  end if;
+                  --Free_Iir (El);
+               end loop;
+               Destroy_Iir_List (Res_List);
             end if;
-            declare
-               A_Range : Iir;
-            begin
-               -- There are limits.  Create a new subtype.
-               Res := Create_Iir (Get_Kind (Type_Mark));
-               Location_Copy (Res, Def);
-               Set_Base_Type (Res, Get_Base_Type (Type_Mark));
-               Set_Type_Mark (Res, Type_Mark);
-               Set_Resolution_Function (Res, Get_Resolution_Function (Def));
-               A_Range := Get_Range_Constraint (Def);
-               if A_Range = Null_Iir then
-                  A_Range := Get_Range_Constraint (Type_Mark);
+
+            --  Build elements list.
+            El_List := Create_Iir_List;
+            Set_Elements_Declaration_List (Res, El_List);
+            Constraint := Fully_Constrained;
+            for I in Els'Range loop
+               Tm_El := Get_Nth_Element (Tm_El_List, I);
+               if Els (I) = Null_Iir and Res_Els (I) = Null_Iir then
+                  El := Tm_El;
                else
-                  A_Range := Sem_Discrete_Range_Expression
-                    (A_Range, Type_Mark, True);
-                  if A_Range = Null_Iir then
-                     --  Avoid error propagation.
-                     A_Range := Get_Range_Constraint (Type_Mark);
+                  if Els (I) = Null_Iir then
+                     El := Create_Iir (Iir_Kind_Record_Element_Constraint);
+                     Location_Copy (El, Tm_El);
+                     Set_Element_Declaration (El, Tm_El);
+                     Set_Element_Position (El, Get_Element_Position (Tm_El));
+                     El_Type := Null_Iir;
+                  else
+                     El := Els (I);
+                     El_Type := Get_Type (El);
                   end if;
+                  El_Type := Sem_Subtype_Constraint (El_Type,
+                                                     Get_Type (Tm_El),
+                                                     Res_Els (I));
+                  Set_Type (El, El_Type);
                end if;
-               Set_Range_Constraint (Res, A_Range);
-               Set_Type_Staticness (Res, Get_Expr_Staticness (A_Range));
-               Free_Name (Def);
-               Sem_Resolution_Function (Res);
-               Set_Signal_Type_Flag (Res, Get_Signal_Type_Flag (Type_Mark));
-               return Res;
-            end;
+               Append_Element (El_List, El);
+               Constraint := Update_Record_Constraint
+                 (Constraint, Get_Type (El));
+            end loop;
+            Set_Constraint_State (Res, Constraint);
+         end;
+      else
+         Set_Elements_Declaration_List (Res, Tm_El_List);
+         Set_Constraint_State (Res, Get_Constraint_State (Type_Mark));
+      end if;
 
-         when Iir_Kind_Enumeration_Type_Definition =>
-            if Get_Range_Constraint (Def) = Null_Iir and then
-              Get_Resolution_Function (Def) = Null_Iir
-            then
-               raise Internal_Error;
-            end if;
+      Set_Signal_Type_Flag (Res, Get_Signal_Type_Flag (Type_Mark));
 
-            declare
-               Constraint : Iir_Range_Expression;
-            begin
-               -- There are limits.  Create a new subtype.
-               Res := Create_Iir (Iir_Kind_Enumeration_Subtype_Definition);
-               Location_Copy (Res, Def);
-               Set_Base_Type (Res, Type_Mark);
-               Set_Type_Mark (Res, Type_Mark);
-               Set_Resolution_Function (Res, Get_Resolution_Function (Def));
-               Constraint := Get_Range_Constraint (Def);
-               if Constraint = Null_Iir then
-                  Constraint := Get_Range_Constraint (Type_Mark);
-               else
-                  Constraint := Sem_Discrete_Range_Expression
-                    (Constraint, Type_Mark, True);
-                  -- FIXME: check bounds, check static
-               end if;
-               Set_Range_Constraint (Res, Constraint);
-               Set_Type_Staticness (Res, Get_Expr_Staticness (Constraint));
-            end;
-            Free_Name (Def);
-            Sem_Resolution_Function (Res);
-            Set_Signal_Type_Flag (Res, True);
-            return Res;
+      if Resolution /= Null_Iir
+        and then Get_Kind (Resolution) in Iir_Kinds_Name
+      then
+         Sem_Resolution_Function (Resolution, Res);
+      end if;
 
-         when Iir_Kind_Record_Type_Definition =>
-            declare
-               Func: Iir;
-            begin
-               if Get_Kind (Def) /= Iir_Kind_Subtype_Definition then
-                  Error_Kind ("sem_subtype_indication1", Def);
-                  return Null_Iir;
-               end if;
-               Func := Get_Resolution_Function (Def);
-               if Func = Null_Iir then
-                  --  This is an alias.
-                  raise Internal_Error;
-               end if;
-               Res := Create_Iir (Iir_Kind_Record_Subtype_Definition);
-               Location_Copy (Res, Def);
-               Set_Base_Type (Res, Type_Mark);
-               Set_Type_Staticness (Res, Get_Type_Staticness (Type_Mark));
-               Set_Type_Mark (Res, Type_Mark);
-               Set_Resolution_Function (Res, Func);
-               Sem_Resolution_Function (Res);
-               Set_Signal_Type_Flag (Res, Get_Signal_Type_Flag (Type_Mark));
-               Free_Name (Def);
-               return Res;
-            end;
+      return Res;
+   end Sem_Record_Constraint;
 
-         when Iir_Kind_Access_Type_Definition =>
+   function Sem_Range_Constraint (Def : Iir; Type_Mark : Iir; Resolution : Iir)
+                                 return Iir
+   is
+      Res : Iir;
+      A_Range : Iir;
+   begin
+      if Def = Null_Iir then
+         Res := Copy_Subtype_Indication (Type_Mark);
+      else
+         if Get_Kind (Def) /= Iir_Kind_Subtype_Definition then
+            --  FIXME: find the correct sentence from LRM
+            --  GHDL: subtype_definition may also be used just to add
+            --    a resolution function.
+            Error_Msg_Sem
+              ("only scalar types may be constrained by range", Def);
+            Error_Msg_Sem
+              (" (type mark is " & Disp_Node (Type_Mark) & ")",
+               Type_Mark);
+            return Type_Mark;
+         end if;
+
+         if Get_Range_Constraint (Def) = Null_Iir
+           and then Resolution = Null_Iir
+         then
+            --  This defines an alias, and must have been handled just
+            --  before the case statment.
+            raise Internal_Error;
+         end if;
+
+         -- There are limits.  Create a new subtype.
+         if Get_Kind (Type_Mark) = Iir_Kind_Enumeration_Type_Definition then
+            Res := Create_Iir (Iir_Kind_Enumeration_Subtype_Definition);
+         else
+            Res := Create_Iir (Get_Kind (Type_Mark));
+         end if;
+         Location_Copy (Res, Def);
+         Set_Base_Type (Res, Get_Base_Type (Type_Mark));
+         Set_Type_Mark (Res, Type_Mark);
+         Set_Resolution_Function (Res, Get_Resolution_Function (Def));
+         A_Range := Get_Range_Constraint (Def);
+         if A_Range = Null_Iir then
+            A_Range := Get_Range_Constraint (Type_Mark);
+         else
+            A_Range := Sem_Discrete_Range_Expression
+              (A_Range, Type_Mark, True);
+            if A_Range = Null_Iir then
+               --  Avoid error propagation.
+               A_Range := Get_Range_Constraint (Type_Mark);
+            end if;
+         end if;
+         Set_Range_Constraint (Res, A_Range);
+         Set_Type_Staticness (Res, Get_Expr_Staticness (A_Range));
+         Free_Name (Def);
+         Set_Signal_Type_Flag (Res, Get_Signal_Type_Flag (Type_Mark));
+      end if;
+
+      if Resolution /= Null_Iir then
+         --  LRM08 6.3  Subtype declarations.
+         if Get_Kind (Resolution) not in Iir_Kinds_Name then
+            Error_Msg_Sem ("resolution indication must be a function name",
+                           Resolution);
+         else
+            Sem_Resolution_Function (Resolution, Res);
+         end if;
+      end if;
+      return Res;
+   end Sem_Range_Constraint;
+
+   function Sem_Subtype_Constraint
+     (Def : Iir; Type_Mark : Iir; Resolution : Iir)
+     return Iir
+   is
+   begin
+      case Get_Kind (Type_Mark) is
+         when Iir_Kind_Array_Subtype_Definition
+           | Iir_Kind_Array_Type_Definition =>
+            return Sem_Array_Constraint (Def, Type_Mark, Resolution);
+         when Iir_Kind_Integer_Subtype_Definition
+           | Iir_Kind_Floating_Subtype_Definition
+           | Iir_Kind_Enumeration_Subtype_Definition
+           | Iir_Kind_Physical_Subtype_Definition
+           | Iir_Kind_Enumeration_Type_Definition=>
+            return Sem_Range_Constraint (Def, Type_Mark, Resolution);
+         when Iir_Kind_Record_Type_Definition
+           | Iir_Kind_Record_Subtype_Definition =>
+            return Sem_Record_Constraint (Def, Type_Mark, Resolution);
+         when Iir_Kind_Access_Type_Definition
+           | Iir_Kind_Access_Subtype_Definition =>
             --  LRM93 4.2
             --  A subtype indication denoting an access type [or a file type]
             --  may not contain a resolution function.
-            if Get_Resolution_Function (Def) /= Null_Iir then
+            if Resolution /= Null_Iir then
                Error_Msg_Sem
                  ("resolution function not allowed for an access type", Def);
             end if;
@@ -1478,10 +1824,13 @@
                   --  constraint.
                   declare
                      Sub_Type : Iir;
+                     pragma Unreferenced (Sub_Type);
                      Base_Type : Iir;
+                     Res : Iir;
                   begin
                      Base_Type := Get_Designated_Type (Type_Mark);
-                     Sub_Type := Sem_Array_Subtype_Indication (Base_Type, Def);
+                     Sub_Type := Sem_Array_Constraint
+                       (Def, Base_Type, Null_Iir);
                      Res := Create_Iir (Iir_Kind_Access_Subtype_Definition);
                      Location_Copy (Res, Def);
                      Set_Base_Type (Res, Type_Mark);
@@ -1494,50 +1843,157 @@
             end case;
 
          when Iir_Kind_File_Type_Definition =>
-            if Get_Kind (Def) = Iir_Kind_Subtype_Definition then
-               Free_Name (Def);
+            --  LRM08 6.3 Subtype declarations
+            --  A subtype indication denoting a subtype of [...] a file
+            --  type [...] shall not contain a constraint.
+            if Get_Kind (Def) /= Iir_Kind_Subtype_Definition
+              or else Get_Range_Constraint (Def) /= Null_Iir
+            then
+               Error_Msg_Sem ("file types can't be constrained", Def);
+               return Type_Mark;
+            end if;
+
+            --  LRM93 4.2
+            --  A subtype indication denoting [an access type or] a file type
+            --  may not contain a resolution function.
+            if Resolution /= Null_Iir then
+               Error_Msg_Sem
+                 ("resolution function not allowed for file types", Def);
+               return Type_Mark;
+            end if;
+            Free_Name (Def);
+            return Type_Mark;
+
+         when Iir_Kind_Protected_Type_Declaration =>
+            --  LRM08 6.3 Subtype declarations
+            --  A subtype indication denoting a subtype of [...] a protected
+            --  type [...] shall not contain a constraint.
+            if Get_Kind (Def) /= Iir_Kind_Subtype_Definition
+              or else Get_Range_Constraint (Def) /= Null_Iir
+            then
+               Error_Msg_Sem ("protected types can't be constrained", Def);
+               return Type_Mark;
+            end if;
+
+            --  LRM08 6.3 Subtype declarations
+            --  A subtype indication denoting [...] a protected type shall
+            --  not contain a resolution function.
+            if Resolution /= Null_Iir then
+               Error_Msg_Sem
+                 ("resolution function not allowed for file types", Def);
                return Type_Mark;
-            else
-               raise Internal_Error;
             end if;
+            Free_Name (Def);
+            return Type_Mark;
 
          when others =>
             Error_Kind ("sem_subtype_indication", Type_Mark);
-            return Def;
+            return Type_Mark;
       end case;
+   end Sem_Subtype_Constraint;
+
+   --  Semantize a subtype indication.
+   --  DEF can be either a name or an iir_subtype_definition.
+   --  Return a new (an anonymous) subtype definition (with the correct kind),
+   --  or an already defined type definition (if DEF is a name).
+   function Sem_Subtype_Indication (Def: Iir; Incomplete : Boolean := False)
+     return Iir
+   is
+      Type_Mark: Iir;
+      Decl_Kind : Decl_Kind_Type;
+   begin
+      if Incomplete then
+         Decl_Kind := Decl_Incomplete_Type;
+      else
+         Decl_Kind := Decl_Type;
+      end if;
+
+      -- LRM08 6.3 Subtype declarations
+      --
+      -- If the subtype indication does not include a constraint, the subtype
+      -- is the same as that denoted by the type mark.
+      if Get_Kind (Def) in Iir_Kinds_Name then
+         Type_Mark := Find_Declaration (Def, Decl_Kind);
+         if Type_Mark = Null_Iir then
+            return Create_Error_Type (Def);
+         else
+            return Type_Mark;
+         end if;
+      end if;
+
+      --  Semantize the type mark.
+      Type_Mark := Find_Declaration (Get_Type_Mark (Def), Decl_Kind);
+      if Type_Mark = Null_Iir then
+         --  FIXME: handle inversion such as "subtype BASETYPE RESOLV", which
+         --  should emit "resolution function must precede type name".
+         return Create_Error_Type (Get_Type_Mark (Def));
+      end if;
+      Set_Type_Mark (Def, Type_Mark);
+
+      return Sem_Subtype_Constraint
+        (Def, Type_Mark, Get_Resolution_Function (Def));
    end Sem_Subtype_Indication;
 
-   function Sem_Is_Constrained (A_Type: Iir) return Boolean is
+   function Copy_Subtype_Indication (Def : Iir) return Iir
+   is
+      Res : Iir;
    begin
-      case Get_Kind (A_Type) is
-         when Iir_Kind_Array_Subtype_Definition =>
-            return True;
-         when Iir_Kind_Enumeration_Subtype_Definition
-           | Iir_Kind_Enumeration_Type_Definition
-           | Iir_Kind_Integer_Subtype_Definition
-           | Iir_Kind_Integer_Type_Definition
+      case Get_Kind (Def) is
+         when Iir_Kind_Integer_Subtype_Definition
            | Iir_Kind_Floating_Subtype_Definition
-           | Iir_Kind_Floating_Type_Definition
-           | Iir_Kind_Access_Type_Definition
-           | Iir_Kind_Access_Subtype_Definition
-           | Iir_Kind_Physical_Subtype_Definition
-           | Iir_Kind_Record_Type_Definition
-           | Iir_Kind_Record_Subtype_Definition
-           | Iir_Kind_File_Type_Definition =>
-            --| Iir_Kind_File_Subtype_Definition =>
-            return True;
-         when Iir_Kind_Protected_Type_Declaration =>
-            return True;
-         when Iir_Kind_Array_Type_Definition
-           | Iir_Kind_Unconstrained_Array_Subtype_Definition =>
-            return False;
-         when Iir_Kind_Incomplete_Type_Definition =>
-            return False;
-         when Iir_Kind_Error =>
-            return True;
+           | Iir_Kind_Enumeration_Subtype_Definition
+           | Iir_Kind_Physical_Subtype_Definition =>
+            Res := Create_Iir (Get_Kind (Def));
+            Set_Range_Constraint (Res, Get_Range_Constraint (Def));
+            Set_Resolution_Function (Res, Get_Resolution_Function (Def));
+         when Iir_Kind_Enumeration_Type_Definition =>
+            Res := Create_Iir (Iir_Kind_Enumeration_Subtype_Definition);
+            Set_Type_Mark (Res, Def);
+            Set_Range_Constraint (Res, Get_Range_Constraint (Def));
+
+         when Iir_Kind_Access_Subtype_Definition
+           | Iir_Kind_Access_Type_Definition =>
+            Res := Create_Iir (Iir_Kind_Access_Subtype_Definition);
+
+         when Iir_Kind_Array_Type_Definition =>
+            Res := Create_Iir (Iir_Kind_Array_Subtype_Definition);
+            Set_Type_Staticness (Res, Get_Type_Staticness (Def));
+            Set_Resolved_Flag (Res, Get_Resolved_Flag (Def));
+            Set_Type_Mark (Res, Def);
+            Set_Index_Subtype_List (Res, Get_Index_Subtype_List (Def));
+            Set_Element_Subtype (Res, Get_Element_Subtype (Def));
+            Set_Index_Constraint_Flag (Res, False);
+            Set_Constraint_State (Res, Get_Constraint_State (Def));
+         when Iir_Kind_Array_Subtype_Definition =>
+            Res := Create_Iir (Iir_Kind_Array_Subtype_Definition);
+            Set_Resolution_Function (Res, Get_Resolution_Function (Def));
+            Set_Resolved_Flag (Res, Get_Resolved_Flag (Def));
+            Set_Type_Mark (Res, Def);
+            Set_Index_Subtype_List (Res, Get_Index_Subtype_List (Def));
+            Set_Element_Subtype (Res, Get_Element_Subtype (Def));
+            Set_Index_Constraint_Flag
+              (Res, Get_Index_Constraint_Flag (Def));
+            Set_Constraint_State (Res, Get_Constraint_State (Def));
+
+         when Iir_Kind_Record_Type_Definition
+           | Iir_Kind_Record_Subtype_Definition =>
+            Res := Create_Iir (Iir_Kind_Record_Subtype_Definition);
+            Set_Type_Staticness (Res, Get_Type_Staticness (Def));
+            if Get_Kind (Def) /= Iir_Kind_Record_Type_Definition then
+               Set_Resolution_Function
+                 (Res, Get_Resolution_Function (Def));
+            end if;
+            Set_Resolved_Flag (Res, Get_Resolved_Flag (Def));
+            Set_Constraint_State (Res, Get_Constraint_State (Def));
+
          when others =>
-            Error_Kind ("sem_is_constrained", A_Type);
+            --  FIXME: todo
+            Error_Kind ("copy_subtype_indication", Def);
       end case;
-   end Sem_Is_Constrained;
-
+      Location_Copy (Res, Def);
+      Set_Base_Type (Res, Get_Base_Type (Def));
+      Set_Type_Staticness (Res, Get_Type_Staticness (Def));
+      Set_Signal_Type_Flag (Res, Get_Signal_Type_Flag (Def));
+      return Res;
+   end Copy_Subtype_Indication;
 end Sem_Types;
diff -urN ghdl-0.27/vhdl/sem_types.ads ghdl-0.28dev/vhdl/sem_types.ads
--- ghdl-0.27/vhdl/sem_types.ads	2006-05-13 17:30:11.000000000 +0200
+++ ghdl-0.28dev/vhdl/sem_types.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
@@ -28,7 +28,7 @@
      return Iir;
 
    -- Return FALSE if A_TYPE is an unconstrained array type or subtype.
-   function Sem_Is_Constrained (A_Type: Iir) return Boolean;
+   --function Sem_Is_Constrained (A_Type: Iir) return Boolean;
 
    procedure Sem_Protected_Type_Body (Bod : Iir);
 
@@ -50,4 +50,8 @@
    --  If ATYPE is not NULL_IIR, type must match.
    function Is_A_Resolution_Function (Func: Iir; Atype: Iir) return Boolean;
 
+   --  Return a subtype definition copy of DEF.
+   --  This is used when an alias of DEF is required (eg: subtype a is b).
+   function Copy_Subtype_Indication (Def : Iir) return Iir;
+
 end Sem_Types;
diff -urN ghdl-0.27/vhdl/std_names.adb ghdl-0.28dev/vhdl/std_names.adb
--- ghdl-0.27/vhdl/std_names.adb	2006-06-14 22:01:16.000000000 +0200
+++ ghdl-0.28dev/vhdl/std_names.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Name_Table;
@@ -55,6 +55,7 @@
         or GI ("/") /= Name_Op_Div
         or GI ("**") /= Name_Op_Exp
         or GI ("&") /= Name_Op_Concatenation
+        or GI ("??") /= Name_Op_Condition
       then
          raise Program_Error;
       end if;
@@ -226,6 +227,7 @@
         or GI ("file_close") /= Name_File_Close
         or GI ("read") /= Name_Read
         or GI ("write") /= Name_Write
+        or GI ("flush") /= Name_Flush
         or GI ("endfile") /= Name_Endfile
         or GI ("p") /= Name_P
         or GI ("f") /= Name_F
@@ -237,6 +239,7 @@
         or GI ("textio") /= Name_Textio
         or GI ("work") /= Name_Work
         or GI ("text") /= Name_Text
+        or GI ("to_string") /= Name_To_String
         or GI ("untruncated_text_read") /= Name_Untruncated_Text_Read
       then
          raise Program_Error;
@@ -257,6 +260,7 @@
          raise Program_Error;
       end if;
 
+      --  Verilog keywords
       if GI ("always") /= Name_Always
         or GI ("assign") /= Name_Assign
         or GI ("buf") /= Name_Buf
@@ -348,5 +352,53 @@
          raise Program_Error;
       end if;
 
+      --  PSL keywords
+      if GI ("a") /= Name_A
+        or GI ("af") /= Name_Af
+        or GI ("ag") /= Name_Ag
+        or GI ("ax") /= Name_Ax
+        or GI ("abort") /= Name_Abort
+        or GI ("assume") /= Name_Assume
+        or GI ("assume_guarantee") /= Name_Assume_Guarantee
+        or GI ("before") /= Name_Before
+        or GI ("clock") /= Name_Clock
+        or GI ("const") /= Name_Const
+        or GI ("cover") /= Name_Cover
+        or GI ("e") /= Name_E
+        or GI ("ef") /= Name_Ef
+        or GI ("eg") /= Name_Eg
+        or GI ("ex") /= Name_Ex
+        or GI ("endpoint") /= Name_Endpoint
+        or GI ("eventually") /= Name_Eventually
+        or GI ("fairness") /= Name_Fairness
+        or GI ("fell ") /= Name_Fell
+        or GI ("forall") /= Name_forall
+        or GI ("g") /= Name_G
+        or GI ("inf") /= Name_Inf
+        or GI ("inherit") /= Name_Inherit
+        or GI ("never") /= Name_Never
+        or GI ("next_a") /= Name_Next_A
+        or GI ("next_e") /= Name_Next_E
+        or GI ("next_event") /= Name_Next_Event
+        or GI ("next_event_a") /= Name_Next_Event_A
+        or GI ("next_event_e") /= Name_Next_Event_E
+        or GI ("property") /= Name_Property
+        or GI ("prev") /= Name_Prev
+        or GI ("restrict") /= Name_Restrict
+        or GI ("restrict_guarantee") /= Name_Restrict_Guarantee
+        or GI ("rose") /= Name_Rose
+        or GI ("sequence") /= Name_Sequence
+        or GI ("strong") /= Name_Strong
+        or GI ("union") /= Name_Union
+        or GI ("vmode") /= Name_Vmode
+        or GI ("vprop") /= Name_Vprop
+        or GI ("vunit") /= Name_Vunit
+        or GI ("w") /= Name_W
+        or GI ("whilenot") /= Name_Whilenot
+        or GI ("within") /= Name_Within
+        or GI ("x") /= Name_X
+      then
+         raise Program_Error;
+      end if;
    end Std_Names_Initialize;
 end Std_Names;
diff -urN ghdl-0.27/vhdl/std_names.ads ghdl-0.28dev/vhdl/std_names.ads
--- ghdl-0.27/vhdl/std_names.ads	2006-06-14 22:01:16.000000000 +0200
+++ ghdl-0.28dev/vhdl/std_names.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
@@ -182,7 +182,8 @@
    Name_Op_Div :         constant Name_Id := Name_First_Operator + 009;
    Name_Op_Exp :         constant Name_Id := Name_First_Operator + 010;
    Name_Op_Concatenation : constant Name_Id := Name_First_Operator + 011;
-   Name_Last_Operator :  constant Name_Id := Name_Op_Concatenation;
+   Name_Op_Condition :   constant Name_Id := Name_First_Operator + 012;
+   Name_Last_Operator :  constant Name_Id := Name_Op_Condition;
 
    subtype Name_Relational_Operators is Name_Id
      range Name_Op_Equality .. Name_Op_Greater_Equal;
@@ -367,18 +368,20 @@
    Name_File_Close :     constant Name_Id := Name_First_Misc + 003;
    Name_Read :           constant Name_Id := Name_First_Misc + 004;
    Name_Write :          constant Name_Id := Name_First_Misc + 005;
-   Name_Endfile :        constant Name_Id := Name_First_Misc + 006;
-   Name_P :              constant Name_Id := Name_First_Misc + 007;
-   Name_F :              constant Name_Id := Name_First_Misc + 008;
-   Name_External_Name :  constant Name_Id := Name_First_Misc + 009;
-   Name_Open_Kind :      constant Name_Id := Name_First_Misc + 010;
-   Name_Status :         constant Name_Id := Name_First_Misc + 011;
-   Name_First :          constant Name_Id := Name_First_Misc + 012;
-   Name_Last :           constant Name_Id := Name_First_Misc + 013;
-   Name_Textio :         constant Name_Id := Name_First_Misc + 014;
-   Name_Work :           constant Name_Id := Name_First_Misc + 015;
-   Name_Text :           constant Name_Id := Name_First_Misc + 016;
-   Name_Untruncated_Text_Read : constant Name_Id := Name_First_Misc + 017;
+   Name_Flush :          constant Name_Id := Name_First_Misc + 006;
+   Name_Endfile :        constant Name_Id := Name_First_Misc + 007;
+   Name_P :              constant Name_Id := Name_First_Misc + 008;
+   Name_F :              constant Name_Id := Name_First_Misc + 009;
+   Name_External_Name :  constant Name_Id := Name_First_Misc + 010;
+   Name_Open_Kind :      constant Name_Id := Name_First_Misc + 011;
+   Name_Status :         constant Name_Id := Name_First_Misc + 012;
+   Name_First :          constant Name_Id := Name_First_Misc + 013;
+   Name_Last :           constant Name_Id := Name_First_Misc + 014;
+   Name_Textio :         constant Name_Id := Name_First_Misc + 015;
+   Name_Work :           constant Name_Id := Name_First_Misc + 016;
+   Name_Text :           constant Name_Id := Name_First_Misc + 017;
+   Name_To_String :      constant Name_Id := Name_First_Misc + 018;
+   Name_Untruncated_Text_Read : constant Name_Id := Name_First_Misc + 019;
    Name_Last_Misc :      constant Name_Id := Name_Untruncated_Text_Read;
 
    Name_First_Ieee :     constant Name_Id := Name_Last_Misc + 1;
@@ -486,6 +489,63 @@
    Name_Finish :         constant Name_Id := Name_First_Systask + 01;
    Name_Last_Systask :   constant Name_Id := Name_Finish;
 
+   Name_First_Psl :          constant Name_Id := Name_Last_Systask + 1;
+   Name_A :                  constant Name_Id := Name_First_Psl + 00;
+   Name_Af :                 constant Name_Id := Name_First_Psl + 01;
+   Name_Ag :                 constant Name_Id := Name_First_Psl + 02;
+   Name_Ax :                 constant Name_Id := Name_First_Psl + 03;
+   Name_Abort :              constant Name_Id := Name_First_Psl + 04;
+   --  Name_Always
+   --  Name_And
+   Name_Assume :             constant Name_Id := Name_First_Psl + 05;
+   Name_Assume_Guarantee :   constant Name_Id := Name_First_Psl + 06;
+   Name_Before :             constant Name_Id := Name_First_Psl + 07;
+   --  Name_Boolean
+   Name_Clock :              constant Name_Id := Name_First_Psl + 08;
+   Name_Const :              constant Name_Id := Name_First_Psl + 09;
+   Name_Cover :              constant Name_Id := Name_First_Psl + 10;
+   --  Name_Default
+   Name_E :                  constant Name_Id := Name_First_Psl + 11;
+   Name_Ef :                 constant Name_Id := Name_First_Psl + 12;
+   Name_Eg :                 constant Name_Id := Name_First_Psl + 13;
+   Name_Ex :                 constant Name_Id := Name_First_Psl + 14;
+   Name_Endpoint  :          constant Name_Id := Name_First_Psl + 15;
+   Name_Eventually :         constant Name_Id := Name_First_Psl + 16;
+   Name_Fairness :           constant Name_Id := Name_First_Psl + 17;
+   Name_Fell  :              constant Name_Id := Name_First_Psl + 18;
+   Name_forall :             constant Name_Id := Name_First_Psl + 19;
+   Name_G :                  constant Name_Id := Name_First_Psl + 20;
+   --  Name_In
+   Name_Inf :                constant Name_Id := Name_First_Psl + 21;
+   Name_Inherit :            constant Name_Id := Name_First_Psl + 22;
+   --  Name_Is
+   Name_Never :              constant Name_Id := Name_First_Psl + 23;
+   --  Name_Next
+   Name_Next_A :             constant Name_Id := Name_First_Psl + 24;
+   Name_Next_E :             constant Name_Id := Name_First_Psl + 25;
+   Name_Next_Event :         constant Name_Id := Name_First_Psl + 26;
+   Name_Next_Event_A :       constant Name_Id := Name_First_Psl + 27;
+   Name_Next_Event_E :       constant Name_Id := Name_First_Psl + 28;
+   --  Name_Not
+   --  Name_Or
+   Name_Property :           constant Name_Id := Name_First_Psl + 29;
+   Name_Prev :               constant Name_Id := Name_First_Psl + 30;
+   Name_Restrict :           constant Name_Id := Name_First_Psl + 31;
+   Name_Restrict_Guarantee : constant Name_Id := Name_First_Psl + 32;
+   Name_Rose :               constant Name_Id := Name_First_Psl + 33;
+   Name_Sequence :           constant Name_Id := Name_First_Psl + 34;
+   Name_Strong :             constant Name_Id := Name_First_Psl + 35;
+   Name_Union :              constant Name_Id := Name_First_Psl + 36;
+   --  Name_Until
+   Name_Vmode :              constant Name_Id := Name_First_Psl + 37;
+   Name_Vprop :              constant Name_Id := Name_First_Psl + 38;
+   Name_Vunit :              constant Name_Id := Name_First_Psl + 39;
+   Name_W :                  constant Name_Id := Name_First_Psl + 40;
+   Name_Whilenot :           constant Name_Id := Name_First_Psl + 41;
+   Name_Within :             constant Name_Id := Name_First_Psl + 42;
+   Name_X :                  constant Name_Id := Name_First_Psl + 43;
+   Name_Last_Psl :           constant Name_Id := Name_X;
+
    -- Initialize the name table with the values defined here.
    procedure Std_Names_Initialize;
 end Std_Names;
diff -urN ghdl-0.27/vhdl/std_package.adb ghdl-0.28dev/vhdl/std_package.adb
--- ghdl-0.27/vhdl/std_package.adb	2006-06-17 02:46:35.000000000 +0200
+++ ghdl-0.28dev/vhdl/std_package.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,16 +12,15 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
-with Iirs; use Iirs;
 with Types; use Types;
 with Files_Map;
 with Name_Table;
 with Str_Table;
 with Std_Names; use Std_Names;
-with Flags;
+with Flags; use Flags;
 with Iirs_Utils;
 with Sem;
 with Sem_Decls;
@@ -315,6 +314,7 @@
          Set_Signal_Type_Flag (Bit_Type_Definition, True);
          Set_Has_Signal_Flag (Bit_Type_Definition,
                               not Flags.Flag_Whole_Analyze);
+         Set_Only_Characters_Flag (Bit_Type_Definition, True);
 
          -- type bit is
          Bit_Type := Create_Std_Decl (Iir_Kind_Type_Declaration);
@@ -331,6 +331,7 @@
       -- characters.
       declare
          El: Iir;
+         pragma Unreferenced (El);
       begin
          Character_Type_Definition :=
            Create_Std_Iir (Iir_Kind_Enumeration_Type_Definition);
@@ -346,7 +347,7 @@
               (Get_Std_Character (I), Character_Type_Definition);
          end loop;
          El := Create_Std_Literal (Name_Del, Character_Type_Definition);
-         if Flags.Vhdl_Std /= Vhdl_87 then
+         if Vhdl_Std /= Vhdl_87 then
             for I in Name_C128 .. Name_C159 loop
                El := Create_Std_Literal (I, Character_Type_Definition);
             end loop;
@@ -724,7 +725,7 @@
          Time_Hr_Unit: Iir_Unit_Declaration;
          Constraint : Iir_Range_Expression;
       begin
-         if Flags.Vhdl_Std >= Vhdl_93c then
+         if Vhdl_Std >= Vhdl_93c then
             Time_Staticness := Globally;
          else
             Time_Staticness := Locally;
@@ -813,7 +814,7 @@
 
          --  VHDL93
          --  subtype DELAY_LENGTH is TIME range 0 to TIME'HIGH
-         if Flags.Vhdl_Std >= Vhdl_93c then
+         if Vhdl_Std >= Vhdl_93c then
             Delay_Length_Subtype_Definition :=
               Create_Std_Iir (Iir_Kind_Physical_Subtype_Definition);
             Set_Type_Mark (Delay_Length_Subtype_Definition,
@@ -855,12 +856,12 @@
          Function_Now :=
            Create_Std_Decl (Iir_Kind_Implicit_Function_Declaration);
          Set_Std_Identifier (Function_Now, Std_Names.Name_Now);
-         if Flags.Vhdl_Std = Vhdl_87 then
+         if Vhdl_Std = Vhdl_87 then
             Set_Return_Type (Function_Now, Time_Subtype_Definition);
          else
             Set_Return_Type (Function_Now, Delay_Length_Subtype_Definition);
          end if;
-         if Flags.Vhdl_Std = Vhdl_02 then
+         if Vhdl_Std = Vhdl_02 then
             Set_Pure_Flag (Function_Now, True);
          else
             Set_Pure_Flag (Function_Now, False);
@@ -872,7 +873,7 @@
 
       --  VHDL93:
       --  type file_open_kind is (read_mode, write_mode, append_mode);
-      if Flags.Vhdl_Std >= Vhdl_93c then
+      if Vhdl_Std >= Vhdl_93c then
          File_Open_Kind_Type_Definition :=
            Create_Std_Iir (Iir_Kind_Enumeration_Type_Definition);
          Set_Base_Type (File_Open_Kind_Type_Definition,
@@ -912,7 +913,7 @@
       --  VHDL93:
       --  type file_open_status is
       --      (open_ok, status_error, name_error, mode_error);
-      if Flags.Vhdl_Std >= Vhdl_93c then
+      if Vhdl_Std >= Vhdl_93c then
          File_Open_Status_Type_Definition :=
            Create_Std_Iir (Iir_Kind_Enumeration_Type_Definition);
          Set_Base_Type (File_Open_Status_Type_Definition,
@@ -954,7 +955,7 @@
 
       --  VHDL93:
       --  attribute FOREIGN: string;
-      if Flags.Vhdl_Std >= Vhdl_93c then
+      if Vhdl_Std >= Vhdl_93c then
          Foreign_Attribute := Create_Std_Decl (Iir_Kind_Attribute_Declaration);
          Set_Std_Identifier (Foreign_Attribute, Name_Foreign);
          Set_Type (Foreign_Attribute, String_Type_Definition);
diff -urN ghdl-0.27/vhdl/std_package.ads ghdl-0.28dev/vhdl/std_package.ads
--- ghdl-0.27/vhdl/std_package.ads	2005-09-22 23:22:40.000000000 +0200
+++ ghdl-0.28dev/vhdl/std_package.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Iirs; use Iirs;
diff -urN ghdl-0.27/vhdl/str_table.adb ghdl-0.28dev/vhdl/str_table.adb
--- ghdl-0.27/vhdl/str_table.adb	2005-09-22 23:33:18.000000000 +0200
+++ ghdl-0.28dev/vhdl/str_table.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with System;
diff -urN ghdl-0.27/vhdl/str_table.ads ghdl-0.28dev/vhdl/str_table.ads
--- ghdl-0.27/vhdl/str_table.ads	2005-09-22 23:22:51.000000000 +0200
+++ ghdl-0.28dev/vhdl/str_table.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
diff -urN ghdl-0.27/vhdl/tokens.adb ghdl-0.28dev/vhdl/tokens.adb
--- ghdl-0.27/vhdl/tokens.adb	2005-09-22 23:33:25.000000000 +0200
+++ ghdl-0.28dev/vhdl/tokens.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 package body Tokens is
diff -urN ghdl-0.27/vhdl/tokens.ads ghdl-0.28dev/vhdl/tokens.ads
--- ghdl-0.27/vhdl/tokens.ads	2005-09-22 23:23:10.000000000 +0200
+++ ghdl-0.28dev/vhdl/tokens.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 package Tokens is
diff -urN ghdl-0.27/vhdl/trans_analyzes.adb ghdl-0.28dev/vhdl/trans_analyzes.adb
--- ghdl-0.27/vhdl/trans_analyzes.adb	2006-09-27 03:18:41.000000000 +0200
+++ ghdl-0.28dev/vhdl/trans_analyzes.adb	2009-09-20 09:06:43.000000000 +0200
@@ -33,6 +33,7 @@
    function Extract_Driver_Stmt (Stmt : Iir) return Walk_Status
    is
       Status : Walk_Status;
+      pragma Unreferenced (Status);
       We : Iir;
    begin
       case Get_Kind (Stmt) is
@@ -91,6 +92,7 @@
    procedure Extract_Drivers_Sequential_Stmt_Chain (Chain : Iir)
    is
       Status : Walk_Status;
+      pragma Unreferenced (Status);
    begin
       Status := Walk_Sequential_Stmt_Chain (Chain, Extract_Driver_Stmt'Access);
    end Extract_Drivers_Sequential_Stmt_Chain;
diff -urN ghdl-0.27/vhdl/trans_be.adb ghdl-0.28dev/vhdl/trans_be.adb
--- ghdl-0.27/vhdl/trans_be.adb	2006-09-25 15:54:59.000000000 +0200
+++ ghdl-0.28dev/vhdl/trans_be.adb	2009-09-20 09:06:43.000000000 +0200
@@ -135,6 +135,7 @@
    is
       use Translation;
       Fi : Foreign_Info_Type;
+      pragma Unreferenced (Fi);
    begin
       case Get_Kind (Decl) is
          when Iir_Kind_Design_Unit =>
diff -urN ghdl-0.27/vhdl/translation.adb ghdl-0.28dev/vhdl/translation.adb
--- ghdl-0.27/vhdl/translation.adb	2008-06-27 03:10:28.000000000 +0200
+++ ghdl-0.28dev/vhdl/translation.adb	2009-09-20 09:06:43.000000000 +0200
@@ -21,7 +21,7 @@
 with Ortho_Nodes; use Ortho_Nodes;
 with Ortho_Ident; use Ortho_Ident;
 with Evaluation; use Evaluation;
-with Flags;
+with Flags; use Flags;
 with Ada.Text_IO;
 with Types; use Types;
 with Errorout; use Errorout;
@@ -70,7 +70,6 @@
 
    --  Global declarations.
    Ghdl_Ptr_Type : O_Tnode;
-   Const_Ptr_Type_Node : O_Tnode;
    Sizetype : O_Tnode;
    Ghdl_I32_Type : O_Tnode;
    Ghdl_I64_Type : O_Tnode;
@@ -3114,7 +3113,7 @@
       procedure Copy_Fat_Pointer
         (D : O_Dnode; S : O_Dnode; Ftype : Iir; Is_Sig : Object_Kind_Type)
       is
-         Info : Type_Info_Acc := Get_Info (Ftype);
+         Info : constant Type_Info_Acc := Get_Info (Ftype);
       begin
          New_Assign_Stmt
            (New_Selected_Acc_Value (New_Obj (D), Info.T.Base_Field (Is_Sig)),
@@ -3633,22 +3632,24 @@
                   Var_Record : Mnode;
                   Sub_Data : Data_Type;
                   Composite_Data : Composite_Data_Type;
+                  List : Iir_List;
                   El : Iir_Element_Declaration;
                begin
                   Open_Temp;
                   Var_Record := Stabilize (Targ);
                   Composite_Data :=
                     Prepare_Data_Record (Var_Record, Targ_Type, Data);
-                  El := Get_Element_Declaration_Chain
+                  List := Get_Elements_Declaration_List
                     (Get_Base_Type (Targ_Type));
-                  while El /= Null_Iir loop
+                  for I in Natural loop
+                     El := Get_Nth_Element (List, I);
+                     exit when El = Null_Iir;
                      Sub_Data := Update_Data_Record
                        (Composite_Data, Targ_Type, El);
                      Foreach_Non_Composite
                        (Chap6.Translate_Selected_Element (Var_Record, El),
                         Get_Type (El),
                         Sub_Data);
-                     El := Get_Chain (El);
                   end loop;
                   Finish_Data_Record (Composite_Data);
                   Close_Temp;
@@ -3830,12 +3831,9 @@
 
       procedure Translate_Entity_Init (Entity : Iir)
       is
-         Info : Block_Info_Acc;
          El : Iir;
          El_Type : Iir;
       begin
-         Info := Get_Info (Entity);
-
          Push_Local_Factory;
 
          --  Generics.
@@ -3849,9 +3847,7 @@
          El := Get_Port_Chain (Entity);
          while El /= Null_Iir loop
             El_Type := Get_Type (El);
-            if Get_Kind (El_Type)
-              in Iir_Kinds_Unconstrained_Array_Type_Definition
-            then
+            if not Is_Fully_Constrained_Type (El_Type) then
                Chap5.Elab_Unconstrained_Port (El, Get_Default_Value (El));
             end if;
             Chap4.Elab_Signal_Declaration_Storage (El);
@@ -4626,7 +4622,8 @@
          Std_Names.Name_Op_Mul => "OPMu",
          Std_Names.Name_Op_Div => "OPDi",
          Std_Names.Name_Op_Exp => "OPEx",
-         Std_Names.Name_Op_Concatenation => "OPCc");
+         Std_Names.Name_Op_Concatenation => "OPCc",
+         Std_Names.Name_Op_Condition => "OPCd");
 
       --  Set the identifier prefix with the subprogram identifier and
       --  overload number if any.
@@ -4716,7 +4713,6 @@
       is
          Inter : Iir;
          Inter_Type : Iir;
-         Inter_Kind : Iir_Kind;
          Info : Subprg_Info_Acc;
          Arg_Info : Ortho_Info_Acc;
          Tinfo : Type_Info_Acc;
@@ -4772,9 +4768,7 @@
                   Tinfo.Ortho_Ptr_Type (Mode_Value));
                --  Furthermore, if the result type is unconstrained, the
                --  function will allocate it on a secondary stack.
-               if Get_Kind (Rtype)
-                 in Iir_Kinds_Unconstrained_Array_Type_Definition
-               then
+               if not Is_Fully_Constrained_Type (Rtype) then
                   Info.Use_Stack2 := True;
                end if;
             else
@@ -4791,7 +4785,6 @@
             while Inter /= Null_Iir loop
                Arg_Info := Add_Info (Inter, Kind_Interface);
                Inter_Type := Get_Type (Inter);
-               Inter_Kind := Get_Kind (Inter_Type);
                Tinfo := Get_Info (Inter_Type);
                if Get_Kind (Inter) = Iir_Kind_Variable_Interface_Declaration
                  and then Get_Mode (Inter) in Iir_Out_Modes
@@ -5206,6 +5199,7 @@
       is
          Info : Ortho_Info_Acc;
          Final : Boolean;
+         pragma Unreferenced (Final);
       begin
          Info := Get_Info (Spec);
          Start_Subprogram_Body (Info.Package_Elab_Spec_Subprg);
@@ -5891,8 +5885,7 @@
             when Iir_Kinds_Scalar_Type_Definition =>
                return 1;
             when Iir_Kind_Array_Type_Definition
-              | Iir_Kind_Array_Subtype_Definition
-              | Iir_Kind_Unconstrained_Array_Subtype_Definition =>
+              | Iir_Kind_Array_Subtype_Definition =>
                return 2
                  + Get_File_Signature_Length (Get_Element_Subtype (Def));
             when Iir_Kind_Record_Type_Definition
@@ -5900,12 +5893,14 @@
                declare
                   El : Iir;
                   Res : Natural;
+                  List : Iir_List;
                begin
                   Res := 2;
-                  El := Get_Element_Declaration_Chain (Get_Base_Type (Def));
-                  while El /= Null_Iir loop
+                  List := Get_Elements_Declaration_List (Get_Base_Type (Def));
+                  for I in Natural loop
+                     El := Get_Nth_Element (List, I);
+                     exit when El = Null_Iir;
                      Res := Res + Get_File_Signature_Length (Get_Type (El));
-                     El := Get_Chain (El);
                   end loop;
                   return Res;
                end;
@@ -5926,8 +5921,7 @@
                Res (Off) := Scalar_Map (Get_Info (Def).Type_Mode);
                Off := Off + 1;
             when Iir_Kind_Array_Type_Definition
-              | Iir_Kind_Array_Subtype_Definition
-              | Iir_Kind_Unconstrained_Array_Subtype_Definition =>
+              | Iir_Kind_Array_Subtype_Definition =>
                Res (Off) := '[';
                Off := Off + 1;
                Get_File_Signature (Get_Element_Subtype (Def), Res, Off);
@@ -5937,13 +5931,15 @@
               | Iir_Kind_Record_Subtype_Definition =>
                declare
                   El : Iir;
+                  List : Iir_List;
                begin
                   Res (Off) := '<';
                   Off := Off + 1;
-                  El := Get_Element_Declaration_Chain (Get_Base_Type (Def));
-                  while El /= Null_Iir loop
+                  List := Get_Elements_Declaration_List (Get_Base_Type (Def));
+                  for I in Natural loop
+                     El := Get_Nth_Element (List, I);
+                     exit when El = Null_Iir;
                      Get_File_Signature (Get_Type (El), Res, Off);
-                     El := Get_Chain (El);
                   end loop;
                   Res (Off) := '>';
                   Off := Off + 1;
@@ -5963,7 +5959,7 @@
             return;
          end if;
          declare
-            Len : Natural := Get_File_Signature_Length (Type_Name);
+            Len : constant Natural := Get_File_Signature_Length (Type_Name);
             Sig : String (1 .. Len + 2);
             Off : Natural := 1;
          begin
@@ -6505,6 +6501,7 @@
       procedure Translate_Record_Type (Def : Iir_Record_Type_Definition)
       is
          El_List : O_Element_List;
+         List : Iir_List;
          El : Iir_Element_Declaration;
          Info : Type_Info_Acc;
          Field_Info : Ortho_Info_Acc;
@@ -6519,8 +6516,10 @@
       begin
          Info := Get_Info (Def);
          Need_Size := False;
-         El := Get_Element_Declaration_Chain (Def);
-         while El /= Null_Iir loop
+         List := Get_Elements_Declaration_List (Def);
+         for I in Natural loop
+            El := Get_Nth_Element (List, I);
+            exit when El = Null_Iir;
             El_Type := Get_Type (El);
             if Get_Info (El_Type) = null then
                Push_Identifier_Prefix (Mark, Get_Identifier (El));
@@ -6531,20 +6530,19 @@
                Need_Size := True;
             end if;
             Field_Info := Add_Info (El, Kind_Field);
-            El := Get_Chain (El);
          end loop;
 
          Info.Ortho_Type (Mode_Signal) := O_Tnode_Null;
          for Kind in Mode_Value .. Type_To_Last_Object_Kind (Def) loop
             Start_Record_Type (El_List);
-            El := Get_Element_Declaration_Chain (Def);
-            while El /= Null_Iir loop
+            for I in Natural loop
+               El := Get_Nth_Element (List, I);
+               exit when El = Null_Iir;
                Field_Info := Get_Info (El);
                El_Tinfo := Get_Info (Get_Type (El));
                New_Record_Field (El_List, Field_Info.Field_Node (Kind),
                                  Create_Identifier_Without_Prefix (El),
                                  Chap4.Get_Element_Type (El_Tinfo, Kind));
-               El := Get_Chain (El);
             end loop;
             Finish_Record_Type (El_List, Info.Ortho_Type (Kind));
          end loop;
@@ -6561,6 +6559,7 @@
         (Def : Iir_Record_Type_Definition; Kind : Object_Kind_Type)
       is
          Base : O_Dnode;
+         List : Iir_List;
          El : Iir_Element_Declaration;
 
          function Get_Field_Lnode
@@ -6601,14 +6600,15 @@
              Char_Ptr_Type));
 
          --  Set memory for each complex element.
-         El := Get_Element_Declaration_Chain (Def);
-         while El /= Null_Iir loop
+         List := Get_Elements_Declaration_List (Def);
+         for I in Natural loop
+            El := Get_Nth_Element (List, I);
+            exit when El = Null_Iir;
             El_Type := Get_Type (El);
             if Get_Info (El_Type).C /= null then
                --  Complex type.
                Update_Field (El_Type, Mem, Kind);
             end if;
-            El := Get_Chain (El);
          end loop;
          Chap2.Finish_Subprg_Instance_Use (Info.C.Builder_Instance (Kind));
          New_Return_Stmt (New_Obj_Value (Mem));
@@ -6630,8 +6630,7 @@
          D_Info := Get_Info (D_Type);
          Def_Info := Get_Info (Def);
 
-         if Get_Kind (D_Type) in Iir_Kinds_Unconstrained_Array_Type_Definition
-         then
+         if not Is_Fully_Constrained_Type (D_Type) then
             --  An access type to an unconstrained type definition is a fat
             --  pointer.
             Def_Info.Type_Mode := Type_Mode_Fat_Acc;
@@ -6822,6 +6821,7 @@
          Mark : Id_Mark_Type;
          Info : Type_Info_Acc;
          Lock_Field : O_Fnode;
+         pragma Unreferenced (Lock_Field);
       begin
          Decl := Get_Protected_Type_Declaration (Bod);
          Info := Get_Info (Decl);
@@ -7006,10 +7006,12 @@
                Create_Scalar_Type_Range (Def, Target);
 
             when Iir_Kind_Array_Subtype_Definition =>
-               Info := Get_Info (Def);
-               if not Info.T.Static_Bounds then
-                  Target := Get_Var (Info.T.Array_Bounds);
-                  Create_Array_Subtype_Bounds (Def, Target);
+               if Get_Constraint_State (Def) = Fully_Constrained then
+                  Info := Get_Info (Def);
+                  if not Info.T.Static_Bounds then
+                     Target := Get_Var (Info.T.Array_Bounds);
+                     Create_Array_Subtype_Bounds (Def, Target);
+                  end if;
                end if;
 
             when Iir_Kind_Array_Type_Definition =>
@@ -7017,7 +7019,6 @@
                return;
             when Iir_Kind_Access_Type_Definition
               | Iir_Kind_Access_Subtype_Definition
-              | Iir_Kind_Unconstrained_Array_Subtype_Definition
               | Iir_Kind_File_Type_Definition
               | Iir_Kind_Record_Type_Definition
               | Iir_Kind_Record_Subtype_Definition
@@ -7078,21 +7079,23 @@
                      end if;
                   when Type_Mode_Record =>
                      declare
+                        List : Iir_List;
                         El : Iir_Element_Declaration;
                         N_Res : O_Enode;
                      begin
                         V := New_Sizeof (Info.Ortho_Type (Kind),
                                          Ghdl_Index_Type);
-                        El := Get_Element_Declaration_Chain
+                        List := Get_Elements_Declaration_List
                           (Get_Base_Type (Def));
                         Res := New_Lit (V);
-                        while El /= Null_Iir loop
+                        for I in Natural loop
+                           El := Get_Nth_Element (List, I);
+                           exit when El = Null_Iir;
                            N_Res := Get_Additionnal_Size (Get_Type (El), Kind);
                            if N_Res /= O_Enode_Null then
                               Res := New_Dyadic_Op
                                 (ON_Add_Ov, Res, N_Res);
                            end if;
-                           El := Get_Chain (El);
                         end loop;
                      end;
                   when Type_Mode_Ptr_Array =>
@@ -7192,14 +7195,16 @@
                declare
                   El : Iir;
                   Asub : Iir;
+                  List : Iir_List;
                begin
-                  El := Get_Element_Declaration_Chain (Def);
-                  while El /= Null_Iir loop
+                  List := Get_Elements_Declaration_List (Def);
+                  for I in Natural loop
+                     El := Get_Nth_Element (List, I);
+                     exit when El = Null_Iir;
                      Asub := Get_Type (El);
                      if Is_Anonymous_Type_Definition (Asub) then
                         Handle_A_Subtype (Asub);
                      end if;
-                     El := Get_Chain (El);
                   end loop;
                end;
             when others =>
@@ -7308,7 +7313,6 @@
                                                Subtype_Info : Type_Info_Acc;
                                                Base_Info : Type_Info_Acc)
       is
-         Base_Type : Iir;
          Rng : Iir;
          Lo, Hi : Iir;
       begin
@@ -7325,7 +7329,6 @@
             Subtype_Info.T.Nocheck_Low := False;
          else
             --  Bounds are locally static.
-            Base_Type := Get_Base_Type (Def);
             Get_Low_High_Limit (Rng, Lo, Hi);
             Subtype_Info.T.Nocheck_Hi :=
               Is_Equal_Limit (Hi, True, Def, Base_Info.Type_Mode);
@@ -7427,21 +7430,26 @@
             -- Info.Type_Range_Type := Create_Array_Type_Bounds_Type (Def, Id);
 
             when Iir_Kind_Array_Subtype_Definition =>
-               if Base_Info = null or else Base_Info.Type_Incomplete then
-                  declare
-                     Mark : Id_Mark_Type;
-                  begin
-                     Push_Identifier_Prefix (Mark, "BT");
-                     Translate_Type_Definition (Base_Type);
-                     Pop_Identifier_Prefix (Mark);
-                     Base_Info := Get_Info (Base_Type);
-                  end;
-               end if;
-               Translate_Array_Subtype (Def);
-               Info.T := Base_Info.T;
-               --Info.Type_Range_Type := Base_Info.Type_Range_Type;
-               if With_Vars then
-                  Create_Array_Subtype_Bounds_Var (Def, False);
+               if Get_Index_Constraint_Flag (Def) then
+                  if Base_Info = null or else Base_Info.Type_Incomplete then
+                     declare
+                        Mark : Id_Mark_Type;
+                     begin
+                        Push_Identifier_Prefix (Mark, "BT");
+                        Translate_Type_Definition (Base_Type);
+                        Pop_Identifier_Prefix (Mark);
+                        Base_Info := Get_Info (Base_Type);
+                     end;
+                  end if;
+                  Translate_Array_Subtype (Def);
+                  Info.T := Base_Info.T;
+                  --Info.Type_Range_Type := Base_Info.Type_Range_Type;
+                  if With_Vars then
+                     Create_Array_Subtype_Bounds_Var (Def, False);
+                  end if;
+               else
+                  Free_Info (Def);
+                  Set_Info (Def, Base_Info);
                end if;
 
             when Iir_Kind_Record_Type_Definition =>
@@ -7449,14 +7457,13 @@
                Info.T := Ortho_Info_Type_Record_Init;
 
             when Iir_Kind_Record_Subtype_Definition
-              | Iir_Kind_Access_Subtype_Definition
-              | Iir_Kind_Unconstrained_Array_Subtype_Definition =>
+              | Iir_Kind_Access_Subtype_Definition =>
                Free_Info (Def);
                Set_Info (Def, Base_Info);
 
             when Iir_Kind_Access_Type_Definition =>
                declare
-                  Dtype : Iir := Get_Designated_Type (Def);
+                  Dtype : constant Iir := Get_Designated_Type (Def);
                begin
                   --  Translate the subtype
                   if Is_Anonymous_Type_Definition (Dtype) then
@@ -7487,10 +7494,7 @@
 
       procedure Translate_Bool_Type_Definition (Def : Iir)
       is
-         Decl : Iir;
-         Id : Name_Id;
          Info : Type_Info_Acc;
-         Base_Type : Iir;
       begin
          --  If the definition is already translated, return now.
          Info := Get_Info (Def);
@@ -7499,10 +7503,6 @@
          end if;
 
          Info := Add_Info (Def, Kind_Type);
-         Base_Type := Get_Base_Type (Def);
-         Decl := Get_Type_Declarator (Def);
-
-         Id := Get_Identifier (Decl);
 
          if Get_Kind (Def) /= Iir_Kind_Enumeration_Type_Definition then
             raise Internal_Error;
@@ -7577,9 +7577,7 @@
       procedure Elab_Type_Definition (Def : Iir);
       procedure Elab_Type_Definition_Depend is new Handle_Anonymous_Subtypes
         (Handle_A_Subtype => Elab_Type_Definition);
-      procedure Elab_Type_Definition (Def : Iir)
-      is
-         Info : Type_Info_Acc;
+      procedure Elab_Type_Definition (Def : Iir) is
       begin
          case Get_Kind (Def) is
             when Iir_Kind_Incomplete_Type_Definition =>
@@ -7604,8 +7602,6 @@
             return;
          end if;
 
-         Info := Get_Info (Def);
-
          Elab_Type_Definition_Depend (Def);
 
          Create_Type_Definition_Type_Range (Def);
@@ -7865,13 +7861,10 @@
       function Get_Array_Type_Length (Atype : Iir) return O_Enode
       is
          Index_List : Iir_List;
-         Index_Type : Iir;
          Nbr_Dim : Natural;
          Dim_Length : O_Enode;
          Res : O_Enode;
          Type_Info : Type_Info_Acc;
-         Binfo : Type_Info_Acc;
-         Index_Info : Type_Info_Acc;
          Bounds : Mnode;
       begin
          Index_List := Get_Index_Subtype_List (Atype);
@@ -7891,10 +7884,7 @@
                raise Internal_Error;
          end case;
 
-         Binfo := Get_Info (Get_Base_Type (Atype));
          for Dim in 1 .. Nbr_Dim loop
-            Index_Type := Get_Nth_Element (Index_List, Dim - 1);
-            Index_Info := Get_Info (Get_Base_Type (Index_Type));
             Dim_Length :=
               M2E (Range_To_Length (Bounds_To_Range (Bounds, Atype, Dim)));
             if Dim = 1 then
@@ -7909,13 +7899,10 @@
       function Get_Array_Length (Arr : Mnode; Atype : Iir) return O_Enode
       is
          Index_List : Iir_List;
-         Index_Type : Iir;
          Nbr_Dim : Natural;
          Dim_Length : O_Enode;
          Res : O_Enode;
          Type_Info : Type_Info_Acc;
-         Binfo : Type_Info_Acc;
-         Index_Info : Type_Info_Acc;
          B : Mnode;
       begin
          Index_List := Get_Index_Subtype_List (Atype);
@@ -7933,10 +7920,7 @@
                raise Internal_Error;
          end case;
 
-         Binfo := Get_Info (Get_Base_Type (Atype));
          for Dim in 1 .. Nbr_Dim loop
-            Index_Type := Get_Nth_Element (Index_List, Dim - 1);
-            Index_Info := Get_Info (Get_Base_Type (Index_Type));
             B := Get_Array_Bounds (Arr);
             Dim_Length :=
               M2E (Range_To_Length (Bounds_To_Range (B, Atype, Dim)));
@@ -7958,11 +7942,9 @@
             when Type_Mode_Fat_Array
               | Type_Mode_Fat_Acc =>
                declare
-                  F : O_Fnode;
                   Kind : Object_Kind_Type;
                begin
                   Kind := Get_Object_Kind (Arr);
-                  F := Info.T.Base_Field (Get_Object_Kind (Arr));
                   return Lp2M
                     (New_Selected_Element (M2Lv (Arr),
                                            Info.T.Base_Field (Kind)),
@@ -8144,13 +8126,16 @@
                   Kind);
             when Type_Mode_Record =>
                declare
+                  List : Iir_List;
                   El : Iir_Element_Declaration;
                   El_Type : Iir;
                   El_Info : Type_Info_Acc;
                begin
-                  El := Get_Element_Declaration_Chain
+                  List := Get_Elements_Declaration_List
                     (Get_Base_Type (Obj_Type));
-                  while El /= Null_Iir loop
+                  for I in Natural loop
+                     El := Get_Nth_Element (List, I);
+                     exit when El = Null_Iir;
                      El_Type := Get_Type (El);
                      El_Info := Get_Info (El_Type);
                      if El_Info.C /= null then
@@ -8160,7 +8145,6 @@
                            El_Type,
                            Kind);
                      end if;
-                     El := Get_Chain (El);
                   end loop;
                   --  Record is known to be complex but has no complex
                   --  element.
@@ -9204,15 +9188,17 @@
                declare
                   Sobj : Mnode;
                   El : Iir_Element_Declaration;
+                  List : Iir_List;
                begin
                   Open_Temp;
                   Sobj := Stabilize (Obj);
-                  El := Get_Element_Declaration_Chain
+                  List := Get_Elements_Declaration_List
                     (Get_Base_Type (Obj_Type));
-                  while El /= Null_Iir loop
+                  for I in Natural loop
+                     El := Get_Nth_Element (List, I);
+                     exit when El = Null_Iir;
                      Init_Object (Chap6.Translate_Selected_Element (Sobj, El),
                                   Get_Type (El));
-                     El := Get_Chain (El);
                   end loop;
                   Close_Temp;
                end;
@@ -9364,7 +9350,7 @@
             if Get_Info (Obj).Object_Static then
                return;
             end if;
-            if Get_Deferred_Declaration_Flag (Obj) = True then
+            if Get_Deferred_Declaration_Flag (Obj) then
                --  No code generation for a deferred constant.
                return;
             end if;
@@ -9426,21 +9412,23 @@
                                    Get_Element_Subtype (Sig_Type)));
             when Type_Mode_Record =>
                declare
+                  List : Iir_List;
                   El : Iir;
                   Res : O_Enode;
                   E : O_Enode;
                begin
-                  El :=
-                    Get_Element_Declaration_Chain (Get_Base_Type (Sig_Type));
+                  List :=
+                    Get_Elements_Declaration_List (Get_Base_Type (Sig_Type));
                   Res := O_Enode_Null;
-                  while El /= Null_Iir loop
+                  for I in Natural loop
+                     El := Get_Nth_Element (List, I);
+                     exit when El = Null_Iir;
                      E := Get_Nbr_Signals (Mnode_Null, Get_Type (El));
                      if Res /= O_Enode_Null then
                         Res := New_Dyadic_Op (ON_Add_Ov, Res, E);
                      else
                         Res := E;
                      end if;
-                     El := Get_Chain (El);
                   end loop;
                   if Res = O_Enode_Null then
                      return New_Lit (Ghdl_Index_0);
@@ -9485,8 +9473,9 @@
                   declare
                      Element : Iir;
                   begin
-                     Element := Get_Element_Declaration_Chain
-                       (Get_Base_Type (Res_Type));
+                     Element := Get_First_Element
+                       (Get_Elements_Declaration_List
+                          (Get_Base_Type (Res_Type)));
                      Res := Chap6.Translate_Selected_Element (Res, Element);
                      Res_Type := Get_Type (Element);
                   end;
@@ -9782,6 +9771,11 @@
             Name_Node := Get_Var (Sig_Info.Object_Driver,
                                   Type_Info, Mode_Value);
             Name_Node := Stabilize (Name_Node);
+            --  Copy bounds from signal.
+            New_Assign_Stmt
+              (M2Lp (Chap3.Get_Array_Bounds (Name_Node)),
+               M2Addr (Chap3.Get_Array_Bounds (Chap6.Translate_Name (Decl))));
+            --  Allocate base.
             Chap3.Allocate_Fat_Array_Base (Alloc_System, Name_Node, Sig_Type);
          elsif Type_Info.C /= null then
             Name_Node := Get_Var (Sig_Info.Object_Driver,
@@ -9801,7 +9795,6 @@
         (Decl : Iir; Parent : Iir; Check_Null : Boolean)
       is
          Sig_Type : Iir;
-         Type_Info : Type_Info_Acc;
          Name_Node : Mnode;
          Val : Iir;
          Data : Elab_Signal_Data;
@@ -9812,7 +9805,6 @@
          Open_Temp;
 
          Sig_Type := Get_Type (Decl);
-         Type_Info := Get_Info (Sig_Type);
          Base_Decl := Get_Base_Name (Decl);
 
          --  Set the name of the signal.
@@ -10231,7 +10223,6 @@
          Name : Iir;
          Name_Node : Mnode;
          Alias_Node : Mnode;
-         N_Info : Type_Info_Acc;
          Alias_Info : Alias_Info_Acc;
          Name_Type : Iir;
          Tinfo : Type_Info_Acc;
@@ -10248,7 +10239,6 @@
          Name_Type := Get_Type (Name);
          Name_Node := Chap6.Translate_Name (Name);
          Kind := Get_Object_Kind (Name_Node);
-         N_Info := Get_Info (Name_Type);
 
          case Tinfo.Type_Mode is
             when Type_Mode_Fat_Array =>
@@ -11068,6 +11058,9 @@
          Push_Identifier_Prefix
            (Mark3, Get_Identifier (Get_Base_Name (Formal)));
 
+         --  Handle anonymous subtypes.
+         Chap3.Translate_Anonymous_Type_Definition (Out_Type, False);
+         Chap3.Translate_Anonymous_Type_Definition (In_Type, False);
          Out_Info := Get_Info (Out_Type);
          In_Info := Get_Info (In_Type);
 
@@ -11794,9 +11787,7 @@
       begin
          Actual_Type := Get_Type (Actual);
          Open_Temp;
-         if Get_Kind (Actual_Type)
-           not in Iir_Kinds_Unconstrained_Array_Type_Definition
-         then
+         if Is_Fully_Constrained_Type (Actual_Type) then
             Chap3.Create_Array_Subtype (Actual_Type, False);
             Tinfo := Get_Info (Actual_Type);
             Bounds := Chap3.Get_Array_Type_Bounds (Actual_Type);
@@ -12086,13 +12077,11 @@
                      Open_Temp;
                      declare
                         Actual_Type : Iir;
-                        Tinfo : Type_Info_Acc;
                         Bounds : Mnode;
                         Formal_Node : Mnode;
                      begin
                         Actual_Type := Get_Type (Get_Default_Value (Formal));
                         Chap3.Create_Array_Subtype (Actual_Type, True);
-                        Tinfo := Get_Info (Actual_Type);
                         Bounds := Chap3.Get_Array_Type_Bounds (Actual_Type);
                         Formal_Node := Chap6.Translate_Name (Formal);
                         New_Assign_Stmt
@@ -12104,13 +12093,11 @@
                      Open_Temp;
                      declare
                         Actual_Type : Iir;
-                        Tinfo : Type_Info_Acc;
                         Bounds : Mnode;
                         Formal_Node : Mnode;
                      begin
                         Actual_Type := Get_Actual_Type (Assoc);
                         Chap3.Create_Array_Subtype (Actual_Type, False);
-                        Tinfo := Get_Info (Actual_Type);
                         Bounds := Chap3.Get_Array_Type_Bounds (Actual_Type);
                         Formal_Node := Chap6.Translate_Name (Formal);
                         New_Assign_Stmt
@@ -12522,7 +12509,6 @@
          Index : O_Enode;
          Index_Base_Type : Iir;
          Index_Range : Iir;
-         Index_Info : Type_Info_Acc;
          V : Iir_Int64;
          B : Iir_Int64;
       begin
@@ -12539,8 +12525,6 @@
               (New_Unsigned_Literal (Ghdl_Index_Type, Unsigned_64 (B)));
          else
             Index_Base_Type := Get_Base_Type (Index_Type);
-            Index_Info := Get_Info (Index_Base_Type);
-
             Index := Chap7.Translate_Expression (Expr, Index_Base_Type);
 
             if Get_Direction (Index_Range) = Iir_To then
@@ -12598,7 +12582,6 @@
          Ibasetype : Iir;
          Prefix_Info : Type_Info_Acc;
          Nbr_Dim : Natural;
-         Fat_Ptr : O_Lnode;
          Range_Ptr : Mnode;
       begin
          Prefix_Type := Get_Type (Get_Prefix (Expr));
@@ -12610,7 +12593,6 @@
                Prefix := Prefix_Orig;
             when Type_Mode_Ptr_Array =>
                --  FIXME: should save the bounds address ?
-               Fat_Ptr := O_Lnode_Null;
                Prefix := Prefix_Orig;
             when others =>
                raise Internal_Error;
@@ -12725,7 +12707,6 @@
          --  Type of the slice.
          Slice_Type : Iir;
          Slice_Info : Type_Info_Acc;
-         Slice_Binfo : Type_Info_Acc;
 
          --  Type of the first (and only) index of the prefix array type.
          Index_Type : Iir;
@@ -12822,8 +12803,6 @@
 
          Data.Is_Off := False;
 
-         Slice_Binfo := Get_Info (Get_Base_Type (Slice_Type));
-
          --  Save prefix.
          Prefix_Var := Stabilize (Prefix);
 
@@ -12938,12 +12917,6 @@
         (Prefix : Mnode; Expr : Iir_Slice_Name; Data : Slice_Name_Data)
         return Mnode
       is
-         --  Type of the prefix.
-         Prefix_Type : Iir;
-
-         --  Type info of the prefix.
-         Prefix_Info : Type_Info_Acc;
-
          --  Type of the slice.
          Slice_Type : Iir;
          Slice_Info : Type_Info_Acc;
@@ -12956,11 +12929,9 @@
       begin
          --  Evaluate the prefix.
          Slice_Type := Get_Type (Expr);
-         Prefix_Type := Get_Type (Get_Prefix (Expr));
 
          Kind := Get_Object_Kind (Prefix);
 
-         Prefix_Info := Get_Info (Prefix_Type);
          Slice_Info := Get_Info (Slice_Type);
 
          if Data.Is_Off then
@@ -13793,6 +13764,12 @@
             when others =>
                Error_Kind ("tranlate_numeric_literal", Expr);
          end case;
+      exception
+         when Constraint_Error =>
+            --  Can be raised by Get_Physical_Unit_Value because of the kludge
+            --  on staticness.
+            Error_Msg_Elab ("numeric literal not in range", Expr);
+            return New_Signed_Literal (Res_Type, 0);
       end Translate_Numeric_Literal;
 
       function Translate_Numeric_Literal (Expr : Iir; Res_Type : Iir)
@@ -14150,14 +14127,12 @@
       is
          Res : O_Dnode;
          Type_Info : Type_Info_Acc;
-         Expr_Type_Info : Type_Info_Acc;
       begin
          -- FIXME: to do.
          --  Be sure the bounds variable was created.
          --  This may be necessary for on-the-fly types, such as strings.
          Chap3.Create_Array_Subtype (Expr_Type, True);
 
-         Expr_Type_Info := Get_Info (Expr_Type);
          Type_Info := Get_Info (Atype);
          Res := Create_Temp (Type_Info.Ortho_Type (Kind));
          New_Assign_Stmt
@@ -14372,7 +14347,6 @@
          Res : O_Dnode;
          Res_Type : O_Tnode;
          If_Blk : O_If_Block;
-         Op : ON_Op_Kind;
          Val : Integer;
          V : O_Cnode;
          Kind : Iir_Predefined_Functions;
@@ -14391,22 +14365,18 @@
          case Kind is
             when Iir_Predefined_Bit_And
               | Iir_Predefined_Boolean_And =>
-               Op := ON_And;
                Invert := False;
                Val := 1;
             when Iir_Predefined_Bit_Nand
               | Iir_Predefined_Boolean_Nand =>
-               Op := ON_And;
                Invert := True;
                Val := 1;
             when Iir_Predefined_Bit_Or
               | Iir_Predefined_Boolean_Or =>
-               Op := ON_Or;
                Invert := False;
                Val := 0;
             when Iir_Predefined_Bit_Nor
               | Iir_Predefined_Boolean_Nor =>
-               Op := ON_Or;
                Invert := True;
                Val := 0;
             when others =>
@@ -15292,11 +15262,13 @@
       procedure Translate_Record_Aggregate (Target : Mnode; Aggr : Iir)
       is
          Targ : Mnode;
-         Aggr_Type : Iir := Get_Type (Aggr);
-         Aggr_Base_Type : Iir_Record_Type_Definition :=
+         Aggr_Type : constant Iir := Get_Type (Aggr);
+         Aggr_Base_Type : constant Iir_Record_Type_Definition :=
            Get_Base_Type (Aggr_Type);
-         Nbr_El : Iir_Index32 :=
-           Get_Number_Element_Declaration (Aggr_Base_Type);
+         El_List : constant Iir_List :=
+           Get_Elements_Declaration_List (Aggr_Base_Type);
+         El_Index : Natural;
+         Nbr_El : constant Natural := Get_Nbr_Elements (El_List);
 
          --  Record which elements of the record have been set.  The 'others'
          --  clause applies to all elements not already set.
@@ -15312,16 +15284,15 @@
          begin
             Translate_Assign (Chap6.Translate_Selected_Element (Targ, El),
                               El_Expr, Get_Type (El));
-            Set_Array (Get_Element_Position (El)) := True;
+            Set_Array (Natural (Get_Element_Position (El))) := True;
          end Set_El;
 
          Assoc : Iir;
-         El : Iir;
          N_El_Expr : Iir;
       begin
          Open_Temp;
          Targ := Stabilize (Target);
-         El := Get_Element_Declaration_Chain (Aggr_Base_Type);
+         El_Index := 0;
          Assoc := Get_Association_Choices_Chain (Aggr);
          while Assoc /= Null_Iir loop
             N_El_Expr := Get_Associated (Assoc);
@@ -15330,20 +15301,17 @@
             end if;
             case Get_Kind (Assoc) is
                when Iir_Kind_Choice_By_None =>
-                  Set_El (El);
-                  El := Get_Chain (El);
+                  Set_El (Get_Nth_Element (El_List, El_Index));
+                  El_Index := El_Index + 1;
                when Iir_Kind_Choice_By_Name =>
                   Set_El (Get_Name (Assoc));
-                  El := Null_Iir;
+                  El_Index := Natural'Last;
                when Iir_Kind_Choice_By_Others =>
-                  El := Get_Element_Declaration_Chain (Aggr_Base_Type);
                   for J in Set_Array'Range loop
                      if not Set_Array (J) then
-                        Set_El (El);
+                        Set_El (Get_Nth_Element (El_List, J));
                      end if;
-                     El := Get_Chain (El);
                   end loop;
-                  pragma Assert (El = Null_Iir);
                when others =>
                   Error_Kind ("translate_record_aggregate", Assoc);
             end case;
@@ -15360,7 +15328,6 @@
          Bounds : Mnode;
          Var_Index : O_Dnode;
          Targ : Mnode;
-         Tinfo : Type_Info_Acc;
 
          Range_Ptr : Mnode;
          Rinfo : Type_Info_Acc;
@@ -15400,7 +15367,6 @@
          If_Blk : O_If_Block;
          Op : ON_Op_Kind;
       begin
-         Tinfo := Get_Info (Target_Type);
          Open_Temp;
          Targ := Stabilize (Target);
          Base := Stabilize (Chap3.Get_Array_Base (Targ));
@@ -15723,13 +15689,14 @@
                --  If res_type = expr_type, do not convert.
                --  FIXME: range check ?
                return New_Convert_Ov (Expr, Res_Info.Ortho_Type (Mode_Value));
-            when Iir_Kind_Array_Subtype_Definition =>
-               return Translate_Array_Subtype_Conversion
-                 (Expr, Expr_Type, Res_Type, Loc);
-            when Iir_Kind_Array_Type_Definition
-              | Iir_Kind_Unconstrained_Array_Subtype_Definition =>
-               return Translate_Fat_Array_Type_Conversion
-                 (Expr, Expr_Type, Res_Type, Loc);
+            when Iir_Kinds_Array_Type_Definition =>
+               if Get_Constraint_State (Res_Type) = Fully_Constrained then
+                  return Translate_Array_Subtype_Conversion
+                    (Expr, Expr_Type, Res_Type, Loc);
+               else
+                  return Translate_Fat_Array_Type_Conversion
+                    (Expr, Expr_Type, Res_Type, Loc);
+               end if;
             when others =>
                Error_Kind ("translate_type_conversion", Res_Type);
          end case;
@@ -16034,7 +16001,6 @@
                declare
                   Unit : Iir;
                   Unit_Info : Object_Info_Acc;
-                  Unit_Type : Type_Info_Acc;
                begin
                   Unit := Get_Unit_Name (Expr);
                   Unit_Info := Get_Info (Unit);
@@ -16043,7 +16009,6 @@
                        (Translate_Static_Expression (Expr, Rtype));
                   else
                      --  Time units might be not locally static.
-                     Unit_Type := Get_Info (Expr_Type);
                      return New_Dyadic_Op
                        (ON_Mul_Ov,
                         New_Lit (New_Signed_Literal
@@ -16057,7 +16022,6 @@
                declare
                   Unit : Iir;
                   Unit_Info : Object_Info_Acc;
-                  Unit_Type : Type_Info_Acc;
                   L, R : O_Enode;
                begin
                   Unit := Get_Unit_Name (Expr);
@@ -16067,7 +16031,6 @@
                        (Translate_Static_Expression (Expr, Rtype));
                   else
                      --  Time units might be not locally static.
-                     Unit_Type := Get_Info (Expr_Type);
                      L := New_Lit
                        (New_Float_Literal
                         (Ghdl_Real_Type, IEEE_Float_64 (Get_Fp_Value (Expr))));
@@ -16207,11 +16170,9 @@
               | Iir_Kind_Attribute_Value =>
                declare
                   L : Mnode;
-                  Expr_Type_Info : Type_Info_Acc;
                begin
                   L := Chap6.Translate_Name (Expr);
 
-                  Expr_Type_Info := Get_Info (Expr_Type);
                   Res := M2E (L);
                   if Get_Object_Kind (L) = Mode_Signal then
                      Res := Translate_Signal (Res, Expr_Type);
@@ -17023,6 +16984,7 @@
          If_Blk : O_If_Block;
          Le, Re : Mnode;
 
+         El_List : Iir_List;
          El : Iir_Element_Declaration;
       begin
          Rec_Type := Get_Type (Get_Interface_Declaration_Chain (Subprg));
@@ -17052,8 +17014,10 @@
          R := Dp2M (Var_R, Info, Mode_Value);
 
          --   Compare each element.
-         El := Get_Element_Declaration_Chain (Rec_Type);
-         while El /= Null_Iir loop
+         El_List := Get_Elements_Declaration_List (Rec_Type);
+         for I in Natural loop
+            El := Get_Nth_Element (El_List, I);
+            exit when El = Null_Iir;
             Le := Chap6.Translate_Selected_Element (L, El);
             Re := Chap6.Translate_Selected_Element (R, El);
 
@@ -17065,7 +17029,6 @@
             New_Return_Stmt (New_Lit (Std_Boolean_False_Node));
             Finish_If_Stmt (If_Blk);
             Close_Temp;
-            El := Get_Chain (El);
          end loop;
          New_Return_Stmt (New_Lit (Std_Boolean_True_Node));
          Chap2.Finish_Subprg_Instance_Use (Subprg);
@@ -17907,18 +17870,20 @@
                   New_Procedure_Call (Assocs);
                when Type_Mode_Record =>
                   declare
+                     El_List : Iir_List;
                      El : Iir;
                      Val1 : Mnode;
                   begin
                      Open_Temp;
                      Val1 := Stabilize (Val);
-                     El := Get_Element_Declaration_Chain
+                     El_List := Get_Elements_Declaration_List
                        (Get_Base_Type (Val_Type));
-                     while El /= Null_Iir loop
+                     for I in Natural loop
+                        El := Get_Nth_Element (El_List, I);
+                        exit when El = Null_Iir;
                         Translate_Rw
                           (Chap6.Translate_Selected_Element (Val1, El),
                            Get_Type (El), Proc);
-                        El := Get_Chain (El);
                      end loop;
                      Close_Temp;
                   end;
@@ -18741,19 +18706,20 @@
         (Targ : Iir_Aggregate; Targ_Type : Iir; Val : Mnode)
       is
          Aggr_El : Iir;
-         El : Iir_Element_Declaration;
+         El_List : Iir_List;
+         El_Index : Natural;
          Elem : Iir;
       begin
-         El := Get_Element_Declaration_Chain (Get_Base_Type (Targ_Type));
+         El_List := Get_Elements_Declaration_List (Get_Base_Type (Targ_Type));
+         El_Index := 0;
          Aggr_El := Get_Association_Choices_Chain (Targ);
          while Aggr_El /= Null_Iir loop
             case Get_Kind (Aggr_El) is
                when Iir_Kind_Choice_By_None =>
-                  Elem := El;
-                  El := Get_Chain (El);
+                  Elem := Get_Nth_Element (El_List, El_Index);
+                  El_Index := El_Index + 1;
                when Iir_Kind_Choice_By_Name =>
                   Elem := Get_Name (Aggr_El);
-                  El := Null_Iir;
                when others =>
                   Error_Kind ("translate_variable_rec_aggr", Aggr_El);
             end case;
@@ -19406,7 +19372,6 @@
       is
          Constr : O_Assoc_List;
          Conv_Info : Subprg_Info_Acc;
-         Res_Info : Type_Info_Acc;
          Res : O_Dnode;
          Imp : Iir;
       begin
@@ -19441,7 +19406,6 @@
 
                   New_Association (Constr, M2E (Src));
 
-                  Res_Info := Get_Info (Get_Return_Type (Imp));
                   if Conv_Info.Res_Interface /= O_Dnode_Null then
                      --  Composite result.
                      New_Procedure_Call (Constr);
@@ -19464,8 +19428,9 @@
       is
          type Mnode_Array is array (Natural range <>) of Mnode;
          type O_Enode_Array is array (Natural range <>) of O_Enode;
-         Assoc_Chain : Iir := Get_Parameter_Association_Chain (Stmt);
-         Nbr_Assoc : Natural := Iir_Chains.Get_Chain_Length (Assoc_Chain);
+         Assoc_Chain : constant Iir := Get_Parameter_Association_Chain (Stmt);
+         Nbr_Assoc : constant Natural :=
+           Iir_Chains.Get_Chain_Length (Assoc_Chain);
          Params : Mnode_Array (0 .. Nbr_Assoc - 1);
          E_Params : O_Enode_Array (0 .. Nbr_Assoc - 1);
          Imp : Iir;
@@ -19480,7 +19445,6 @@
          Base_Formal : Iir;
          Formal_Type : Iir;
          Ftype_Info : Type_Info_Acc;
-         Atype_Info : Type_Info_Acc;
          Formal_Info : Ortho_Info_Acc;
          Val : O_Enode;
          Param : Mnode;
@@ -19592,7 +19556,6 @@
                     | Iir_Kind_Signal_Interface_Declaration =>
                      Param := Chap6.Translate_Name (Act);
                      --  Atype may not have been set (eg: slice).
-                     Atype_Info := Get_Info (Actual_Type);
                      if Base_Formal /= Formal then
                         Stabilize (Param);
                         Params (Pos) := Param;
@@ -20289,20 +20252,22 @@
         (Aggr : Mnode; Target : Iir; Target_Type : Iir)
       is
          Aggr_El : Iir;
-         El_Decl : Iir_Element_Declaration;
+         El_List : Iir_List;
+         El_Index : Natural;
          Element : Iir_Element_Declaration;
       begin
-         El_Decl := Get_Element_Declaration_Chain
+         El_List := Get_Elements_Declaration_List
            (Get_Base_Type (Target_Type));
+         El_Index := 0;
          Aggr_El := Get_Association_Choices_Chain (Target);
          while Aggr_El /= Null_Iir loop
             case Get_Kind (Aggr_El) is
                when Iir_Kind_Choice_By_None =>
-                  Element := El_Decl;
-                  El_Decl := Get_Chain (El_Decl);
+                  Element := Get_Nth_Element (El_List, El_Index);
+                  El_Index := El_Index + 1;
                when Iir_Kind_Choice_By_Name =>
                   Element := Get_Name (Aggr_El);
-                  El_Decl := Null_Iir;
+                  El_Index := Natural'Last;
                when others =>
                   Error_Kind ("translate_signal_target_record_aggr", Aggr_El);
             end case;
@@ -20697,6 +20662,7 @@
             when Iir_Kind_Procedure_Call_Statement =>
                declare
                   Assocs : Iir;
+                  pragma Unreferenced (Assocs); -- FIXME
                   Call : Iir_Procedure_Call;
                   Imp : Iir;
                begin
@@ -20752,8 +20718,8 @@
    package body Chap9 is
       procedure Set_Direct_Drivers (Proc : Iir)
       is
-         Proc_Info : Proc_Info_Acc := Get_Info (Proc);
-         Drivers : Direct_Drivers_Acc := Proc_Info.Process_Drivers;
+         Proc_Info : constant Proc_Info_Acc := Get_Info (Proc);
+         Drivers : constant Direct_Drivers_Acc := Proc_Info.Process_Drivers;
          Info : Ortho_Info_Acc;
          Var : Var_Acc;
          Sig : Iir;
@@ -20777,8 +20743,8 @@
 
       procedure Reset_Direct_Drivers (Proc : Iir)
       is
-         Proc_Info : Proc_Info_Acc := Get_Info (Proc);
-         Drivers : Direct_Drivers_Acc := Proc_Info.Process_Drivers;
+         Proc_Info : constant Proc_Info_Acc := Get_Info (Proc);
+         Drivers : constant Direct_Drivers_Acc := Proc_Info.Process_Drivers;
          Info : Ortho_Info_Acc;
          Var : Var_Acc;
          Sig : Iir;
@@ -20941,6 +20907,7 @@
          Chap4.Translate_Declaration_Chain (Proc);
 
          if Flag_Direct_Drivers then
+            --  Create direct drivers.
             Drivers := Trans_Analyzes.Extract_Drivers (Proc);
             if Flag_Dump_Drivers then
                Trans_Analyzes.Dump_Drivers (Proc, Drivers);
@@ -21436,6 +21403,7 @@
          Constr : O_Assoc_List;
          Info : Proc_Info_Acc;
          List : Iir_List;
+         List_Orig : Iir_List;
          Final : Boolean;
       begin
          New_Debug_Line_Stmt (Get_Line_Number (Proc));
@@ -21473,16 +21441,11 @@
             New_Lit (New_Subprogram_Address (Info.Process_Subprg,
                                              Ghdl_Ptr_Type)));
          Rtis.Associate_Rti_Context (Constr, Proc);
---          New_Association
---            (Constr,
---             New_Address (New_Selected_Element
---                          (Get_Instance_Ref (Info.Process_Decls_Type),
---                           Info.Process_Name),
---                          Ghdl_Instance_Name_Acc));
          New_Procedure_Call (Constr);
 
          --  First elaborate declarations since a driver may depend on
          --  an alias declaration.
+         --  Also, with vhdl 08 a sensitivity element may depend on an alias.
          Chap4.Elab_Declaration_Chain (Proc, Final);
 
          --  Register drivers.
@@ -21528,9 +21491,17 @@
          end if;
 
          if Is_Sensitized then
-            List := Get_Sensitivity_List (Proc);
+            List_Orig := Get_Sensitivity_List (Proc);
+            if List_Orig = Iir_List_All then
+               List := Canon.Canon_Extract_Process_Sensitivity (Proc);
+            else
+               List := List_Orig;
+            end if;
             Destroy_Types_In_List (List);
             Register_Signal_List (List, Ghdl_Process_Add_Sensitivity);
+            if List_Orig = Iir_List_All then
+               Destroy_Iir_List (List);
+            end if;
          end if;
 
          Pop_Scope (Info.Process_Decls_Type);
@@ -21640,7 +21611,7 @@
                   end if;
                end Get_Arch_Name;
 
-               Str : String :=
+               Str : constant String :=
                  Image_Identifier (Get_Library (Get_Design_File (Entity_Unit)))
                  & "__" & Image_Identifier (Entity) & "__"
                  & Get_Arch_Name & "__";
@@ -23260,28 +23231,22 @@
          return Translate_Low_High_Type_Attribute (Atype, True);
       end Translate_Low_Type_Attribute;
 
-      function Translate_Left_Type_Attribute (Atype : Iir) return O_Enode
-      is
-         Info : Type_Info_Acc;
+      function Translate_Left_Type_Attribute (Atype : Iir) return O_Enode is
       begin
          if Get_Type_Staticness (Atype) = Locally then
             return New_Lit (Chap7.Translate_Static_Range_Left
                             (Get_Range_Constraint (Atype), Atype));
          else
-            Info := Get_Info (Atype);
             return M2E (Chap3.Range_To_Left (Chap3.Type_To_Range (Atype)));
          end if;
       end Translate_Left_Type_Attribute;
 
-      function Translate_Right_Type_Attribute (Atype : Iir) return O_Enode
-      is
-         Info : Type_Info_Acc;
+      function Translate_Right_Type_Attribute (Atype : Iir) return O_Enode is
       begin
          if Get_Type_Staticness (Atype) = Locally then
             return New_Lit (Chap7.Translate_Static_Range_Right
                             (Get_Range_Constraint (Atype), Atype));
          else
-            Info := Get_Info (Atype);
             return M2E (Chap3.Range_To_Right (Chap3.Type_To_Range (Atype)));
          end if;
       end Translate_Right_Type_Attribute;
@@ -25149,8 +25114,9 @@
          end if;
 
          declare
-            Lit_List : Iir_List := Get_Enumeration_Literal_List (Atype);
-            Nbr_Lit : Integer := Get_Nbr_Elements (Lit_List);
+            Lit_List : constant Iir_List :=
+              Get_Enumeration_Literal_List (Atype);
+            Nbr_Lit : constant Integer := Get_Nbr_Elements (Lit_List);
             Lit : Iir;
 
             type Dnode_Array is array (Natural range <>) of O_Dnode;
@@ -25460,10 +25426,6 @@
                Base_Type := Get_Base_Type (Atype);
                Base := Get_Info (Base_Type).Type_Rti;
                Kind := Ghdl_Rtik_Subtype_Access;
-            when Iir_Kind_Unconstrained_Array_Subtype_Definition =>
-               Base_Type := Get_Base_Type (Atype);
-               Base := Get_Info (Base_Type).Type_Rti;
-               Kind := Ghdl_Rtik_Subtype_Unconstrained_Array;
             when others =>
                Error_Kind ("rti.generate_fileacc_type_definition", Atype);
          end case;
@@ -25491,6 +25453,7 @@
          Nbr_Indexes : Integer;
          Index : Iir;
          Tmp : O_Dnode;
+         pragma Unreferenced (Tmp);
          Arr_Type : O_Tnode;
          Arr_Aggr : O_Array_Aggr_List;
          Val : O_Cnode;
@@ -25563,6 +25526,7 @@
             declare
                Mark : Id_Mark_Type;
                El_Rti : O_Dnode;
+               pragma Unreferenced (El_Rti);
             begin
                Push_Identifier_Prefix (Mark, "EL");
                El_Rti := Generate_Type_Definition (Element);
@@ -25603,12 +25567,18 @@
          Aggr : O_Record_Aggr_List;
          Val : O_Cnode;
          Base_Rti : O_Dnode;
+         pragma Unreferenced (Base_Rti);
          Bounds : Var_Acc;
          Name : O_Dnode;
          Kind : O_Cnode;
          Mark : Id_Mark_Type;
          Depth : Rti_Depth_Type;
       begin
+         --  FIXME: temporary work-around
+         if Get_Constraint_State (Atype) /= Fully_Constrained then
+            return;
+         end if;
+
          Info := Get_Info (Atype);
 
          Base_Type := Get_Base_Type (Atype);
@@ -25640,6 +25610,8 @@
                Kind := Ghdl_Rtik_Subtype_Array;
             when Type_Mode_Ptr_Array =>
                Kind := Ghdl_Rtik_Subtype_Array_Ptr;
+            when Type_Mode_Fat_Array =>
+               Kind := Ghdl_Rtik_Subtype_Unconstrained_Array;
             when others =>
                Error_Kind ("generate_array_subtype_definition", Atype);
          end case;
@@ -25649,7 +25621,12 @@
                                   Info.T.Rti_Max_Depth, Type_To_Mode (Info)));
          New_Record_Aggr_El (Aggr, New_Name_Address (Name));
          New_Record_Aggr_El (Aggr, New_Rti_Address (Base_Info.Type_Rti));
-         New_Record_Aggr_El (Aggr, Var_Acc_To_Loc (Bounds));
+         if Bounds = null then
+            Val := Get_Null_Loc;
+         else
+            Val := Var_Acc_To_Loc (Bounds);
+         end if;
+         New_Record_Aggr_El (Aggr, Val);
          for I in Mode_Value .. Mode_Signal loop
             case Info.Type_Mode is
                when Type_Mode_Array =>
@@ -25666,6 +25643,8 @@
                   else
                      Val := Get_Null_Loc;
                   end if;
+               when Type_Mode_Fat_Array =>
+                  Val := Get_Null_Loc;
                when others =>
                   Error_Kind ("generate_array_subtype_definition", Atype);
             end case;
@@ -25678,7 +25657,7 @@
 
       procedure Generate_Record_Type_Definition (Atype : Iir)
       is
-         El_Chain : Iir;
+         El_List : Iir_List;
          El : Iir;
          Prev : Rti_Block;
          El_Arr : O_Dnode;
@@ -25692,13 +25671,14 @@
             return;
          end if;
 
-         El_Chain := Get_Element_Declaration_Chain (Atype);
+         El_List := Get_Elements_Declaration_List (Atype);
          Max_Depth := 0;
 
          --  Generate elements.
          Push_Rti_Node (Prev, False);
-         El := El_Chain;
-         while El /= Null_Iir loop
+         for I in Natural loop
+            El := Get_Nth_Element (El_List, I);
+            exit when El = Null_Iir;
             declare
                Type_Rti : O_Dnode;
                El_Name : O_Dnode;
@@ -25742,7 +25722,6 @@
 
                Pop_Identifier_Prefix (Mark);
             end;
-            El := Get_Chain (El);
          end loop;
          El_Arr := Generate_Rti_Array (Create_Identifier ("RTIARRAY"));
          Pop_Rti_Node (Prev);
@@ -25764,8 +25743,7 @@
             New_Record_Aggr_El (Aggr, New_Name_Address (Name));
             New_Record_Aggr_El
               (Aggr, New_Unsigned_Literal
-               (Ghdl_Index_Type,
-                Unsigned_64 (Get_Number_Element_Declaration (Atype))));
+               (Ghdl_Index_Type, Unsigned_64 (Get_Nbr_Elements (El_List))));
             New_Record_Aggr_El (Aggr,
                                 New_Global_Address (El_Arr, Ghdl_Rti_Arr_Acc));
             Finish_Record_Aggr (Aggr, Res);
@@ -25830,8 +25808,7 @@
               | Iir_Kind_File_Type_Definition =>
                Generate_Fileacc_Type_Definition (Atype);
             when Iir_Kind_Record_Subtype_Definition
-              | Iir_Kind_Access_Subtype_Definition
-              | Iir_Kind_Unconstrained_Array_Subtype_Definition =>
+              | Iir_Kind_Access_Subtype_Definition =>
                --  FIXME: No separate infos (yet).
                null;
             when Iir_Kind_Record_Type_Definition =>
@@ -25950,6 +25927,7 @@
                declare
                   Mark : Id_Mark_Type;
                   Tmp : O_Dnode;
+                  pragma Unreferenced (Tmp);
                begin
                   Push_Identifier_Prefix (Mark, "OT");
                   Tmp := Generate_Type_Definition (Decl_Type);
@@ -27015,7 +26993,6 @@
 
       --  Generic pointer.
       Ghdl_Ptr_Type := New_Access_Type (Char_Type_Node);
-      Const_Ptr_Type_Node := Ghdl_Ptr_Type;
       New_Type_Decl (Get_Identifier ("__ghdl_ptr"), Ghdl_Ptr_Type);
 
       --  Create record
@@ -28252,6 +28229,7 @@
    is
       Lib_Mark, Unit_Mark : Id_Mark_Type;
       Info : Ortho_Info_Acc;
+      pragma Unreferenced (Info);
    begin
       Update_Node_Infos;
 
@@ -28384,8 +28362,7 @@
                      Free_Info (I);
                   end if;
                when Iir_Kind_Record_Subtype_Definition
-                 | Iir_Kind_Access_Subtype_Definition
-                 | Iir_Kind_Unconstrained_Array_Subtype_Definition =>
+                 | Iir_Kind_Access_Subtype_Definition =>
                   null;
                when Iir_Kind_Enumeration_Type_Definition
                  | Iir_Kind_Array_Type_Definition
@@ -28395,9 +28372,11 @@
                  | Iir_Kind_Enumeration_Subtype_Definition =>
                   Free_Type_Info (Info, True);
                when Iir_Kind_Array_Subtype_Definition =>
-                  Free_Var (Info.T.Array_Bounds);
-                  Info.T := Ortho_Info_Type_Array_Init;
-                  Free_Type_Info (Info, True);
+                  if Get_Index_Constraint_Flag (I) then
+                     Free_Var (Info.T.Array_Bounds);
+                     Info.T := Ortho_Info_Type_Array_Init;
+                     Free_Type_Info (Info, True);
+                  end if;
                when others =>
                   --  By default, info are not shared.
                   --  The exception is infos for implicit subprograms, but
@@ -28518,6 +28497,7 @@
       procedure Gen_Setup_Info
       is
          Cst : O_Dnode;
+         pragma Unreferenced (Cst);
       begin
          Cst := Create_String (Flags.Flag_String,
                                Get_Identifier ("__ghdl_flag_string"),
@@ -28555,8 +28535,7 @@
          --  Check port.
          El := Get_Port_Chain (Entity);
          while El /= Null_Iir loop
-            if Get_Kind (Get_Type (El)) in
-              Iir_Kinds_Unconstrained_Array_Type_Definition
+            if not Is_Fully_Constrained_Type (Get_Type (El))
               and then Get_Default_Value (El) = Null_Iir
             then
                Error ("(" & Disp_Node (El)
@@ -28831,6 +28810,7 @@
          F : FILEs;
          R : int;
          S : size_t;
+         pragma Unreferenced (R, S); -- FIXME
          Id : Name_Id;
          Lib : Iir_Library_Declaration;
          File : Iir_Design_File;
diff -urN ghdl-0.27/vhdl/types.ads ghdl-0.28dev/vhdl/types.ads
--- ghdl-0.27/vhdl/types.ads	2008-04-07 05:20:31.000000000 +0200
+++ ghdl-0.28dev/vhdl/types.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Interfaces;
@@ -20,10 +20,6 @@
 package Types is
    pragma Preelaborate (Types);
 
-   --  List of vhdl standards.
-   --  VHDL_93c is vhdl_93 with backward compatibility with 87 (file).
-   type Vhdl_Std_Type is (Vhdl_87, Vhdl_93c, Vhdl_93, Vhdl_00, Vhdl_02);
-
    -- A tri state type.
    type Tri_State_Type is (Unknown, False, True);
 
diff -urN ghdl-0.27/vhdl/version.ads ghdl-0.28dev/vhdl/version.ads
--- ghdl-0.27/vhdl/version.ads	2008-07-01 01:59:18.000000000 +0200
+++ ghdl-0.28dev/vhdl/version.ads	2009-09-20 09:06:46.000000000 +0200
@@ -1,5 +1,5 @@
 package Version is
    Ghdl_Release : constant String :=
-      "GHDL 0.27 (20080701) [Sokcho edition]";
-   Ghdl_Ver : constant String := "0.27";
+      "GHDL 0.28dev (20080721) [Sokcho edition]";
+   Ghdl_Ver : constant String := "0.28dev";
 end Version;
diff -urN ghdl-0.27/vhdl/xrefs.adb ghdl-0.28dev/vhdl/xrefs.adb
--- ghdl-0.27/vhdl/xrefs.adb	2005-09-22 23:33:32.000000000 +0200
+++ ghdl-0.28dev/vhdl/xrefs.adb	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with GNAT.Table;
diff -urN ghdl-0.27/vhdl/xrefs.ads ghdl-0.28dev/vhdl/xrefs.ads
--- ghdl-0.27/vhdl/xrefs.ads	2005-09-22 23:23:46.000000000 +0200
+++ ghdl-0.28dev/vhdl/xrefs.ads	2009-09-20 09:06:46.000000000 +0200
@@ -12,7 +12,7 @@
 --  for more details.
 --
 --  You should have received a copy of the GNU General Public License
---  along with GCC; see the file COPYING.  If not, write to the Free
+--  along with GHDL; see the file COPYING.  If not, write to the Free
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with Types; use Types;
